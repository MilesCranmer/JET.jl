<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Dispatch Analysis · JET.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JET.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">README</a></li><li><a class="tocitem" href="../../usages/">Usages</a></li><li><a class="tocitem" href="../../config/">Configurations</a></li><li><a class="tocitem" href="../../internals/">Internals</a></li><li><span class="tocitem">Pluggable Analysis Framework</span><ul><li><a class="tocitem" href="../../generated-plugin-api/">API</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox" checked/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Dispatch Analysis</a><ul class="internal"><li><a class="tocitem" href="#Motivation"><span>Motivation</span></a></li><li><a class="tocitem" href="#Implementation"><span>Implementation</span></a></li><li><a class="tocitem" href="#Usages"><span>Usages</span></a></li></ul></li><li><a class="tocitem" href="../find_unstable_api/">&quot;Unstable API&quot; Analysis</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Pluggable Analysis Framework</a></li><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Dispatch Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Dispatch Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aviatesk/JET.jl/blob/master/examples/dispatch_analysis.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Dispatch-Analysis"><a class="docs-heading-anchor" href="#Dispatch-Analysis">Dispatch Analysis</a><a id="Dispatch-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Dispatch-Analysis" title="Permalink"></a></h1><h2 id="Motivation"><a class="docs-heading-anchor" href="#Motivation">Motivation</a><a id="Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation" title="Permalink"></a></h2><p>When Julia compiles your code and type inference on it was not so successful, the compiler is likely to be unable to determine which method should be be called at each generic function callsite, and then it will be looked up at runtime. That is called &quot;runtime dispatch&quot;, which is known as a common source of performance problem – the compiler can&#39;t do various kinds of optimizations including inlining when it can&#39;t determine a single matching method, and method lookup also can be a bottleneck if the call happens many times.</p><p>In order to avoid this problem, we usually use <code>code_typed</code>, inspect its output, and check if there is anywhere type is not well inferred (i.e. where is &quot;type-instable&quot;) and optimization was not successful. But the problem is that <code>code_typed</code> can only present the &quot;final&quot; output of inference or optimization, and we can&#39;t inspect an entire call tree and <em>may</em> not be able to find where a problem happened and how the &quot;type instability&quot; has been propagated.</p><p>There is a nice package called <a href="https://github.com/JuliaDebug/Cthulhu.jl">Cthulhu.jl</a>, which allows us to inspect the output of <code>code_typed</code> by <em>descending</em> into a call tree, recursively. The workflow with Cthulhu is much more powerful, but still, it&#39;s tedious.</p><p>So, why not automate the workflow ? We can use JET&#39;s pluggable analysis framework and create such an analyzer that automatically analyzes your code and alarms you when it detects anywhere Julia can&#39;t determine matching method statically and thus runtime dispatch will happen at runtime.</p><h2 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h2><p>In this analysis, the analyzer will be designed to detect:</p><ol><li>where Julia compiler gives up optimization</li><li>where a runtime dispatch will happen</li></ol><p>The case 1. will happen when there are (mutually) recursive calls and Julia compiler decided not to do inference in order to make sure the inference&#39;s termination. In such a case, optimization won&#39;t happen and method dispatches aren&#39;t resolved statically, so we will just report it (as <code>OptimizationFailureReport</code>). In order to detect the case 2., we will inspect the optimized IR and look for <code>:call</code> expressions. <code>:call</code> expressions are such calls that were not resolved statically and will be dispatched at runtime (as opposed to <a href="https://docs.julialang.org/en/v1/devdocs/ast/#Expr-types"><code>:invoke</code></a> expressions, that represent staticall resolved generic function calls).</p><p>We will define <code>DispatchAnalyzer &lt;: AbstractAnalyzer</code>, and overload some of <code>Core.Compiler</code> methods with it:</p><ul><li><code>Core.Compiler.finish(frame::CC.InferenceState, analyzer::DispatchAnalyzer)</code> to check if optimization will happen or not (the case 1.)</li><li><code>Core.Compiler.finish!(analyzer::DispatchAnalyzer, caller::CC.InferenceResult)</code> to inspect an optimized IR (the case 2.)</li></ul><pre><code class="language-julia">using JET.JETInterfaces
const CC = Core.Compiler
import JET:
    JET,
    @invoke,
    @isexpr,
    gen_call_with_extracted_types_and_kwargs

struct DispatchAnalyzer{T} &lt;: AbstractAnalyzer
    state::AnalyzerState
    opts::BitVector
    target_filter::T
end
function DispatchAnalyzer(;
    # a predicate, which takes `CC.InfernceState` and returns whether we want to analyze the call or not
    target_filter = x-&gt;true,
    jetconfigs...)
    return DispatchAnalyzer(AnalyzerState(; jetconfigs...), BitVector(), target_filter)
end

# maybe filtering by module would be most useful
function module_filter(m)
    return function (frame::CC.InferenceState)
        frame.mod === m
    end
end

# AbstractAnalyzer API requirements
JETInterfaces.AnalyzerState(analyzer::DispatchAnalyzer)                          = analyzer.state
JETInterfaces.AbstractAnalyzer(analyzer::DispatchAnalyzer, state::AnalyzerState) = DispatchAnalyzer(state, analyzer.target_filter)
JETInterfaces.ReportPass(analyzer::DispatchAnalyzer)                             = DispatchAnalysisPass()

# we want to run different analysis with a different filter, so include its hash into the cache key
function JET.get_cache_key(analyzer::DispatchAnalyzer)
    h = @invoke JET.get_cache_key(analyzer::AbstractAnalyzer)
    h = hash(analyzer.target_filter, h)
    return h
end

struct DispatchAnalysisPass &lt;: ReportPass end

# ignore all reports defined by JET, since we&#39;ll just define our own reports
(::DispatchAnalysisPass)(T::Type{&lt;:InferenceErrorReport}, @nospecialize(_...)) = return

function CC._typeinf(analyzer::DispatchAnalyzer, frame::CC.InferenceState)
    @assert isempty(analyzer.opts)
    ret = @invoke CC._typeinf(analyzer::AbstractAnalyzer, frame::CC.InferenceState)
    @assert isempty(analyzer.opts)
    return ret
end

function CC.finish(frame::CC.InferenceState, analyzer::DispatchAnalyzer)
    ret = @invoke CC.finish(frame::CC.InferenceState, analyzer::AbstractAnalyzer)

    if !analyzer.target_filter(frame)
        push!(analyzer.opts, false)
    else
        if isa(frame.result.src, CC.OptimizationState)
            push!(analyzer.opts, true)
        else # means, compiler decides not to do optimization
            report_pass!(OptimizationFailureReport, analyzer, frame)
            push!(analyzer.opts, false)
        end
    end

    return ret
end

@reportdef struct OptimizationFailureReport &lt;: InferenceErrorReport end
JETInterfaces.get_msg(::Type{OptimizationFailureReport}, args...) =
    return &quot;failed to optimize&quot; #: signature of this MethodInstance

function (::DispatchAnalysisPass)(::Type{OptimizationFailureReport}, analyzer::DispatchAnalyzer, frame::CC.InferenceState)
    report!(OptimizationFailureReport, analyzer, frame.linfo)
end

function CC.finish!(analyzer::DispatchAnalyzer, caller::CC.InferenceResult)
    opt = caller.src

    ret = @invoke CC.finish!(analyzer::CC.AbstractInterpreter, caller::CC.InferenceResult)

    if popfirst!(analyzer.opts) # optimization happened
        if isa(ret, Core.Const) # the optimization was very successful, nothing to report
        elseif isa(ret, CC.OptimizationState) # compiler cached the optimized IR, just analyze it
            report_pass!(RuntimeDispatchReport, analyzer, ret)
        elseif isa(ret, Core.CodeInfo) # compiler didn&#39;t cache the optimized IR, but `finish!(::AbstractInterpreter, ::InferenceResult)` transformed it to `opt.src`, so we can analyze it
            @assert opt.src === ret &amp;&amp; isa(opt, CC.OptimizationState)
            report_pass!(RuntimeDispatchReport, analyzer, opt)
        else
            throw(&quot;got $ret, unexpected state happened&quot;) # this pass should never happen
        end
    end

    return ret
end

@reportdef struct RuntimeDispatchReport &lt;: InferenceErrorReport end
JETInterfaces.get_msg(::Type{RuntimeDispatchReport}, analyzer, s) =
    return &quot;runtime dispatch detected&quot; #: call signature

function (::DispatchAnalysisPass)(::Type{RuntimeDispatchReport}, analyzer::DispatchAnalyzer, opt::CC.OptimizationState)
    (; sptypes, slottypes) = opt
    for (pc, x) in enumerate(opt.src.code)
        if @isexpr(x, :call)
            ft = CC.widenconst(CC.argextype(first(x.args), opt.src, sptypes, slottypes))
            ft &lt;: Core.Builtin &amp;&amp; continue # ignore `:call`s of language intrinsics
            report!(RuntimeDispatchReport, analyzer, (opt, pc))
        end
    end
end</code></pre><h2 id="Usages"><a class="docs-heading-anchor" href="#Usages">Usages</a><a id="Usages-1"></a><a class="docs-heading-anchor-permalink" href="#Usages" title="Permalink"></a></h2><p>So we defined our analyzer. Let&#39;s setup utility analysis entries first:</p><pre><code class="language-julia">using JET # to use analysis entry points

function report_dispatch(@nospecialize(f), @nospecialize(types = Tuple{});
                         analyzer = DispatchAnalyzer,
                         jetconfigs...)
    @assert analyzer === DispatchAnalyzer &quot;analyzer is fixed to $DispatchAnalyzer&quot;
    report_call(f, types; analyzer, jetconfigs...)
end
macro report_dispatch(ex0...)
    return gen_call_with_extracted_types_and_kwargs(__module__, :report_dispatch, ex0)
end</code></pre><pre class="documenter-example-output">@report_dispatch (macro with 1 method)</pre><p>Now we can just call <code>@report_dispatch f(args...)</code> and check if there are any problematic part within the entire call tree of <code>f(args...)</code>.</p><h3 id="Simple-cases"><a class="docs-heading-anchor" href="#Simple-cases">Simple cases</a><a id="Simple-cases-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-cases" title="Permalink"></a></h3><p>First, let&#39;s play with simple and factitious examples and check if <code>DispatchAnalyzer</code> works as expected.</p><pre><code class="language-julia">f(a) = a
f(a::Number) = a</code></pre><pre class="documenter-example-output">f (generic function with 2 methods)</pre><p><code>f(::Int)</code> a concrete call and just type stable and anthing shouldn&#39;t be reported:</p><pre><code class="language-julia">@report_dispatch f(10); # should be ok</code></pre><pre class="documenter-example-output">No errors !</pre><p>But if the argument type isn&#39;t well typed, compiler can&#39;t determine which method to call, and it will lead to runtime dispatch:</p><pre><code class="language-julia">report_dispatch((Any,)) do a
    f(a) # runtime dispatch !
end;</code></pre><pre class="documenter-example-output">═════ 1 possible error found ═════
┌ @ none:2 Main.ex-dispatch_analysis.f(a)
│ runtime dispatch detected: Main.ex-dispatch_analysis.f(a::Any)
└──────────</pre><p>Even if a call is not &quot;well-typed&quot;, i.e. it&#39;s not a concrete call, runtime dispatch won&#39;t happen as far as a single method can be resovled statically:</p><pre><code class="language-julia">report_dispatch((Integer,)) do a
    f(a) # this isn&#39;t so good, but ok
end;</code></pre><pre class="documenter-example-output">No errors !</pre><p>Ok, working nicely so far. Let&#39;s move on to a bit more complicated example. If we annotate <code>@noinline</code> to a function, then its call won&#39;t be inlined and will be dispatched runtime. We will confirm this:</p><pre><code class="language-julia">@inline   g1(a) = return a # WARNING use `@inline` just for demonstrative purpose, usually we really don&#39;t need to use it for a very trivial function like this
@noinline g2(a) = return a
report_dispatch((Any,)) do a
    g1(a) # this call should be statically resolved and inlined
    g2(a) # this call should be statically resolved but not inlined, and will be dispatched
end;</code></pre><pre class="documenter-example-output">═════ 1 possible error found ═════
┌ @ none:3 Main.ex-dispatch_analysis.g2(a)
│ runtime dispatch detected: Main.ex-dispatch_analysis.g2(a::Any)
└──────────</pre><p>We can assert this report by looking at the output of <code>code_typed</code>, where <code>g1(a)</code> has been just disappeared by inlining and optimizations, but <code>g2(a)</code> still remains as a <code>:call</code> expression:</p><pre><code class="language-julia">code_typed((Any,)) do a
    g1(a) # this call should be statically resolved and inlined
    g2(a) # this call should be statically resolved but not inlined, and will be dispatched
end |&gt; first</code></pre><pre class="documenter-example-output">CodeInfo(
1 ─ %1 = Main.ex-dispatch_analysis.g2(a)::Any
└──      return %1
) =&gt; Any</pre><h3 id="Real-world-targets"><a class="docs-heading-anchor" href="#Real-world-targets">Real-world targets</a><a id="Real-world-targets-1"></a><a class="docs-heading-anchor-permalink" href="#Real-world-targets" title="Permalink"></a></h3><p>Let&#39;s run <code>DispatchAnalyzer</code> on real-world code and check how it works. Here we will test with Julia&#39;s <code>Base</code> module.</p><p>Numerical computations are usually written to be very type-stable, and so we expects e.g. <code>sin(10)</code> to be dispatch-free and run fast. Let&#39;s check it.</p><pre><code class="language-julia">@report_dispatch sin(10);</code></pre><pre class="documenter-example-output">═════ 1 possible error found ═════
┌ @ math.jl:1221 Base.Math.sin(xf)
│┌ @ special/trig.jl:39 Base.Math.sin_domain_error(x)
││┌ @ special/trig.jl:28 Base.Math.DomainError(x, &quot;sin(x) is only defined for finite x.&quot;)
│││ runtime dispatch detected: Base.Math.DomainError(x::Float64, &quot;sin(x) is only defined for finite x.&quot;)
││└──────────────────────</pre><p>Oh no, so runtime dispatch happens there even in <code>Base</code>. Well, actually, this specific dispatch is expected. Especially, <a href="https://github.com/JuliaLang/julia/pull/35982">https://github.com/JuliaLang/julia/pull/35982</a> implements an heuristic to intentionally disable inference (and so succeeding optimizations too) in order to ease <a href="https://julialang.org/blog/2020/08/invalidations/">the latency problem, a.k.a. &quot;first-time-to-plot&quot;</a>. The report trace certainly suggests a dispatch was detected where <code>DomainError</code> can be thrown. We can turn off the heuristic by turning off <a href="generated-plugin-examples/@ref JETAnalysisParams">the <code>unoptimize_throw_blocks::Bool</code> configuration</a>, and this time any runtime dispatch won&#39;t be reported:</p><pre><code class="language-julia">@report_dispatch unoptimize_throw_blocks=false sin(10);</code></pre><pre class="documenter-example-output">No errors !</pre><p>We can also confirm that the same thing would happen for <code>rand(1:1000)</code>:</p><pre><code class="language-julia">@report_dispatch rand(1:1000); # an runtiem dispatch will be detected within a `throw` block</code></pre><pre class="documenter-example-output">═════ 1 possible error found ═════
┌ @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.7/Random/src/Random.jl:258 Random.rand(Random.default_rng(), X)
│┌ @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.7/Random/src/Random.jl:253 Random.Sampler(rng, X, Random.Val(1))
││┌ @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.7/Random/src/generation.jl:189 Random.SamplerRangeNDL(r)
│││┌ @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.7/Random/src/generation.jl:321 Random.ArgumentError(&quot;range must be non-empty&quot;)
││││ runtime dispatch detected: Random.ArgumentError(&quot;range must be non-empty&quot;)
│││└──────────────────────────────────────────────────────────────────────────────────────────────────────</pre><pre><code class="language-julia">@report_dispatch unoptimize_throw_blocks=false rand(1:1000); # nothing should be reported</code></pre><pre class="documenter-example-output">No errors !</pre><p>Finally, let&#39;s see an example of very &quot;type-instable&quot; code maintained within <code>Base</code>. Typically, anything involved with I/O is written in a very dynamic way for good reasons, and certainly, e.g. <code>println(QuoteNode(nothing))</code> will yield bunch of runtime dispatches:</p><pre><code class="language-julia">@report_dispatch println(QuoteNode(nothing))
═════ 585 possible errors found ═════
┌ @ coreio.jl:4 Base.println(Core.tuple(Core.typeassert(Base.stdout, Base.IO)), xs...)
│┌ @ strings/io.jl:73 Base.print(Core.tuple(io), xs, Core.tuple(&quot;\n&quot;)...)
││┌ @ strings/io.jl:43 Base.lock(io)
│││┌ @ show.jl:334 Base.lock(Base.getproperty(io, :io))
# so many reports follow ...</code></pre><p>But what if your code contains a single <code>println</code> call, which you&#39;re absolutely okay with the type instabilities involved with it (e.g. it&#39;s only called once or only in debug mode, or such), but still you want to assert that any other part of code is type-stable and dispatch-free ? <code>DispatchAnalyzer</code>&#39;s <code>target_filter</code> option can be useful for this, by allowing us to specificy where it should and shouldn&#39;t run analysis. For example, we can check type-stabilities of anything in the current module like this:</p><pre><code class="language-julia"># problem: when ∑1/n exceeds 30 ?
function compute(x)
    r = 1
    s = 0.0
    n = 1
    @time while r &lt; x
        s += 1/n
        if s ≥ r
            println(&quot;round $r/$x has been finished&quot;) # we&#39;re not interested type-instabilities within this call
            r += 1
        end
        n += 1
    end
    return n, s
end

# NOTE:
# `compute(30)` will take more than hours in actual execution, according to https://twitter.com/genkuroki/status/1401332946707963909,
# but `@report_dispatch` will just do abstract interpretation of the call, so will finish instantly
@report_dispatch target_filter=module_filter(@__MODULE__) compute(30);</code></pre><pre class="documenter-example-output">No errors !</pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../generated-plugin-api/">« API</a><a class="docs-footer-nextpage" href="../find_unstable_api/">&quot;Unstable API&quot; Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 6 June 2021 06:50">Sunday 6 June 2021</span>. Using Julia version 1.7.0-DEV.1234.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
