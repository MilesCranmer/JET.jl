<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Error Analysis · JET.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">JET.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">README</a></li><li><span class="tocitem">Analyses</span><ul><li class="is-active"><a class="tocitem" href>Error Analysis</a><ul class="internal"><li><a class="tocitem" href="#jetanalysis-quick-start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#jetanalysis-entry"><span>Entry Points</span></a></li><li><a class="tocitem" href="#jetanalysis-config"><span>Configurations</span></a></li></ul></li><li><a class="tocitem" href="../optanalysis/">Optimization Analysis</a></li></ul></li><li><a class="tocitem" href="../config/">Configurations</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><span class="tocitem"><code>AbstractAnalyzer</code> Framework</span><ul><li><a class="tocitem" href="../generated-plugin-api/">API</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../generated-plugin-examples/dispatch_analysis/">Dispatch Analysis</a></li><li><a class="tocitem" href="../generated-plugin-examples/find_unstable_api/">&quot;Unstable API&quot; Analysis</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Analyses</a></li><li class="is-active"><a href>Error Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Error Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aviatesk/JET.jl/blob/master/docs/src/jetanalysis.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="jetanalysis"><a class="docs-heading-anchor" href="#jetanalysis">Error Analysis</a><a id="jetanalysis-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis" title="Permalink"></a></h1><p>Julia&#39;s type system is quite expressive and its type inference is strong enough to generate highly optimized code from its very concise and generic program. But as opposed to other statically-compiled languages, Julia by design does NOT error nor warn anything even if it detects possible errors during its compilation process no matter how serious they are. Julia delays all the errors and warnings to the runtime.</p><p>This is actually a core design choice of the language – on the one hand, Julia&#39;s dynamism allow it to work in places where data types are not fully decided ahead of runtime just because Julia doesn&#39;t require it – on the other hand, with Julia, it&#39;s not straightforward to have such modern development experiences that a typical static language can offer, including static type checking and very rich IDE features.</p><p>JET is a trial to get the best of both worlds: can we have a sufficiently useful static analysis without losing all the beauty of Julia&#39;s dynamism ? JET directly employs Julia&#39;s builtin type inference system to enable a static analysis, so in that sense its approach is very different from <a href="https://en.wikipedia.org/wiki/Gradual_typing">&quot;gradual typing&quot;</a>, which is a common technique to bring static analysis into a dynamic language, as used for <a href="https://github.com/python/mypy">mypy</a> for Python and <a href="https://www.typescriptlang.org/">TypeScript</a> for JavaScript. Rather, Julia&#39;s type inference system and JET are powered by the technique called <a href="https://en.wikipedia.org/wiki/Abstract_interpretation">&quot;abstract interpretation&quot;</a>. As like Julia can effectively optimize your simple and generic program, JET can also analyze <em>just a normal</em> Julia program and smartly detect possible errors, but statically. So in other word, JET doesn&#39;t require any additional setups like scattering type annotations just for the sake of analysis.</p><h2 id="jetanalysis-quick-start"><a class="docs-heading-anchor" href="#jetanalysis-quick-start">Quick Start</a><a id="jetanalysis-quick-start-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis-quick-start" title="Permalink"></a></h2><p>First you need to install and load JET. JET is an ordinary Julia package, so you can install it via Julia&#39;s built-in package manager and use it as like other packages.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ; # ] add JET # install JET via the built-in package manager</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JET</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Let&#39;s start with a simplest example: how JET can find anything wrong with <code>sum(&quot;julia&quot;)</code> ? <a href="#JET.@report_call"><code>@report_call</code></a> and <a href="#JET.report_call"><code>report_call</code></a> analyzes a given function call and get back the detected problems. They can be used in a similar way as <a href="https://docs.julialang.org/en/v1/stdlib/InteractiveUtils/#InteractiveUtils.@code_typed"><code>@code_typed</code></a> and <a href="https://docs.julialang.org/en/v1/base/base/#Base.code_typed"><code>code_typed</code></a>, and those <a href="#jetanalysis-interactive-entry">interactive entry points</a> are the most easiest way to use JET:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call sum(&quot;julia&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 2 possible errors found ═════</span>
<span class="sgr35">┌ @ reduce.jl:549 </span>Base.#sum#266(Base.pairs(Core.NamedTuple()), #self#, a)
<span class="sgr35">│</span><span class="sgr34">┌ @ reduce.jl:549 </span>Base.sum(Base.identity, a)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reduce.jl:520 </span>Base.#sum#265(Base.pairs(Core.NamedTuple()), #self#, f, a)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reduce.jl:520 </span>Base.mapreduce(f, Base.add_sum, a)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reduce.jl:294 </span>Base.#mapreduce#262(Base.pairs(Core.NamedTuple()), #self#, f, op, itr)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reduce.jl:294 </span>Base.mapfoldl(f, op, itr)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reduce.jl:162 </span>Base.#mapfoldl#258(Base._InitialValue(), #self#, f, op, itr)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reduce.jl:162 </span>Base.mapfoldl_impl(f, op, init, itr)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reduce.jl:44 </span>Base.foldl_impl(op′, nt, itr′)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reduce.jl:48 </span>v = Base._foldl_impl(op, nt, itr)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reduce.jl:62 </span>v = op(v, Base.getindex(y, 1))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reduce.jl:81 </span>Base.getproperty(op, :rf)(acc, x)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr91">┌ @ reduce.jl:24 </span>Base.+(x, y)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr91">│ no matching method found for call signature (Tuple{typeof(+), Char, Char}): </span><span class="sgr1">Base.+(x<span class="sgr96">::Char</span>, y<span class="sgr96">::Char</span>)</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr91">└────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reduce.jl:49 </span>Base.reduce_empty_iter(op, itr)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reduce.jl:370 </span>Base.reduce_empty_iter(op, itr, Base.IteratorEltype(itr))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reduce.jl:371 </span>Base.reduce_empty(op, Base.eltype(itr))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reduce.jl:347 </span>Base.reduce_empty(Base.getproperty(op, :rf), _)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reduce.jl:339 </span>Base.reduce_empty(Base.+, _)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">┌ @ reduce.jl:330 </span>Base.zero(_)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">│ no matching method found for call signature (Tuple{typeof(zero), Type{Char}}): </span><span class="sgr1">Base.zero(_<span class="sgr96">::Type{Char}</span>)</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">└─────────────────</span></code></pre><p>So JET found two possible problems. Now let&#39;s see how they can occur in <em>actual execution</em>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum(&quot;julia&quot;) # will lead to `MethodError: +(::Char, ::Char)`</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching +(::Char, ::Char)
Closest candidates are:
  +(::Any, ::Any, <span class="sgr91">::Any</span>, <span class="sgr91">::Any...</span>) at operators.jl:591
  +(::T, <span class="sgr91">::Integer</span>) where T&lt;:AbstractChar at char.jl:237
  +(<span class="sgr91">::Integer</span>, ::AbstractChar) at char.jl:247</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum(&quot;&quot;) # will lead to `MethodError: zero(Type{Char})`</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching zero(::Type{Char})
Closest candidates are:
  zero(<span class="sgr91">::Union{Type{P}, P}</span>) where P&lt;:Dates.Period at /opt/hostedtoolcache/julia/nightly/x64/share/julia/stdlib/v1.9/Dates/src/periods.jl:53
  zero(<span class="sgr91">::T</span>) where T&lt;:Dates.TimeType at /opt/hostedtoolcache/julia/nightly/x64/share/julia/stdlib/v1.9/Dates/src/types.jl:450
  zero(<span class="sgr91">::LinearAlgebra.Diagonal</span>) at /opt/hostedtoolcache/julia/nightly/x64/share/julia/stdlib/v1.9/LinearAlgebra/src/special.jl:332
  ...</code></pre><p>We should note that <code>@report_call sum(&quot;julia&quot;)</code> could detect both of those two different errors that can happen at runtime. This is because <code>@report_call</code> does a static analysis – it analyzes the function call in a way that does NOT rely on runtime, and so it can reason about all the possible executions ! This is one of the biggest advantages of static analysis, because other alternatives to check software qualities like &quot;testing&quot; usually rely on runtime and they can only represent a subset of all the possible executions.</p><p>As mentioned above, JET is designed to work with <em>just a normal</em> Julia program. Let&#39;s define new arbitrary functions and run JET on it:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function foo(s0)
           a = []
           for s in split(s0)
               push!(a, bar(s))
           end
           return sum(a)
       end</code><code class="nohighlight hljs ansi" style="display:block;">foo (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bar(s::String) = parse(Int, s)</code><code class="nohighlight hljs ansi" style="display:block;">bar (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call foo(&quot;1 2 3&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 2 possible errors found ═════</span>
<span class="sgr91">┌ @ REPL[1]:4 </span>Main.bar(s)
<span class="sgr91">│ no matching method found for call signature (Tuple{typeof(Main.bar), SubString{String}}): </span><span class="sgr1">Main.bar(s<span class="sgr96">::SubString{String}</span>)</span>
<span class="sgr91">└─────────────</span>
<span class="sgr35">┌ @ REPL[1]:6 </span>Main.sum(a)
<span class="sgr35">│</span><span class="sgr34">┌ @ reducedim.jl:994 </span>Base.#sum#768(Base.:, Base.pairs(Core.NamedTuple()), #self#, a)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reducedim.jl:994 </span>Base._sum(a, dims)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reducedim.jl:998 </span>Base.#_sum#770(Base.pairs(Core.NamedTuple()), #self#, a, _3)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reducedim.jl:998 </span>Base._sum(Base.identity, a, Base.:)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reducedim.jl:999 </span>Base.#_sum#771(Base.pairs(Core.NamedTuple()), #self#, f, a, _4)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reducedim.jl:999 </span>Base.mapreduce(f, Base.add_sum, a)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reducedim.jl:357 </span>Base.#mapreduce#761(Base.:, Base._InitialValue(), #self#, f, op, A)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reducedim.jl:357 </span>Base._mapreduce_dim(f, op, init, A, dims)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reducedim.jl:365 </span>Base._mapreduce(f, op, Base.IndexStyle(A), A)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reduce.jl:419 </span>Base.mapreduce_empty_iter(f, op, A, Base.IteratorEltype(A))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reduce.jl:367 </span>Base.reduce_empty_iter(Base.MappingRF(f, op), itr, ItrEltype)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reduce.jl:371 </span>Base.reduce_empty(op, Base.eltype(itr))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reduce.jl:348 </span>Base.mapreduce_empty(Base.getproperty(op, :f), Base.getproperty(op, :rf), _)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reduce.jl:359 </span>Base.reduce_empty(op, T)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reduce.jl:339 </span>Base.reduce_empty(Base.+, _)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reduce.jl:330 </span>Base.zero(_)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ @ missing.jl:106 </span>Base.throw(Base.MethodError(Base.zero, Core.tuple(Base.Any)))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ MethodError: no method matching zero(::Type{Any})</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└──────────────────</span></code></pre><p>Now let&#39;s fix this problematic code. Say, for some reason, we&#39;re not interested in errors that may happen in the context of <code>Base</code> – we want to focus on fixing the error that happens from the definition of <code>bar</code>. First, we can fix the definition of <code>bar</code> so that it can accept generic <code>AbstractString</code> input. JET&#39;s analysis result can be dynamically updated when we refine a function definition, and so we just need to add a new <code>bar(::AbstractString)</code> definition. As for the second error, we can use the <a href="../config/#result-config"><code>target_modules</code></a> configuration to limit the analysis scope to the current module context to ignore the possible error that may happen within <code>sum(a)</code><sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # hot fix the definition of `bar`
       bar(s::AbstractString) = parse(Int, s)</code><code class="nohighlight hljs ansi" style="display:block;">bar (generic function with 2 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # now no errors should be reported !
       @report_call target_modules=(@__MODULE__,) foo(&quot;1 2 3&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code></pre><p>So far, we have used the default error analysis pass, which collects problems according to one specific definition of &quot;errors&quot; (see the <a href="#JET.BasicPass"><code>JET.BasicPass</code></a> for more details). JET offers other error reporting passes, including the &quot;sound&quot; error detection (<a href="#JET.SoundPass"><code>JET.SoundPass</code></a>) as well as the &quot;typo&quot; detection pass (<a href="#JET.TypoPass"><code>JET.TypoPass</code></a>)<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>. They can be switched using the <code>mode</code> configuration:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function myifelse(cond, a, b)
           if cond
               return a
           else
               return b
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">myifelse (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # the default analysis pass doesn&#39;t report &quot;non-boolean (T) used in boolean context&quot; error
       # as far as there is possibility when the condition &quot;can&quot; be bool (NOTE: Bool &lt;: Integer)
       report_call(myifelse, (Integer, Int, Int))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # the sound analyzer doens&#39;t permit such a case: it requires the type of a conditional value to be `Bool` strictly
       report_call(myifelse, (Integer, Int, Int); mode=:sound)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ @ REPL[1]:2 </span>goto %3 if not cond
<span class="sgr91">│ non-boolean (Integer) used in boolean context: </span><span class="sgr1">goto %3 if not cond<span class="sgr96">::Integer</span></span>
<span class="sgr91">└─────────────</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function strange_sum(a)
           if rand(Bool)
               undefsum(a)
           else
               sum(a)
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">strange_sum (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # the default analysis pass will report both problems:
       # - `undefsum` is not defined
       # - `sum(a::Vector{Any})` can throw when `a` is empty
       @report_call strange_sum([])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 2 possible errors found ═════</span>
<span class="sgr91">┌ @ REPL[4]:3 </span>Main.undefsum(a)
<span class="sgr91">│ variable Main.undefsum is not defined: </span><span class="sgr1">Main.undefsum(a<span class="sgr96">::Vector{Any}</span>)</span>
<span class="sgr91">└─────────────</span>
<span class="sgr35">┌ @ REPL[4]:5 </span>Main.sum(a)
<span class="sgr35">│</span><span class="sgr34">┌ @ reducedim.jl:994 </span>Base.#sum#768(Base.:, Base.pairs(Core.NamedTuple()), #self#, a)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reducedim.jl:994 </span>Base._sum(a, dims)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reducedim.jl:998 </span>Base.#_sum#770(Base.pairs(Core.NamedTuple()), #self#, a, _3)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reducedim.jl:998 </span>Base._sum(Base.identity, a, Base.:)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reducedim.jl:999 </span>Base.#_sum#771(Base.pairs(Core.NamedTuple()), #self#, f, a, _4)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reducedim.jl:999 </span>Base.mapreduce(f, Base.add_sum, a)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reducedim.jl:357 </span>Base.#mapreduce#761(Base.:, Base._InitialValue(), #self#, f, op, A)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reducedim.jl:357 </span>Base._mapreduce_dim(f, op, init, A, dims)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reducedim.jl:365 </span>Base._mapreduce(f, op, Base.IndexStyle(A), A)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reduce.jl:419 </span>Base.mapreduce_empty_iter(f, op, A, Base.IteratorEltype(A))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reduce.jl:367 </span>Base.reduce_empty_iter(Base.MappingRF(f, op), itr, ItrEltype)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reduce.jl:371 </span>Base.reduce_empty(op, Base.eltype(itr))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reduce.jl:348 </span>Base.mapreduce_empty(Base.getproperty(op, :f), Base.getproperty(op, :rf), _)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reduce.jl:359 </span>Base.reduce_empty(op, T)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reduce.jl:339 </span>Base.reduce_empty(Base.+, _)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reduce.jl:330 </span>Base.zero(_)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ @ missing.jl:106 </span>Base.throw(Base.MethodError(Base.zero, Core.tuple(Base.Any)))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ MethodError: no method matching zero(::Type{Any})</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└──────────────────</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # the typo dection pass will only report the &quot;typo&quot;
       @report_call mode=:typo strange_sum([])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ @ REPL[4]:3 </span>Main.undefsum(a)
<span class="sgr91">│ variable Main.undefsum is not defined: </span><span class="sgr1">Main.undefsum(a<span class="sgr96">::Vector{Any}</span>)</span>
<span class="sgr91">└─────────────</span></code></pre><p>We can use <a href="#JET.@test_call"><code>@test_call</code></a> and <a href="#JET.test_call"><code>test_call</code></a> to assert that your program is free from problems that <code>@report_call</code> can detect. They work nicely with <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code> standard library</a>&#39;s unit-testing infrastructure:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_call target_modules=(@__MODULE__,) foo(&quot;1 2 3&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Test</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # we can get the nice summery using `@testset` !
       @testset &quot;JET testset&quot; begin
           @test_call target_modules=(@__MODULE__,) foo(&quot;1 2 3&quot;) # should pass
       
           test_call(myifelse, (Integer, Int, Int); mode=:sound)
       
           @test_call broken=true foo(&quot;1 2 3&quot;) # `broken` and `skip` options are supported
       
           @test foo(&quot;1 2 3&quot;) == 6 # of course other `Test` macros can be used in the same place
       end</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr37">JET testset: </span><span class="sgr91"><span class="sgr1">JET-test failed</span></span> at <span class="sgr1">/home/runner/work/JET.jl/JET.jl/src/JET.jl:1476</span>
  Expression: (JET.test_call)(Main.myifelse, (Integer, Int64, Int64); mode = sound)
  <span class="sgr7">═════ 1 possible error found ═════</span>
  <span class="sgr91">┌ @ REPL[1]:2 </span>goto %3 if not cond
  <span class="sgr91">│ non-boolean (Integer) used in boolean context: </span><span class="sgr1">goto %3 if not cond<span class="sgr96">::Integer</span></span>
  <span class="sgr91">└─────────────</span>
  
<span class="sgr1">Test Summary: | <span class="sgr32">Pass  </span><span class="sgr91">Fail  </span><span class="sgr33">Broken  </span><span class="sgr36">Total  </span>Time</span>
JET testset   | <span class="sgr32">   2  </span><span class="sgr91">   1  </span><span class="sgr33">     1  </span><span class="sgr36">    4  </span>2.8s
ERROR: <span class="sgr91">Some tests did not pass: 2 passed, 1 failed, 0 errored, 1 broken.</span></code></pre><p>JET actually uses JET itself in its test pipeline. JET&#39;s static analysis has been proven to be very useful and helped its development a lot. If interested, take a peek at <a href="https://github.com/aviatesk/JET.jl/blob/master/test/runtests.jl">JET&#39;s <code>&quot;self check !!!&quot;</code> testset</a>.</p><p>Lastly, let&#39;s see the example that demonstrates JET can analyze &quot;top-level&quot; program. The top-level analysis should be considered as a somewhat experimental feature, and at this moment you may need additional configurations to run it correctly. Please read the descriptions of <a href="#jetanalysis-toplevel-entry">top-level entry points</a> and choose an appropriate entry point for your use case. Here we run <a href="#JET.report_file"><code>report_file</code></a> on <a href="https://github.com/aviatesk/JET.jl/blob/master/demo.jl">demo.jl</a>. It automatically extracts and loads &quot;definitions&quot; of functions, structs and such, and then analyzes their &quot;usages&quot; statically:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; report_file(normpath(Base.pkgdir(JET), &quot;demo.jl&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">[toplevel-info] applied JET configurations in /home/runner/work/JET.jl/JET.jl/.JET.toml
[toplevel-info] virtualized the context of Main (took 0.006 sec)
[toplevel-info] entered into /home/runner/work/JET.jl/JET.jl/demo.jl
[toplevel-info]  exited from /home/runner/work/JET.jl/JET.jl/demo.jl (took 2.3 sec)
[toplevel-info] analyzing from top-level definitions ... 1/9[toplevel-info] analyzing from top-level definitions ... 2/9[toplevel-info] analyzing from top-level definitions ... 3/9[toplevel-info] analyzing from top-level definitions ... 4/9[toplevel-info] analyzing from top-level definitions ... 5/9[toplevel-info] analyzing from top-level definitions ... 6/9[toplevel-info] analyzing from top-level definitions ... 7/9[toplevel-info] analyzing from top-level definitions ... 8/9[toplevel-info] analyzing from top-level definitions ... 9/9
<span class="sgr7">═════ 8 possible errors found ═════</span>
<span class="sgr91">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:10 </span>fib(m)
<span class="sgr91">│ variable m is not defined: </span><span class="sgr1">fib(m)</span>
<span class="sgr91">└──────────────────────────────────────────────</span>
<span class="sgr35">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:11 </span>fib(&quot;1000&quot;)
<span class="sgr35">│</span><span class="sgr34">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:7 </span>≤(n, 2)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ operators.jl:405 </span>Base.&lt;(x, y)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">┌ @ operators.jl:356 </span>Base.isless(x, y)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">│ no matching method found for call signature (Tuple{typeof(isless), String, Int64}): </span><span class="sgr1">Base.isless(x<span class="sgr96">::String</span>, y<span class="sgr96">::Int64</span>)</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">└────────────────────</span>
<span class="sgr35">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:32 </span>foo(1.2)
<span class="sgr35">│</span><span class="sgr34">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:24 </span>bar(v)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:29 </span>Base.getproperty(v, :fdl)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">┌ @ Base.jl:37 </span>Base.getfield(x, f)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">│ type Ty{Float64} has no field fdl</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">└──────────────</span>
<span class="sgr35">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:33 </span>foo(&quot;1&quot;)
<span class="sgr35">│</span><span class="sgr34">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:24 </span>bar(v)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:30 </span>convert(Number, Base.getproperty(v, :fld))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">│ no matching method found for call signature (Tuple{typeof(convert), Type{Number}, String}): </span><span class="sgr1">convert(Number, Base.getproperty(v<span class="sgr96">::Ty{String}</span>, :fld<span class="sgr96">::Symbol</span>)<span class="sgr96">::String</span>)</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">└──────────────────────────────────────────────</span>
<span class="sgr35">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:44 </span>badmerge(Core.apply_type(Core.NamedTuple, (:x, :y))(Core.tuple(1, 2)), Core.apply_type(Core.NamedTuple, (:y, :z))(Core.tuple(3, 1)))
<span class="sgr35">│</span><span class="sgr91">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:37 </span>getfield(a, x)
<span class="sgr35">│</span><span class="sgr91">│ variable x is not defined: </span><span class="sgr1">getfield(a<span class="sgr96">::NamedTuple{(:x, :y), Tuple{Int64, Int64}}</span>, x)</span>
<span class="sgr35">│</span><span class="sgr91">└──────────────────────────────────────────────</span>
<span class="sgr35">│</span><span class="sgr91">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:37 </span>getfield(b, y)
<span class="sgr35">│</span><span class="sgr91">│ variable y is not defined: </span><span class="sgr1">getfield(b<span class="sgr96">::NamedTuple{(:y, :z), Tuple{Int64, Int64}}</span>, y)</span>
<span class="sgr35">│</span><span class="sgr91">└──────────────────────────────────────────────</span>
<span class="sgr35">│</span><span class="sgr91">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:37 </span>getfield(b, z)
<span class="sgr35">│</span><span class="sgr91">│ variable z is not defined: </span><span class="sgr1">getfield(b<span class="sgr96">::NamedTuple{(:y, :z), Tuple{Int64, Int64}}</span>, z)</span>
<span class="sgr35">│</span><span class="sgr91">└──────────────────────────────────────────────</span>
<span class="sgr35">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:24 </span>bar(v)
<span class="sgr35">│</span><span class="sgr34">┌ @ /home/runner/work/JET.jl/JET.jl/demo.jl:29 </span>Base.getproperty(v, :fdl)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">┌ @ Base.jl:37 </span>Base.getfield(x, f)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">│ type Ty{T} where T&lt;:Number has no field fdl</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">└──────────────</span></code></pre><h2 id="jetanalysis-entry"><a class="docs-heading-anchor" href="#jetanalysis-entry">Entry Points</a><a id="jetanalysis-entry-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis-entry" title="Permalink"></a></h2><h3 id="jetanalysis-interactive-entry"><a class="docs-heading-anchor" href="#jetanalysis-interactive-entry">Interactive Entry Points</a><a id="jetanalysis-interactive-entry-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis-interactive-entry" title="Permalink"></a></h3><p>JET offers interactive analysis entry points that can be used similarly to <a href="https://docs.julialang.org/en/v1/base/base/#Base.code_typed"><code>code_typed</code></a> and its family:</p><article class="docstring"><header><a class="docstring-binding" id="JET.@report_call" href="#JET.@report_call"><code>JET.@report_call</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@report_call [jetconfigs...] f(args...)</code></pre><p>Evaluates the arguments to the function call, determines its types, and then calls <a href="#JET.report_call"><code>report_call</code></a> on the resulting expression. As with <code>@code_typed</code> and its family, any of <a href="../config/#JET-configurations">JET configurations</a> can be given as the optional arguments like this:</p><pre><code class="language-julia-repl hljs"># reports `rand(::Type{Bool})` with `aggressive_constant_propagation` configuration turned off
julia&gt; @report_call aggressive_constant_propagation=false rand(Bool)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/f6e1d17c54caf78bc5729a8cc27a58d40a8d8542/src/JET.jl#L1254-L1265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.report_call" href="#JET.report_call"><code>JET.report_call</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">report_call(f, types = Tuple{};
            analyzer::Type{&lt;:AbstractAnalyzer} = JETAnalyzer,
            jetconfigs...) -&gt; JETCallResult
report_call(tt::Type{&lt;:Tuple};
            analyzer::Type{&lt;:AbstractAnalyzer} = JETAnalyzer,
            jetconfigs...) -&gt; JETCallResult</code></pre><p>Analyzes the generic function call with the given type signature with <code>analyzer</code>. And finally returns the analysis result as <a href="../internals/#JET.JETCallResult"><code>JETCallResult</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/f6e1d17c54caf78bc5729a8cc27a58d40a8d8542/src/JET.jl#L1270-L1280">source</a></section></article><h3 id="jetanalysis-test-integration"><a class="docs-heading-anchor" href="#jetanalysis-test-integration"><code>Test</code> Integration</a><a id="jetanalysis-test-integration-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis-test-integration" title="Permalink"></a></h3><p>JET also exports entries that are fully integrated with <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code> standard library</a>&#39;s unit-testing infrastructure. It can be used in your test suite to assert your program is free from errors that JET can detect:</p><article class="docstring"><header><a class="docstring-binding" id="JET.@test_call" href="#JET.@test_call"><code>JET.@test_call</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@test_call [jetconfigs...] [broken=false] [skip=false] f(args...)</code></pre><p>Runs <a href="#JET.@report_call"><code>@report_call jetconfigs... f(args...)</code></a> and tests that the generic function call <code>f(args...)</code> is free from problems that <code>@report_call</code> can detect. If executed inside <code>@testset</code>, returns a <code>Pass</code> result if it is, a <code>Fail</code> result if it contains any error points detected, or an <code>Error</code> result if this macro encounters an unexpected error. When the test <code>Fail</code>s, abstract call stack to each problem location will also be printed to <code>stdout</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; @test_call sincos(10)
Test Passed
  Expression: #= none:1 =# JET.@test_call sincos(10)</code></pre><p>As with <a href="#JET.@report_call"><code>@report_call</code></a>, any of <a href="https://aviatesk.github.io/JET.jl/dev/config/">JET configurations</a> or analyzer specific configurations can be given as the optional arguments <code>jetconfigs...</code> like this:</p><pre><code class="language-julia-repl hljs">julia&gt; cond = false

julia&gt; function f(n)
           # `cond` is untyped, and will be reported by the sound analysis pass,
           # while JET&#39;s default analysis pass will ignore it
           if cond
               return sin(n)
           else
               return cos(n)
           end
       end;

julia&gt; @test_call f(10)
Test Passed
  Expression: #= none:1 =# JET.@test_call f(10)

julia&gt; @test_call mode=:sound f(10)
JET-test failed at none:1
  Expression: #= none:1 =# JET.@test_call mode = :sound f(10)
  ═════ 1 possible error found ═════
  ┌ @ none:2 goto %4 if not Main.cond
  │ non-boolean (Any) used in boolean context: goto %4 if not Main.cond
  └──────────

ERROR: There was an error during testing</code></pre><p><code>@test_call</code> is fully integrated with <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code> standard library</a>&#39;s unit-testing infrastructure. It means, the result of <code>@test_call</code> will be included in the final <code>@testset</code> summary, it supports <code>skip</code> and <code>broken</code> annotations as like <code>@test</code> and its family:</p><pre><code class="language-julia-repl hljs">julia&gt; using JET, Test

# Julia can&#39;t propagate the type constraint `ref[]::Number` to `sin(ref[])`, JET will report `NoMethodError`
julia&gt; f(ref) = isa(ref[], Number) ? sin(ref[]) : nothing;

# we can make it type-stable if we extract `ref[]` into a local variable `x`
julia&gt; g(ref) = (x = ref[]; isa(x, Number) ? sin(x) : nothing);

julia&gt; @testset &quot;check errors&quot; begin
           ref = Ref{Union{Nothing,Int}}(0)
           @test_call f(ref)             # fail
           @test_call g(ref)             # fail
           @test_call broken=true f(ref) # annotated as broken, thus still &quot;pass&quot;
       end
check errors: JET-test failed at none:3
  Expression: #= none:3 =# JET.@test_call f(ref)
  ═════ 1 possible error found ═════
  ┌ @ none:1 Main.sin(Base.getindex(ref))
  │ for 1 of union split cases, no matching method found for call signatures (Tuple{typeof(sin), Nothing})): Main.sin(Base.getindex(ref::Base.RefValue{Union{Nothing, Int64}})::Union{Nothing, Int64})
  └──────────

Test Summary: | Pass  Fail  Broken  Total
check errors  |    1     1       1      3
ERROR: Some tests did not pass: 1 passed, 1 failed, 0 errored, 1 broken.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/f6e1d17c54caf78bc5729a8cc27a58d40a8d8542/src/JET.jl#L1310-L1385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.test_call" href="#JET.test_call"><code>JET.test_call</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">test_call(f, types = Tuple{}; broken::Bool = false, skip::Bool = false, jetconfigs...)
test_call(tt::Type{&lt;:Tuple}; broken::Bool = false, skip::Bool = false, jetconfigs...)</code></pre><p>Runs <a href="#JET.report_call"><code>report_call(f, types; jetconfigs...</code></a> and tests that the generic function call <code>f(args...)</code> is free from problems that <code>report_call</code> can detect. Except that it takes a type signature rather than a call expression, this function works in the same way as <a href="#JET.@test_call"><code>@test_call</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/f6e1d17c54caf78bc5729a8cc27a58d40a8d8542/src/JET.jl#L1464-L1472">source</a></section></article><h3 id="jetanalysis-toplevel-entry"><a class="docs-heading-anchor" href="#jetanalysis-toplevel-entry">Top-level Entry Points</a><a id="jetanalysis-toplevel-entry-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis-toplevel-entry" title="Permalink"></a></h3><p>JET can also analyze your &quot;top-level&quot; program: it can just take your Julia script or package and will report possible errors.</p><p>Note that JET will analyze your code &quot;half-statically&quot;: JET will selectively interpret &quot;definitions&quot; (like a function or struct definition) and try to simulate Julia&#39;s top-level code execution. While it tries to avoid executing any other parts of code like function calls, but analyzes them based on abstract interpretation instead (and this is a part where JET statically analyzes your code). If you&#39;re interested in how JET selects &quot;top-level definitions&quot;, please see <a href="../internals/#JET.virtual_process"><code>JET.virtual_process</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Because JET will actually interpret &quot;definitions&quot; in your code, that part of top-level analysis certainly <em>runs</em> your code. So we should note that JET can cause some side effects from your code; for example JET will try to expand all the macros used in your code, and so the side effects involved with macro expansions will also happen in JET&#39;s analysis process.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="JET.report_file" href="#JET.report_file"><code>JET.report_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">report_file(filename::AbstractString;
            jetconfigs...) -&gt; JETToplevelResult</code></pre><p>Analyzes <code>filename</code> and returns <a href="../internals/#JET.JETToplevelResult"><code>JETToplevelResult</code></a>.</p><p>This function will look for <code>.JET.toml</code> configuration file in the directory of <code>filename</code>, and search <em>up</em> the file tree until any <code>.JET.toml</code> is (or isn&#39;t) found. When found, the configurations specified in the file will be applied. See <a href="../config/#config-file">JET&#39;s configuration file</a> for more details.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>When you want to analyze your package, but any file actually using it isn&#39;t available, the <code>analyze_from_definitions</code> option can be useful (see <a href="../config/#JET.ToplevelConfig"><code>ToplevelConfig</code></a>&#39;s <code>analyze_from_definitions</code> option). <br/>For example, JET can analyze JET itself like below:</p><pre><code class="language-julia-repl hljs"># from the root directory of JET.jl
julia&gt; report_file(&quot;src/JET.jl&quot;;
                   analyze_from_definitions = true)</code></pre><p>See also: <a href="#JET.report_package"><code>report_package</code></a></p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function will enable the <code>toplevel_logger</code> configuration by default with the default logging level. You can still explicitly specify and configure it:</p><pre><code class="language-julia hljs">report_file(args...;
            toplevel_logger = nothing, # suppress toplevel logger
            jetconfigs...) # other configurations</code></pre><p>See <a href="../config/#logging-config">JET&#39;s logging configurations</a> for more details.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/f6e1d17c54caf78bc5729a8cc27a58d40a8d8542/src/JET.jl#L761-L793">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.report_and_watch_file" href="#JET.report_and_watch_file"><code>JET.report_and_watch_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">report_and_watch_file(filename::AbstractString;
                      jetconfigs...)</code></pre><p>Watches <code>filename</code> and keeps re-triggering analysis with <a href="#JET.report_file"><code>report_file</code></a> on code update. JET will try to analyze all the <code>include</code>d files reachable from <code>filename</code>, and it will re-trigger analysis if there is code update detected in any of the <code>include</code>d files.</p><p>This function internally uses <a href="https://timholy.github.io/Revise.jl/stable/">Revise.jl</a> to track code updates. Revise also offers possibilities to track changes in files that are not directly analyzed by JET, or even changes in <code>Base</code> files. See <a href="../config/#watch-config">watch configurations</a> for more details.</p><p>See also: <a href="#JET.report_file"><code>report_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/f6e1d17c54caf78bc5729a8cc27a58d40a8d8542/src/JET.jl#L1051-L1065">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.report_package" href="#JET.report_package"><code>JET.report_package</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">report_package(package::Union{AbstractString,Module};
               jetconfigs...) -&gt; JETToplevelResult</code></pre><p>Analyzes <code>package</code> in the same way as <a href="#JET.report_file"><code>report_file</code></a> with the special default configurations, which are especially tuned for package analysis (see below for details). <code>package</code> can be either a <code>Module</code> or a <code>String</code>. In the latter case it must be the name of a package in your current environment.</p><p>This function configures analysis with the following configurations:</p><ul><li><code>analyze_from_definitions = true</code>: allows JET to enter analysis without top-level call sites; this is useful for package analysis since a package itself usually has only definitions but not usages (i.e. call sites)</li><li><code>concretization_patterns = [:(x_)]</code>: concretizes every top-level code in a given <code>package</code>; concretizations are generally preferred for successful analysis as far as they&#39;re cheap, and a package definition doesn&#39;t contain heavy computations in general cases</li></ul><p>See <a href="../config/#JET.ToplevelConfig"><code>ToplevelConfig</code></a> for more details.</p><hr/><pre><code class="nohighlight hljs">report_package([io::IO = stdout];
               jetconfigs...) -&gt; res::ReportResult</code></pre><p>Like above but analyzes the package of the current project.</p><p>See also: <a href="#JET.report_file"><code>report_file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/f6e1d17c54caf78bc5729a8cc27a58d40a8d8542/src/JET.jl#L928-L954">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.report_text" href="#JET.report_text"><code>JET.report_text</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">report_text(text::AbstractString,
            filename::AbstractString = &quot;top-level&quot;;
            jetconfigs...) -&gt; JETToplevelResult</code></pre><p>Analyzes <code>text</code> and returns <a href="../internals/#JET.JETToplevelResult"><code>JETToplevelResult</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/f6e1d17c54caf78bc5729a8cc27a58d40a8d8542/src/JET.jl#L985-L991">source</a></section></article><h2 id="jetanalysis-config"><a class="docs-heading-anchor" href="#jetanalysis-config">Configurations</a><a id="jetanalysis-config-1"></a><a class="docs-heading-anchor-permalink" href="#jetanalysis-config" title="Permalink"></a></h2><p>In addition to <a href="../config/#JET-configurations">general configurations</a>, the error analysis can take the following specific configurations:</p><article class="docstring"><header><a class="docstring-binding" id="JET.JETAnalyzer" href="#JET.JETAnalyzer"><code>JET.JETAnalyzer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Every <a href="#jetanalysis-entry">entry point of error analysis</a> can accept any of <a href="../config/#JET-configurations">general JET configurations</a> as well as the following additional configurations that are specific to the error analysis.</p><hr/><ul><li><p><code>mode::Symbol = :basic</code>:<br/>Switches the error analysis pass. Each analysis pass reports errors according to their own &quot;error&quot; definition. JET by default offers the following modes:</p><ul><li><code>mode = :basic</code>: the default error analysis pass. This analysis pass is tuned to be useful for general Julia development by reporting common problems, but also note that it is not enough strict to guarantee that your program never throws runtime errors.<br/>See <a href="#JET.BasicPass"><code>BasicPass</code></a> for more details.</li><li><code>mode = :sound</code>: the sound error analysis pass. If this pass doesn&#39;t report any errors, then your program is assured to run without any runtime errors (unless JET&#39;s error definition is not accurate and/or there is an implementation flaw).<br/>See <a href="#JET.SoundPass"><code>SoundPass</code></a> for more details.</li><li><code>mode = :typo</code>: a typo detection pass A simple analysis pass to detect &quot;typo&quot;s in your program. This analysis pass is essentially a subset of the default basic pass (<a href="#JET.BasicPass"><code>BasicPass</code></a>), and it only reports undefined global reference and undefined field access. This might be useful especially for a very complex code base, because even the basic pass tends to be too noisy (spammed with too many errors) for such a case.<br/>See <a href="#JET.TypoPass"><code>TypoPass</code></a> for more details.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You can also set up your own analysis using JET&#39;s <a href="../generated-plugin-api/#AbstractAnalyzer-Framework"><code>AbstractAnalyzer</code>-Framework</a>.</p></div></div></li></ul><hr/></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/f6e1d17c54caf78bc5729a8cc27a58d40a8d8542/src/analyzers/jetanalyzer.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.BasicPass" href="#JET.BasicPass"><code>JET.BasicPass</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The basic (default) error analysis pass.</p><p><em><strong>TODO</strong></em>: elaborate the definitions of &quot;error&quot;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/f6e1d17c54caf78bc5729a8cc27a58d40a8d8542/src/analyzers/jetanalyzer.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.SoundPass" href="#JET.SoundPass"><code>JET.SoundPass</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The sound error analysis pass.</p><p><em><strong>TODO</strong></em>: elaborate the definitions of &quot;error&quot;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/f6e1d17c54caf78bc5729a8cc27a58d40a8d8542/src/analyzers/jetanalyzer.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.TypoPass" href="#JET.TypoPass"><code>JET.TypoPass</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A typo detection pass.</p><p><em><strong>TODO</strong></em>: elaborate the definitions of &quot;error&quot;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/f6e1d17c54caf78bc5729a8cc27a58d40a8d8542/src/analyzers/jetanalyzer.jl#L112-L116">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>We used <code>target_modules</code> just for the sake of demonstration. To make it idiomatic, we can   initialize <code>a</code> as typed vector <code>a = Int[]</code>, and then we won&#39;t get any problem from <code>sum(a)</code>   even without the <code>target_modules</code> configuration.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Actually JET offers the framework to define your own abstract interpretation based analysis.   See <a href="../generated-plugin-api/#AbstractAnalyzer-Framework"><code>AbstractAnalyzer</code>-Framework</a> if interested.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« README</a><a class="docs-footer-nextpage" href="../optanalysis/">Optimization Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.14 on <span class="colophon-date" title="Friday 18 March 2022 07:26">Friday 18 March 2022</span>. Using Julia version 1.9.0-DEV.212.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
