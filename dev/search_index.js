var documenterSearchIndex = {"docs":
[{"location":"optanalysis/#optanalysis","page":"Optimization Analysis","title":"Optimization Analysis","text":"","category":"section"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"Successful type inference and optimization is key to high-performing Julia programs. But as mentioned in the performance tips, there are some chances where Julia can not infer the types of your program very well and can not optimize it well accordingly.","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"While there are many possibilities of \"type-instabilities\", like usage of non-constant global variable most notably, probably the most tricky one would be \"captured variable\" – Julia can not really well infer the type of variable that is observed and modified by both inner function and enclosing one. And such type instabilities can lead to various optimization failures. One of the most common barrier to the performance is known as \"runtime dispatch\", which happens when a matching method can't be resolved by the compiler due to the lack of type information and it is looked up at runtime instead. Since runtime dispatch is caused by poor type information, it often indicates the compiler could not do other optimizations including inlining and scalar replacements of aggregates.","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"In order to avoid such problems, we usually inspect output of code_typed or its family, and check if there is anywhere type is not well inferred and optimization was not successful. But the problem is that one needs to have enough knowledge about the inference and optimization in order to interpret the output. Another problem is that they can only present the \"final\" output of the inference and optimization, and we can not inspect the entire call graph and may miss to find where a problem actually happened and how the type-instability has been propagated. There is a nice package called Cthulhu.jl, which allows us to look at the outputs of code_typed by descending into a call tree, recursively and interactively. The workflow with Cthulhu is much more efficient and powerful, but still, it requires much familiarity with Julia compiler and it tends to be tedious.","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"So, why not automate it ? JET implements such an analyzer that investigates optimized representation of your program and automatically detects anywhere the compiler failed in optimization. Especially, it can find where Julia creates captured variables, where runtime dispatch will happen, and where Julia gives up the optimization work due to unresolvable recursive function call.","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"SnoopCompile also detects inference failures, but JET and SnoopCompile use different mechanisms: JET performs static analysis of a particular call, while SnoopCompile performs dynamic analysis of new inference. As a consequence, JET's detection of inference failures is reproducible (you can run the same analysis repeatedly and get the same result) but terminates at any non-inferrable node of the call graph: you will miss runtime dispatch in any non-inferrable callees. Conversely, SnoopCompile's detection of inference failures can explore the entire callgraph, but only for those portions that have not been previously inferred, and the analysis cannot be repeated in the same session.","category":"page"},{"location":"optanalysis/#optanalysis-quick-start","page":"Optimization Analysis","title":"Quick Start","text":"","category":"section"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"JET exports @report_opt, which analyzes the entire call graph of a given generic function call, and then reports detected performance pitfalls:","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"using JET","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"As a first example, let's see how we can find and fix runtime dispatches using JET:","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"n = rand(Int); # non-constant global variable\nmake_vals(n) = n ≥ 0 ? (zero(n):n) : (n:zero(n));\nfunction sumup(f)\n    # this function uses the non-constant global variable `n` here\n    # and it makes every succeeding operations type-unstable\n    vals = make_vals(n)\n    s = zero(eltype(vals))\n    for v in vals\n        s += f(v)\n    end\n    return s\nend;\n@report_opt sumup(sin) # runtime dispatches will be reported","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"JET's analysis result will be dynamically updated when we (re-)define functions[1], and we can \"hot-fix\" the runtime dispatches within the same running Julia session like this:","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"# we can pass parameters as a function argument instead, and then everything will be type-stable\nfunction sumup(f, n)\n    vals = make_vals(n)\n    s = zero(eltype(vals))\n    for v in vals\n        # NOTE here we may get union type like `s::Union{Int,Float64}`,\n        # but Julia can optimize away such small unions (thus no runtime dispatch)\n        s += f(v)\n    end\n    return s\nend;\n\n@report_opt sumup(sin, rand(Int)) # now runtime dispatch free !","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"[1]: Technically, it's fully integrated with Julia's method invalidation system.","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"@report_opt can also report existence of captured variables, which are really better to be eliminated within performance-sensitive context:","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"# the examples below are all adapted from https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-captured\nfunction abmult(r::Int)\n    if r < 0\n        r = -r\n    end\n    # the closure assigned to `f` make the variable `r` captured\n    f = x -> x * r\n    return f\nend;\n@report_opt abmult(42)\n\nfunction abmult(r0::Int)\n    # we can improve the type stability of the variable `r` like this,\n    # but it is still captured\n    r::Int = r0\n    if r < 0\n        r = -r\n    end\n    f = x -> x * r\n    return f\nend;\n@report_opt abmult(42)\n\nfunction abmult(r::Int)\n    if r < 0\n        r = -r\n    end\n    # we can try to eliminate the capturing\n    # and now this function would be most high-performing\n    f = let r = r\n        x -> x * r\n    end\n    return f\nend;\n@report_opt abmult(42)","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"With the target_modules configuration, we can easily limit the analysis scope to a specific module context:","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"# problem: when ∑1/n exceeds `x` ?\nfunction compute(x)\n    r = 1\n    s = 0.0\n    n = 1\n    @time while r < x\n        s += 1/n\n        if s ≥ r\n            # `println` call is full of runtime dispatches for good reasons\n            # and we're not interested in type-instabilities within this call\n            # since we know it's only called few times\n            println(\"round $r/$x has been finished\")\n            r += 1\n        end\n        n += 1\n    end\n    return n, s\nend\n\n@report_opt compute(30) # bunch of reports will be reported from the `println` call\n\n@report_opt target_modules=(@__MODULE__,) compute(30) # focus on what we wrote, and no error should be reported","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"There is also function_filter, which can ignore specific function call.","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"@test_opt can be used to assert that a given function call is free from the performance pitfalls. It is fully integrated with Test standard library's unit-testing infrastructure, and we can use it as like other Test macros e.g. @test:","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"@test_opt sumup(cos)\n\n@test_opt target_modules=(@__MODULE__,) compute(30)\n\nusing Test\n\n@testset \"check type-stabilities\" begin\n    @test_opt sumup(cos) # should fail\n\n    n = rand(Int)\n    @test_opt sumup(cos, n) # should pass\n\n    @test_opt target_modules=(@__MODULE__,) compute(30) # should pass\n\n    @test_opt broken=true compute(30) # should pass with the \"broken\" annotation\nend","category":"page"},{"location":"optanalysis/#optanalysis-entry","page":"Optimization Analysis","title":"Entry Points","text":"","category":"section"},{"location":"optanalysis/#optanalysis-interactive-entry","page":"Optimization Analysis","title":"Interactive Entry Points","text":"","category":"section"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"The optimization analysis offers interactive entry points that can be used in the same way as @report_call and report_call:","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"JET.@report_opt\nJET.report_opt","category":"page"},{"location":"optanalysis/#JET.@report_opt","page":"Optimization Analysis","title":"JET.@report_opt","text":"@report_opt [jetconfigs...] f(args...)\n\nEvaluates the arguments to the function call, determines its types, and then calls report_opt on the resulting expression. As with @code_typed and its family, any of JET configurations or optimization analysis specific configurations can be given as the optional arguments like this:\n\n# reports `rand(::Type{Bool})` with `unoptimize_throw_blocks` configuration turned on\njulia> @report_opt unoptimize_throw_blocks=true rand(Bool)\n\n\n\n\n\n","category":"macro"},{"location":"optanalysis/#JET.report_opt","page":"Optimization Analysis","title":"JET.report_opt","text":"report_opt(f, types = Tuple{}; jetconfigs...) -> JETCallResult\nreport_opt(tt::Type{<:Tuple}; jetconfigs...) -> JETCallResult\n\nAnalyzes the generic function call with the given type signature with the optimization analyzer, which collects optimization failures and runtime dispatches involved within the call stack.\n\n\n\n\n\n","category":"function"},{"location":"optanalysis/#optanalysis-test-integration","page":"Optimization Analysis","title":"Test Integration","text":"","category":"section"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"As with the default error analysis, the optimization analysis also offers the integration with Test standard library:","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"JET.@test_opt\nJET.test_opt","category":"page"},{"location":"optanalysis/#JET.@test_opt","page":"Optimization Analysis","title":"JET.@test_opt","text":"@test_opt [jetconfigs...] [broken=false] [skip=false] f(args...)\n\nTests the generic function call f(args...) is free from runtime dispatch. Returns a Pass result if it is, a Fail result if if contains any location where runtime dispatch or optimization failure happens, or an Error result if this macro encounters an unexpected error. When the test Fails, abstract call stack to each problem location will also be printed to stdout.\n\njulia> @test_opt sincos(10)\nTest Passed\n  Expression: #= none:1 =# JET.@test_opt sincos(10)\n\nAs with @report_opt, any of JET configurations or optimization analysis specific configurations can be given as the optional arguments like this:\n\njulia> function f(n)\n            r = sincos(n)\n            # `println` is full of runtime dispatches,\n            # but we can ignore the corresponding reports from `Base`\n            # with the `target_modules` configuration\n            println(r)\n            return r\n       end;\n\njulia> @test_opt target_modules=(@__MODULE__,) f(10)\nTest Passed\n  Expression: #= REPL[3]:1 =# JET.@test_call analyzer = JET.OptAnalyzer target_modules = (#= REPL[3]:1 =# @__MODULE__(),) f(10)\n\nLike @test_call, @test_opt is fully integrated with Test standard library. See @test_call for the details.\n\n\n\n\n\n","category":"macro"},{"location":"optanalysis/#JET.test_opt","page":"Optimization Analysis","title":"JET.test_opt","text":"test_opt(f, types = Tuple{}; broken::Bool = false, skip::Bool = false, jetconfigs...)\ntest_opt(tt::Type{<:Tuple}; broken::Bool = false, skip::Bool = false, jetconfigs...)\n\nTests the generic function call with the given type signature is free from runtime dispatch. Except that it takes a type signature rather than a call expression, this function works in the same way as @test_opt.\n\n\n\n\n\n","category":"function"},{"location":"optanalysis/#optanalysis-toplevel-entry","page":"Optimization Analysis","title":"Top-level Entry Points","text":"","category":"section"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"By default, JET doesn't offer top-level entry points for the optimization analysis, because it's usually used for only a selective portion of your program. But if you want you can just use report_file or similar top-level entry points with specifying analyzer = OptAnalyzer configuration in order to apply the optimization analysis on top-level script, e.g. report_file(\"path/to/file.jl\"; analyzer = OptAnalyzer).","category":"page"},{"location":"optanalysis/#optanalysis-config","page":"Optimization Analysis","title":"Configurations","text":"","category":"section"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"In addition to general configurations, the optimization analysis can take the following specific configurations:","category":"page"},{"location":"optanalysis/","page":"Optimization Analysis","title":"Optimization Analysis","text":"JET.OptAnalyzer","category":"page"},{"location":"optanalysis/#JET.OptAnalyzer","page":"Optimization Analysis","title":"JET.OptAnalyzer","text":"Every entry point of optimization analysis can accept any of general JET configurations as well as the following additional configurations that are specific to the optimization analysis.\n\n\n\nskip_noncompileable_calls::Bool = true:\nJulia's runtime dispatch is \"powerful\" because it can always compile code with concrete runtime arguments so that a \"kernel\" function runs very effectively even if it's called from a type-instable call site. This means, we (really) often accept that some parts of our code are not inferred statically, and rather we want to just rely on information that is only available at runtime. To model this programming style, the optimization analyzer by default does NOT report any optimization failures or runtime dispatches detected within non-concrete calls (more correctly, \"non-compileable\" calls are ignored: see also the note below). We can turn off this skip_noncompileable_calls configuration to get type-instabilities within those calls.\n# the following examples are adapted from https://docs.julialang.org/en/v1/manual/performance-tips/#kernel-functions\njulia> function fill_twos!(a)\n           for i = eachindex(a)\n               a[i] = 2\n           end\n       end;\n\njulia> function strange_twos(n)\n           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)\n           fill_twos!(a)\n           return a\n       end;\n\n# by default, only type-instabilities within concrete call (i.e. `strange_twos(3)`) are reported\n# and those within non-concrete calls (`fill_twos!(a)`) are not reported\njulia> @report_opt strange_twos(3)\n═════ 2 possible errors found ═════\n┌ @ REPL[2]:2 %45(Main.undef, n)\n│ runtime dispatch detected: %45::Type{Vector{_A}} where _A(Main.undef, n::Int64)\n└─────────────\n┌ @ REPL[2]:3 Main.fill_twos!(%46)\n│ runtime dispatch detected: Main.fill_twos!(%46::Vector)\n└─────────────\nVector (alias for Array{_A, 1} where _A)\n\n# we can get reports from non-concrete calls with `skip_noncompileable_calls=false`\njulia> @report_opt skip_noncompileable_calls=false strange_twos(3)\n═════ 4 possible errors found ═════\n┌ @ REPL[2]:3 Main.fill_twos!(a)\n│┌ @ REPL[1]:3 Base.setindex!(a, 2, %14)\n││ runtime dispatch detected: Base.setindex!(a::Vector, 2, %14::Int64)\n│└─────────────\n│┌ @ REPL[1]:3 Base.setindex!(a, 2, i)\n││┌ @ array.jl:877 Base.convert(_, x)\n│││ runtime dispatch detected: Base.convert(_::Any, x::Int64)\n││└────────────────\n┌ @ REPL[2]:2 %45(Main.undef, n)\n│ runtime dispatch detected: %45::Type{Vector{_A}} where _A(Main.undef, n::Int64)\n└─────────────\n┌ @ REPL[2]:3 Main.fill_twos!(%46)\n│ runtime dispatch detected: Main.fill_twos!(%46::Vector)\n└─────────────\nVector (alias for Array{_A, 1} where _A)\nnote: Non-compileable calls\nJulia runtime system sometimes generate and execute native code of an abstract call. More technically, when some of call arguments are annotated as @nospecialize, Julia compiles the call even if those @nospecialized arguments aren't fully concrete. skip_noncompileable_calls = true also respects this behavior, i.e. doesn't skip compileable abstract calls:julia> function maybesin(@nospecialize x)\n     if isa(x, Number)\n         return sin(x) # this call is dynamically dispatched\n     else\n         return 0\n     end\n end\n maybesin (generic function with 1 method)\n\n julia> report_opt((Vector{Any},)) do xs\n     for x in xs\n         s = maybesin(x) # this call is resolved statically and compiled\n         s !== 0 && return s\n     end\n end\n ═════ 1 possible error found ═════\n ┌ @ none:3 s = Main.maybesin(x)\n │┌ @ none:3 Main.sin(%3)\n ││ runtime dispatch detected: Main.sin(%3::Number)\n │└──────────\n\n julia> function maybesin(x)  # now `maybesin` is always called with concrete `x`\n            if isa(x, Number)\n                return sin(x) # this call is dynamically dispatched\n            else\n                return 0\n            end\n        end\n        maybesin (generic function with 1 method)\n\n julia> report_opt((Vector{Any},)) do xs\n            for x in xs\n                s = maybesin(x) # this call is dynamically dispatched\n                s !== 0 && return s\n            end\n        end\n ═════ 1 possible error found ═════\n ┌ @ none:3 Main.maybesin(%21)\n │ runtime dispatch detected: Main.maybesin(%21::Any)\n └──────────\n\n\n\nfunction_filter = @nospecialize(ft)->true:\nA predicate which takes a function type and returns false to skip runtime dispatch analysis on the function call. This configuration is particularly useful when your program uses a function that is intentionally written to use runtime dispatch.\n# ignores `Core.Compiler.widenconst` calls (since it's designed to be runtime-dispatched):\njulia> function_filter(@nospecialize(ft)) = ft !== typeof(Core.Compiler.widenconst)\n\njulia> @test_opt function_filter=function_filter f(args...)\n...\n\n\n\nskip_unoptimized_throw_blocks::Bool = true:\nBy default, Julia's native compilation pipeline intentionally disables inference (and so succeeding optimizations too) on \"throw blocks\", which are code blocks that will eventually lead to throw calls, in order to ease the compilation latency problem, a.k.a. \"first-time-to-plot\". Accordingly, the optimization analyzer also ignores any performance pitfalls detected within those blocks since we usually don't mind if code involved with error handling isn't optimized. If skip_unoptimized_throw_blocks is set to false, it doesn't ignore them and will report type instabilities detected within \"throw blocks\".\nSee also https://github.com/JuliaLang/julia/pull/35982.\n# by default, unoptimized \"throw blocks\" are not analyzed\njulia> @test_opt sin(10)\nTest Passed\n  Expression: #= none:1 =# JET.@test_opt sin(10)\n\n# we can turn on the analysis on unoptimized \"throw blocks\" with `skip_unoptimized_throw_blocks=false`\njulia> @test_opt skip_unoptimized_throw_blocks=false sin(10)\nJET-test failed at none:1\n  Expression: #= REPL[6]:1 =# JET.@test_call analyzer = JET.OptAnalyzer skip_unoptimized_throw_blocks = false sin(10)\n  ═════ 1 possible error found ═════\n  ┌ @ math.jl:1221 Base.Math.sin(xf)\n  │┌ @ special/trig.jl:39 Base.Math.sin_domain_error(x)\n  ││┌ @ special/trig.jl:28 Base.Math.DomainError(x, \"sin(x) is only defined for finite x.\")\n  │││ runtime dispatch detected: Base.Math.DomainError(x::Float64, \"sin(x) is only defined for finite x.\")\n  ││└──────────────────────\n\nERROR: There was an error during testing\n\n# we can also turns off the heuristic itself\njulia> @test_opt unoptimize_throw_blocks=false skip_unoptimized_throw_blocks=false sin(10)\nTest Passed\n  Expression: #= REPL[7]:1 =# JET.@test_call analyzer = JET.OptAnalyzer unoptimize_throw_blocks = false skip_unoptimized_throw_blocks = false sin(10)\n\n\n\n\n\n\n\n","category":"type"},{"location":"generated-plugin-api/#AbstractAnalyzer-Framework","page":"API","title":"AbstractAnalyzer Framework","text":"","category":"section"},{"location":"generated-plugin-api/","page":"API","title":"API","text":"Pages = [\"generated-plugin-api.md\"]","category":"page"},{"location":"generated-plugin-api/","page":"API","title":"API","text":"JET offers an infrastructure to implement a \"plugin\" code analyzer. Actually, JET's default error analyzer is one specific instance of such a pluggin analyzer built on top of the framework.","category":"page"},{"location":"generated-plugin-api/","page":"API","title":"API","text":"In this documentation we will try to elaborate the framework APIs and showcase example analyzers.","category":"page"},{"location":"generated-plugin-api/","page":"API","title":"API","text":"warning: Warning\nThe APIs described in this page is very experimental and subject to changes. And this documentation is also very WIP.","category":"page"},{"location":"generated-plugin-api/#Interfaces","page":"API","title":"Interfaces","text":"","category":"section"},{"location":"generated-plugin-api/","page":"API","title":"API","text":"JET.JETInterface\nJET.AbstractAnalyzer\nJET.AnalyzerState\nJET.ReportPass\nJET.get_cache_key\nJET.InferenceErrorReport\nJET.aggregation_policy\nJET.add_new_report!\nJET.get_msg\nJET.print_error_report\nJET.get_spec_args\nJET.@reportdef\nJET.VSCode.vscode_source\nJET.VSCode.vscode_diagnostics_order","category":"page"},{"location":"generated-plugin-api/#JET.JETInterface","page":"API","title":"JET.JETInterface","text":"JETInterface\n\nThis baremodule exports names that form the APIs of AbstractAnalyzer Framework. using JET.JETInterface loads all names that are necessary to define a plugin analysis.\n\n\n\n\n\n","category":"module"},{"location":"generated-plugin-api/#JET.AbstractAnalyzer","page":"API","title":"JET.AbstractAnalyzer","text":"abstract type AbstractAnalyzer <: AbstractInterpreter end\n\nAn interface type of analyzers that are built on top of JET's analyzer framework.\n\nWhen a new type NewAnalyzer implements the AbstractAnalyzer interface, it should be declared as subtype of AbstractAnalyzer, and is expected to the following interfaces:\n\n\n\nNewAnalyzer(; jetconfigs...) -> NewAnalyzer: \nConstructs new analyzer given JET configurations passed as jetconfigs.\n\n\n\nAnalyzerState(analyzer::NewAnalyzer) -> AnalyzerState: \nReturns the AnalyzerState for analyzer::NewAnalyzer.\n\n\n\nAbstractAnalyzer(analyzer::NewAnalyzer, state::AnalyzerState) -> NewAnalyzer: \nConstructs an new NewAnalyzer instance in the middle of JET's top-level analysis or abstract interpretation, given the previous analyzer::NewAnalyzer and state::AnalyzerState.\n\n\n\nReportPass(analyzer::NewAnalyzer) -> ReportPass: \nReturns ReportPass used for analyzer::NewAnalyzer.\n\n\n\nget_cache_key(analyzer::NewAnalyzer) -> cache_key::UInt: \nReturns cache_key::UInt used for analyzer::NewAnalyzer.\n\n\n\nSee also AnalyzerState, ReportPass and get_cache_key.\n\nExample\n\nJET.jl defines its default error analyzer JETAnalyzer <: AbstractAnalyzer as the following (modified a bit for the sake of simplicity):\n\n# the default error analyzer for JET.jl\nstruct JETAnalyzer{RP<:ReportPass} <: AbstractAnalyzer\n    report_pass::RP\n    state::AnalyzerState\nend\n\n# AbstractAnalyzer API requirements\n\nfunction JETAnalyzer(;\n    report_pass::ReportPass = BasicPass(),\n    jetconfigs...)\n    return JETAnalyzer(report_pass,\n                       AnalyzerState(; jetconfigs...),\n                       )\nend\nAnalyzerState(analyzer::JETAnalyzer) =\n    return analyzer.state\nAbstractAnalyzer(analyzer::JETAnalyzer, state::AnalyzerState) =\n    return JETAnalyzer(ReportPass(analyzer), state)\nReportPass(analyzer::JETAnalyzer) =\n    return analyzer.report_pass\n\n\n\n\n\n","category":"type"},{"location":"generated-plugin-api/#JET.AnalyzerState","page":"API","title":"JET.AnalyzerState","text":"mutable struct AnalyzerState\n    ...\nend\n\nThe mutable object that holds various states that are consumed by all AbstractAnalyzers.\n\n\n\nAnalyzerState(analyzer::AbstractAnalyzer) -> AnalyzerState\n\nIf NewAnalyzer implements the AbstractAnalyzer interface, NewAnalyzer should implement this AnalyzerState(analyzer::NewAnalyzer) -> AnalyzerState interface.\n\nA new AnalyzerState is supposed to be constructed using JET configurations passed as keyword arguments jetconfigs of the NewAnalyzer(; jetconfigs...) constructor, and the constructed AnalyzerState is usually kept within NewAnalyzer itself:\n\nfunction NewAnalyzer(; jetconfigs...)\n    ...\n    state = AnalyzerState(; jetconfigs...)\n    return NewAnalyzer(..., state)\nend\nAnalyzerState(analyzer::NewAnalyzer) = analyzer.state\n\n\n\n\n\n","category":"type"},{"location":"generated-plugin-api/#JET.ReportPass","page":"API","title":"JET.ReportPass","text":"abstract type ReportPass end\n\nAn interface type that represents AbstractAnalyzer's report pass. analyzer::AbstractAnalyzer injects report passes using the (::ReportPass)(::Type{InferenceErrorReport}, ::AbstractAnalyzer, state, ...) interface, which provides a flexible and efficient layer to configure the analysis done by AbstractAnalyzer.\n\n\n\nReportPass(analyzer::AbstractAnalyzer) -> ReportPass\n\nIf NewAnalyzer implements the AbstractAnalyzer interface, NewAnalyzer should implement this ReportPass(analyzer::NewAnalyzer) -> ReportPass interface.\n\nReportPass allows NewAnalyzer to provide a very flexible configuration layer for NewAnalyzer's analysis; an user can define their own ReportPass to control how NewAnalyzer collects report errors while still using the analysis routine implemented by NewAnalyzer.\n\nExample\n\nFor example, JETAnalyzer accepts a custom ReportPass passed as JET configurations (see the example documentation of AbstractAnalyzer for details). And we can setup a custom report pass IgnoreAllExceptGlobalUndefVar, that ignores all the reports that are otherwise collected by JETAnalyzer except GlobalUndefVarErrorReport:\n\n# custom report pass that ignores all the reports except `GlobalUndefVarErrorReport`\nstruct IgnoreAllExceptGlobalUndefVar <: ReportPass end\n\n# ignores all the reports analyzed by `JETAnalyzer`\n(::IgnoreAllExceptGlobalUndefVar)(::Type{<:InferenceErrorReport}, @nospecialize(_...)) = return\n\n# forward to `BasicPass` to collect `GlobalUndefVarErrorReport`\nfunction (::IgnoreAllExceptGlobalUndefVar)(::Type{GlobalUndefVarErrorReport}, @nospecialize(args...))\n    BasicPass()(GlobalUndefVarErrorReport, args...)\nend\n\nno_method_error()    = 1 + \"1\"\nundef_global_error() = undefvar\nreport_call(; report_pass=IgnoreAllExceptGlobalUndefVar()) do\n    if rand(Bool)\n        return no_method_error()    # \"no matching method found\" error report won't be reported here\n    else\n        return undef_global_error() # \"variable undefvar is not defined\" error report will be reported\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"generated-plugin-api/#JET.get_cache_key","page":"API","title":"JET.get_cache_key","text":"get_cache_key(analyzer::AbstractAnalyzer) -> cache_key::UInt\n\nReturns the cache key for this analyzer::AbstractAnalyzer. AbstractAnalyzers that have different cache keys will use different cache so that their analysis results are completely separated.\n\nSee also JET_CACHE.\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.InferenceErrorReport","page":"API","title":"JET.InferenceErrorReport","text":"InferenceErrorReport\n\nAn interface type of error reports that JET collects by abstract interpration. If T implements this interface, the following requirements should be satisfied:\n\n\n\nRequired fields \nT should have the following fields, which explains where and why this error is reported:\nvst::VirtualStackTrace: a virtual stack trace of the error\nmsg::String: explains why this error is reported\nsig::Signature: a signature of the error point\nNote that T can still have additional, specific fields.\n\n\n\nA constructor interface to create T from abstraction interpretation \nT<:InferenceErrorReport has the default constructor\nT(::AbstractAnalyzer, sv::InferenceState, spec_args...)\nwhich works when T is reported when sv's program counter (sv.currpc) points to that of statement where the error may happen. If so T just needs to overload\nJET.get_msg(::Type{T}, ::InferenceState, spec_args...) -> msg::String\nto provide the message that describes why this error is reported (otherwise the senseless default message will be used).\n\nIf T is reported when sv's program counter (sv.currpc) may not point to the error location or even sv::InferenceState isn't available, T can implement its own constructor method.\n\n\n\nA contructor interface to create T from the global report cache \nIn order to be cached and restored from JET_CACHE, T must implement the following interfaces:\nJET.get_spec_args(::T) -> Tuple{...}: returns fields that are specific to T, which is internally used by the caching logic\nT(vst::VirtualStackTrace, msg::String, sig::Signature spec_args::Tuple{...}) -> T: constructor to create T from the cache, which should expand spec_args into each specific field\n\n\n\nTo satisfy these requirements manually will be very tedious. JET internally uses @reportdef utility macro, which takes the struct definition of InferenceErrorReport and automatically defines the struct itself and the cache interfaces.\n\nSee also: VirtualStackTrace, VirtualFrame\n\n\n\n\n\n","category":"type"},{"location":"generated-plugin-api/#JET.aggregation_policy","page":"API","title":"JET.aggregation_policy","text":"aggregation_policy(analyzer::AbstractAnalyzer)\n\nDefines how analyzer aggregates InferenceErrorReports. Defaults to default_aggregation_policy.\n\n\n\ndefault_aggregation_policy(report::InferenceErrorReport) -> DefaultReportIdentity\n\nReturns the default identity of report::InferenceErrorReport, where DefaultReportIdentity aggregates reports based on \"error location\" of each report. DefaultReportIdentity aggregates InferenceErrorReports aggressively in a sense that it ignores the identity of error point's MethodInstance, under the assumption that errors are identical as far as they're collected at the same file and line.\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.add_new_report!","page":"API","title":"JET.add_new_report!","text":"add_new_report!(analyzer::AbstractAnalyzer, result::InferenceResult, report::InferenceErrorReport)\n\nAdds new report::InferenceErrorReport associated with result::InferenceResult.\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.VSCode.vscode_source","page":"API","title":"JET.VSCode.vscode_source","text":"vscode_source(analyzer::AbstractAnalyzer, source::AbstractString) -> String\n\nReturns \"source\" of diagnostics, which represents the identity of diagnostics.\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#JET.VSCode.vscode_diagnostics_order","page":"API","title":"JET.VSCode.vscode_diagnostics_order","text":"vscode_diagnostics_order(analyzer::AbstractAnalyzer) -> Bool\n\nIf true (default) a diagnostic will be reported at entry site. Otherwise it's reported at error point.\n\n\n\n\n\n","category":"function"},{"location":"generated-plugin-api/#Examples","page":"API","title":"Examples","text":"","category":"section"},{"location":"generated-plugin-api/","page":"API","title":"API","text":"Pages = [\"generated-plugin-examples/dispatch_analysis.md\", \"generated-plugin-examples/find_unstable_api.md\"]","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"EditURL = \"https://github.com/aviatesk/JET.jl/blob/master/examples/find_unstable_api.jl\"","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/#\"Unstable-API\"-Analysis","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"","category":"section"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"CurrentModule = JET","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/#Motivation","page":"\"Unstable API\" Analysis","title":"Motivation","text":"","category":"section"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"Julia doesn't have any facilities to truly hide module internals. This means, we can always access to whatever defined within a module and use it freely, but some of them may be considered as the module's \"internal\"s and subject to changes. When possible, we want to avoid their usages for better maintainability in the future. But the problem is, how can we automatically find them already used in an existing code ?","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"This analysis is motivated by this discussion.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/#Implementation","page":"\"Unstable API\" Analysis","title":"Implementation","text":"","category":"section"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"Let's define \"unstable API\" s such that, they're","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"undefined binding, or\nnot exported nor documented, if defined","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"and now we can implement such analyzer that detects code that matches the definition above using JET.jl's pluggable-analysis framework.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"The implementation below is almost sound, under the assumption that the bindings are resolved statically. One thing to note is that, the analysis implements an heuristic to avoid false positives from \"language intrinsics\", for example, Base.indexed_iterate and Base.Broadcast.broadcasted. They're usually introduced into your code implicitly by Julia's iteration protocols and such, and we're not responsible for their details (thus not interested in their usages). But the problem is that the analyzer below doesn't distinguish those introduced by the language and those written by ourselves, and in the latter case we're certainly uses \"unstable API\" under the definition above.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"using JET.JETInterface   # to load APIs of the pluggable analysis framework\nusing JET                # to use analysis entry points\nconst CC = Core.Compiler # to inject a customized report pass","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"First off, we define UnstableAPIAnalyzer, which is a new AbstractAnalyzer and will implement the customized report pass","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"struct UnstableAPIAnalyzer{T} <: AbstractAnalyzer\n    state::AnalyzerState\n    is_target_module::T\nend\nfunction UnstableAPIAnalyzer(;\n    is_target_module = ==(@__MODULE__),\n    jetconfigs...)\n    return UnstableAPIAnalyzer(AnalyzerState(; jetconfigs...), is_target_module)\nend\nJETInterface.AnalyzerState(analyzer::UnstableAPIAnalyzer) = analyzer.state\nJETInterface.AbstractAnalyzer(analyzer::UnstableAPIAnalyzer, state::AnalyzerState) =\n    UnstableAPIAnalyzer(state, analyzer.is_target_module)\nJETInterface.ReportPass(analyzer::UnstableAPIAnalyzer) = UnstableAPIAnalysisPass()\nJETInterface.get_cache_key(analyzer::UnstableAPIAnalyzer) = AnalyzerState(analyzer).param_key","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"Next, we overload some of Core.Compiler's abstract interpretation methods, and inject a customized analysis pass (here we gonna name it UnstableAPIAnalysisPass). In this analysis, we are interested in whether a binding that appears in a target code is an \"unstable API\" or not, and we can simply check if each abstract element appeared during abstract interpretation meets our criteria of \"unstable API\". For that purpose, it's suffice to overload Core.Compiler.abstract_eval_special_value and Core.Compiler.builtin_tfunction. To inject a report pass, we use ReportPass(::AbstractAnalyzer) interface.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"struct UnstableAPIAnalysisPass <: ReportPass end\n\nfunction CC.abstract_eval_special_value(analyzer::UnstableAPIAnalyzer, @nospecialize(e), vtypes::CC.VarTable, sv::CC.InferenceState)\n    if analyzer.is_target_module(sv.mod) # we care only about what we wrote\n        ReportPass(analyzer)(UnstableAPI, analyzer, sv, e)\n    end\n\n    # recurse into JET's default abstract interpretation routine\n    return Base.@invoke CC.abstract_eval_special_value(analyzer::AbstractAnalyzer, e, vtypes::CC.VarTable, sv::CC.InferenceState)\nend\n\nfunction CC.builtin_tfunction(analyzer::UnstableAPIAnalyzer, @nospecialize(f), argtypes::Vector{Any}, sv::CC.InferenceState)\n    if f === getfield\n        if length(argtypes) ≥ 2\n            a1, a2 = argtypes[1:2]\n            if isa(a1, Core.Const) && (v1 = a1.val; isa(v1, Module))\n                if isa(a2, Core.Const) && (v2 = a2.val; isa(v2, Symbol))\n                    if analyzer.is_target_module(sv.mod) || # we care only about what we wrote, but with relaxed filter\n                       (parent = sv.parent; isa(parent, CC.InferenceState) && analyzer.is_target_module(parent.mod))\n                        ReportPass(analyzer)(UnstableAPI, analyzer, sv, GlobalRef(v1, v2))\n                    end\n                end\n            end\n        end\n    end\n\n    # recurse into JET's default abstract interpretation routine\n    return Base.@invoke CC.builtin_tfunction(analyzer::AbstractAnalyzer, f, argtypes::Vector{Any}, sv::CC.InferenceState)\nend","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"Additionally, we can cut off the performance cost involved with Julia's native compiler's optimizations passes:","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"CC.may_optimize(analyzer::UnstableAPIAnalyzer) = return false","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"Now we implement the body of our analysis. We define \"unstable API\"s such that they're:","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"undefined binding, or\nnot exported nor documented, if defined","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"and we're not interested in any other program properties other than whether our code contains \"unstable API\"s or not.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"So in our report pass, we would like to ignore all the reports implemented by JET.jl by default","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"(::UnstableAPIAnalysisPass)(T::Type{<:InferenceErrorReport}, analyzer, state, @nospecialize(spec_args...)) = return","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"but except the report of undefined global references (i.e. GlobalUndefVarErrorReport). This overload allow us to find code that falls into the category 1.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"function (::UnstableAPIAnalysisPass)(T::Type{JET.GlobalUndefVarErrorReport}, analyzer, state, @nospecialize(spec_args...))\n    JET.BasicPass()(T, analyzer, state, spec_args...) # forward to JET's default report pass\nend","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"And now we will define new InferenceErrorReport report type UnstableAPI, which represents the category 2, and implement a report pass to detect it.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"@reportdef struct UnstableAPI <: InferenceErrorReport\n    g::GlobalRef\nend\nfunction JETInterface.get_msg(::Type{UnstableAPI}, sv, g::GlobalRef)\n    (; mod, name) = Base.resolve(g) # resolve to original name\n    return \"usage of unstable API `$mod.$name` found\"\nend\n\nfunction (::UnstableAPIAnalysisPass)(::Type{UnstableAPI}, analyzer::UnstableAPIAnalyzer, sv, @nospecialize(e))\n    if isa(e, GlobalRef)\n        isdefined(e.mod, e.name) || return false # this global reference falls into the category 1, should be caught by `GlobalUndefVarErrorReport` instead\n\n        (; mod, name) = Base.resolve(e) # this reference will be safely resolved\n        analyzer.is_target_module(mod) && return # we don't care about what we defined ourselves\n\n        if isunstable(mod, name)\n            add_new_report!(analyzer, sv.result, UnstableAPI(sv, e))\n        end\n    end\nend","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"In the report pass above, isunstable will take the heavy lifting to find \"unstable API\"s. Here we will implement isunstable according to the definition above but with some heuristics to exclude language intrinsics, which can automatically be included into our code and aren't usually of our interest.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"function isunstable(mod, name)\n    # exclude language intrinsics\n    mod === Core && return false\n    x = getfield(mod, name)\n    x isa Core.Builtin && return false\n    (x === Base.indexed_iterate || x === Base.SizeUnknown) && return false # iteration protocol\n    (x === Base.Iterators.Filter || x === Base.Iterators.Flatten) && return false # iterator protocol\n    x === Base.Broadcast.broadcasted && return false # broadcase protocol\n    x === Base.kwerr && return false # ignore keyword lowering\n\n    return !isexported(mod, name) && !hasdoc(mod, name)\nend\n\nfunction isexported(mod, name)\n    (; mod, name) = Base.resolve(GlobalRef(mod, name))\n    return Base.isexported(mod, name)\nend\n\n# adapted from https://github.com/JunoLab/CodeTools.jl/blob/56e7f0b514a7476864c27523bcf9d4bc04699ce1/src/summaries.jl#L24-L34\n\nusing Base.Docs\nfunction hasdoc(mod, name)\n    binding = Docs.Binding(mod, name)\n    for m in Docs.modules\n        meta = Docs.meta(m)\n        haskey(meta, binding) && return true\n        (; mod, var) = binding\n        isdefined(mod, var) && haskey(meta, getfield(mod, var)) && return true\n    end\n    return false\nend","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/#Usages","page":"\"Unstable API\" Analysis","title":"Usages","text":"","category":"section"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"Now we find \"unstable API\"s in your code using JET's analysis entry points with passing UnstableAPIAnalyzer as the analyzer configuration.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/#Simple-cases","page":"\"Unstable API\" Analysis","title":"Simple cases","text":"","category":"section"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"Let's first use the interactive analysis entries and try simple test cases.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"UnstableAPIAnalyzer can find an \"unstable\" function:","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"function some_reflection_code(@nospecialize(f))\n    return any(Base.hasgenerator, methods(f)) # Base.hasgenerator is unstable\nend\n@report_call analyzer=UnstableAPIAnalyzer some_reflection_code(sin)","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"UnstableAPIAnalyzer can find an \"unstable\" global variable:","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"module foo; bar = 1 end\nreport_call((Any,); analyzer=UnstableAPIAnalyzer) do a\n    foo.bar + a # foo.bar is unstable\nend","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"UnstableAPIAnalyzer can detect \"unstable API\"s even if they're imported binding or nested reference (, which will be resolve to getproperty)","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"import Base: hasgenerator\nreport_call((Any,); analyzer=UnstableAPIAnalyzer) do mi\n    # NOTE every function call appearing here is unstable\n    ci = hasgenerator(mi) ? Core.Compiler.get_staged(mi) : Base.uncompressed_ast(mi)\nend","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/#Analyze-a-real-world-package","page":"\"Unstable API\" Analysis","title":"Analyze a real-world package","text":"","category":"section"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"Finally we can use JET's top-level analysis entry points to analyze a whole script or package.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"Here we will run UnstableAPIAnalyzer on IRTools.jl, which uses Base.isgenerated, which is renamed to Base.hasgenerator in Julia v1.7 and invoked the discussion at https://github.com/JuliaLang/julia/pull/40745#issuecomment-850876150. Especially, it uses Base.isgenerator here, and you can see the analyzer correctly detects it if you run the following code with IRTools@v0.4.2 installed.","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"is_irtools(mod) = occursin(\"IRTools\", string(Symbol(mod))) # module context will be virtualized by `report_package`, thus use string match\nreport_package(\"IRTools\"; analyzer=UnstableAPIAnalyzer, is_target_module=is_irtools)","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"═════ 59 possible errors found ═════\n┌ @ /Users/aviatesk/.julia/packages/IRTools/aSVI5/src/reflection/reflection.jl:39 Core.kwfunc(IRTools.Inner.invoke_meta)(Core.apply_type(Core.NamedTuple, (:world,))(Core.tuple(world)), IRTools.Inner.invoke_meta, T)\n│┌ @ /Users/aviatesk/.julia/packages/IRTools/aSVI5/src/reflection/reflection.jl:69 IRTools.Inner.#invoke_meta#6(world, _3, T)\n││┌ @ /Users/aviatesk/.julia/packages/IRTools/aSVI5/src/reflection/reflection.jl:74 Core.kwfunc(IRTools.Inner.meta)(Core.apply_type(Core.NamedTuple, (:types, :world))(Core.tuple(S, world)), IRTools.Inner.meta, T)\n│││┌ @ /Users/aviatesk/.julia/packages/IRTools/aSVI5/src/reflection/reflection.jl:38 IRTools.Inner.#meta#1(types, world, _3, T)\n││││┌ @ /Users/aviatesk/.julia/packages/IRTools/aSVI5/src/reflection/reflection.jl:43 Base._methods_by_ftype\n│││││ Base._methods_by_ftype is unstable !: Base._methods_by_ftype\n││││└─────────────────────────────────────────────────────────────────────────────────\n││││┌ @ /Users/aviatesk/.julia/packages/IRTools/aSVI5/src/reflection/reflection.jl:49 Base.isgenerated\n│││││ variable Base.isgenerated is not defined: Base.isgenerated\n││││└─────────────────────────────────────────────────────────────────────────────────\n││││┌ @ /Users/aviatesk/.julia/packages/IRTools/aSVI5/src/reflection/reflection.jl:49 Base.uncompressed_ast\n│││││ Base.uncompressed_ast is unstable !: Base.uncompressed_ast\n││││└─────────────────────────────────────────────────────────────────────────────────\n││││┌ @ /Users/aviatesk/.julia/packages/IRTools/aSVI5/src/reflection/reflection.jl:54\n... # many other \"unstable API\"s detected","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"","category":"page"},{"location":"generated-plugin-examples/find_unstable_api/","page":"\"Unstable API\" Analysis","title":"\"Unstable API\" Analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"jetanalysis/#jetanalysis","page":"Error Analysis","title":"Error Analysis","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"Julia's type system is quite expressive and its type inference is strong enough to generate highly optimized code from its very concise and generic program. But as opposed to other statically-compiled languages, Julia by design does NOT error nor warn anything even if it detects possible errors during its compilation process no matter how serious they are. Julia delays all the errors and warnings to the runtime.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"This is actually a core design choice of the language – on the one hand, Julia's dynamism allow it to work in places where data types are not fully decided ahead of runtime just because Julia doesn't require it – on the other hand, with Julia, it's not straightforward to have such modern development experiences that a typical static language can offer, including static type checking and very rich IDE features.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"JET is a trial to get the best of both worlds: can we have a sufficiently useful static analysis without losing all the beauty of Julia's dynamism ? JET directly employs Julia's builtin type inference system to enable a static analysis, so in that sense its approach is very different from \"gradual typing\", which is a common technique to bring static analysis into a dynamic language, as used for mypy for Python and TypeScript for JavaScript. Rather, Julia's type inference system and JET are powered by the technique called \"abstract interpretation\". As like Julia can effectively optimize your simple and generic program, JET can also analyze just a normal Julia program and smartly detect possible errors, but statically. So in other word, JET doesn't require any additional setups like scattering type annotations just for the sake of analysis.","category":"page"},{"location":"jetanalysis/#jetanalysis-quick-start","page":"Error Analysis","title":"Quick Start","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"First you need to install and load JET. JET is an ordinary Julia package, so you can install it via Julia's built-in package manager and use it as like other packages.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"; # ] add JET # install JET via the built-in package manager\n\nusing JET","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"Let's start with a simplest example: how JET can find anything wrong with sum(\"julia\") ? @report_call and report_call analyzes a given function call and get back the detected problems. They can be used in a similar way as @code_typed and code_typed, and those interactive entry points are the most easiest way to use JET:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"@report_call sum(\"julia\")","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"So JET found two possible problems. Now let's see how they can occur in actual execution:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"sum(\"julia\") # will lead to `MethodError: +(::Char, ::Char)`\nsum(\"\") # will lead to `MethodError: zero(Type{Char})`","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"We should note that @report_call sum(\"julia\") could detect both of those two different errors that can happen at runtime. This is because @report_call does a static analysis – it analyzes the function call in a way that does NOT rely on runtime, and so it can reason about all the possible executions ! This is one of the biggest advantages of static analysis, because other alternatives to check software qualities like \"testing\" usually rely on runtime and they can only represent a subset of all the possible executions.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"As mentioned above, JET is designed to work with just a normal Julia program. Let's define new arbitrary functions and run JET on it:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"function foo(s0)\n    a = []\n    for s in split(s0)\n        push!(a, bar(s))\n    end\n    return sum(a)\nend\n\nbar(s::String) = parse(Int, s)\n\n@report_call foo(\"1 2 3\")","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"Now let's fix this problematic code. Say, for some reason, we're not interested in errors that may happen in the context of Base – we want to focus on fixing the error that happens from the definition of bar. First, we can fix the definition of bar so that it can accept generic AbstractString input. JET's analysis result can be dynamically updated when we refine a function definition, and so we just need to add a new bar(::AbstractString) definition. As for the second error, we can use the target_modules configuration to limit the analysis scope to the current module context to ignore the possible error that may happen within sum(a)[1].","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"[1]: We used target_modules just for the sake of demonstration. To make it idiomatic, we can   initialize a as typed vector a = Int[], and then we won't get any problem from sum(a)   even without the target_modules configuration.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"# hot fix the definition of `bar`\nbar(s::AbstractString) = parse(Int, s)\n\n# now no errors should be reported !\n@report_call target_modules=(@__MODULE__,) foo(\"1 2 3\")","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"So far, we have used the default error analysis pass, which collects problems according to one specific definition of \"errors\" (see the JET.BasicPass for more details). JET offers other error reporting passes, including the \"sound\" error detection (JET.SoundPass) as well as the \"typo\" detection pass (JET.TypoPass)[2]. They can be switched using the mode configuration:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"[2]: Actually JET offers the framework to define your own abstract interpretation based analysis.   See AbstractAnalyzer-Framework if interested.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"function myifelse(cond, a, b)\n    if cond\n        return a\n    else\n        return b\n    end\nend\n\n# the default analysis pass doesn't report \"non-boolean (T) used in boolean context\" error\n# as far as there is possibility when the condition \"can\" be bool (NOTE: Bool <: Integer)\nreport_call(myifelse, (Integer, Int, Int))\n\n# the sound analyzer doens't permit such a case: it requires the type of a conditional value to be `Bool` strictly\nreport_call(myifelse, (Integer, Int, Int); mode=:sound)\n\nfunction strange_sum(a)\n    if rand(Bool)\n        undefsum(a)\n    else\n        sum(a)\n    end\nend\n\n# the default analysis pass will report both problems:\n# - `undefsum` is not defined\n# - `sum(a::Vector{Any})` can throw when `a` is empty\n@report_call strange_sum([])\n\n# the typo dection pass will only report the \"typo\"\n@report_call mode=:typo strange_sum([])","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"We can use @test_call and test_call to assert that your program is free from problems that @report_call can detect. They work nicely with Test standard library's unit-testing infrastructure:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"@test_call target_modules=(@__MODULE__,) foo(\"1 2 3\")\n\nusing Test\n\n# we can get the nice summery using `@testset` !\n@testset \"JET testset\" begin\n    @test_call target_modules=(@__MODULE__,) foo(\"1 2 3\") # should pass\n\n    test_call(myifelse, (Integer, Int, Int); mode=:sound)\n\n    @test_call broken=true foo(\"1 2 3\") # `broken` and `skip` options are supported\n\n    @test foo(\"1 2 3\") == 6 # of course other `Test` macros can be used in the same place\nend","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"JET actually uses JET itself in its test pipeline. JET's static analysis has been proven to be very useful and helped its development a lot. If interested, take a peek at JET's \"self check !!!\" testset.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"Lastly, let's see the example that demonstrates JET can analyze \"top-level\" program. The top-level analysis should be considered as a somewhat experimental feature, and at this moment you may need additional configurations to run it correctly. Please read the descriptions of top-level entry points and choose an appropriate entry point for your use case. Here we run report_file on demo.jl. It automatically extracts and loads \"definitions\" of functions, structs and such, and then analyzes their \"usages\" statically:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"report_file(normpath(Base.pkgdir(JET), \"demo.jl\"))","category":"page"},{"location":"jetanalysis/#jetanalysis-entry","page":"Error Analysis","title":"Entry Points","text":"","category":"section"},{"location":"jetanalysis/#jetanalysis-interactive-entry","page":"Error Analysis","title":"Interactive Entry Points","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"JET offers interactive analysis entry points that can be used similarly to code_typed and its family:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"JET.@report_call\nJET.report_call","category":"page"},{"location":"jetanalysis/#JET.@report_call","page":"Error Analysis","title":"JET.@report_call","text":"@report_call [jetconfigs...] f(args...)\n\nEvaluates the arguments to the function call, determines its types, and then calls report_call on the resulting expression. As with @code_typed and its family, any of JET configurations can be given as the optional arguments like this:\n\n# reports `rand(::Type{Bool})` with `aggressive_constant_propagation` configuration turned off\njulia> @report_call aggressive_constant_propagation=false rand(Bool)\n\n\n\n\n\n","category":"macro"},{"location":"jetanalysis/#JET.report_call","page":"Error Analysis","title":"JET.report_call","text":"report_call(f, types = Tuple{};\n            analyzer::Type{<:AbstractAnalyzer} = JETAnalyzer,\n            jetconfigs...) -> JETCallResult\nreport_call(tt::Type{<:Tuple};\n            analyzer::Type{<:AbstractAnalyzer} = JETAnalyzer,\n            jetconfigs...) -> JETCallResult\n\nAnalyzes the generic function call with the given type signature with analyzer. And finally returns the analysis result as JETCallResult.\n\n\n\n\n\n","category":"function"},{"location":"jetanalysis/#jetanalysis-test-integration","page":"Error Analysis","title":"Test Integration","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"JET also exports entries that are fully integrated with Test standard library's unit-testing infrastructure. It can be used in your test suite to assert your program is free from errors that JET can detect:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"JET.@test_call\nJET.test_call","category":"page"},{"location":"jetanalysis/#JET.@test_call","page":"Error Analysis","title":"JET.@test_call","text":"@test_call [jetconfigs...] [broken=false] [skip=false] f(args...)\n\nRuns @report_call jetconfigs... f(args...) and tests that the generic function call f(args...) is free from problems that @report_call can detect. If executed inside @testset, returns a Pass result if it is, a Fail result if it contains any error points detected, or an Error result if this macro encounters an unexpected error. When the test Fails, abstract call stack to each problem location will also be printed to stdout.\n\njulia> @test_call sincos(10)\nTest Passed\n  Expression: #= none:1 =# JET.@test_call sincos(10)\n\nAs with @report_call, any of JET configurations or analyzer specific configurations can be given as the optional arguments jetconfigs... like this:\n\njulia> cond = false\n\njulia> function f(n)\n           # `cond` is untyped, and will be reported by the sound analysis pass,\n           # while JET's default analysis pass will ignore it\n           if cond\n               return sin(n)\n           else\n               return cos(n)\n           end\n       end;\n\njulia> @test_call f(10)\nTest Passed\n  Expression: #= none:1 =# JET.@test_call f(10)\n\njulia> @test_call mode=:sound f(10)\nJET-test failed at none:1\n  Expression: #= none:1 =# JET.@test_call mode = :sound f(10)\n  ═════ 1 possible error found ═════\n  ┌ @ none:2 goto %4 if not Main.cond\n  │ non-boolean (Any) used in boolean context: goto %4 if not Main.cond\n  └──────────\n\nERROR: There was an error during testing\n\n@test_call is fully integrated with Test standard library's unit-testing infrastructure. It means, the result of @test_call will be included in the final @testset summary, it supports skip and broken annotations as like @test and its family:\n\njulia> using JET, Test\n\n# Julia can't propagate the type constraint `ref[]::Number` to `sin(ref[])`, JET will report `NoMethodError`\njulia> f(ref) = isa(ref[], Number) ? sin(ref[]) : nothing;\n\n# we can make it type-stable if we extract `ref[]` into a local variable `x`\njulia> g(ref) = (x = ref[]; isa(x, Number) ? sin(x) : nothing);\n\njulia> @testset \"check errors\" begin\n           ref = Ref{Union{Nothing,Int}}(0)\n           @test_call f(ref)             # fail\n           @test_call g(ref)             # fail\n           @test_call broken=true f(ref) # annotated as broken, thus still \"pass\"\n       end\ncheck errors: JET-test failed at none:3\n  Expression: #= none:3 =# JET.@test_call f(ref)\n  ═════ 1 possible error found ═════\n  ┌ @ none:1 Main.sin(Base.getindex(ref))\n  │ for 1 of union split cases, no matching method found for call signatures (Tuple{typeof(sin), Nothing})): Main.sin(Base.getindex(ref::Base.RefValue{Union{Nothing, Int64}})::Union{Nothing, Int64})\n  └──────────\n\nTest Summary: | Pass  Fail  Broken  Total\ncheck errors  |    1     1       1      3\nERROR: Some tests did not pass: 1 passed, 1 failed, 0 errored, 1 broken.\n\n\n\n\n\n","category":"macro"},{"location":"jetanalysis/#JET.test_call","page":"Error Analysis","title":"JET.test_call","text":"test_call(f, types = Tuple{}; broken::Bool = false, skip::Bool = false, jetconfigs...)\ntest_call(tt::Type{<:Tuple}; broken::Bool = false, skip::Bool = false, jetconfigs...)\n\nRuns report_call(f, types; jetconfigs... and tests that the generic function call f(args...) is free from problems that report_call can detect. Except that it takes a type signature rather than a call expression, this function works in the same way as @test_call.\n\n\n\n\n\n","category":"function"},{"location":"jetanalysis/#jetanalysis-toplevel-entry","page":"Error Analysis","title":"Top-level Entry Points","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"JET can also analyze your \"top-level\" program: it can just take your Julia script or package and will report possible errors.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"Note that JET will analyze your code \"half-statically\": JET will selectively interpret \"definitions\" (like a function or struct definition) and try to simulate Julia's top-level code execution. While it tries to avoid executing any other parts of code like function calls, but analyzes them based on abstract interpretation instead (and this is a part where JET statically analyzes your code). If you're interested in how JET selects \"top-level definitions\", please see JET.virtual_process.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"warning: Warning\nBecause JET will actually interpret \"definitions\" in your code, that part of top-level analysis certainly runs your code. So we should note that JET can cause some side effects from your code; for example JET will try to expand all the macros used in your code, and so the side effects involved with macro expansions will also happen in JET's analysis process.","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"JET.report_file\nJET.report_and_watch_file\nJET.report_package\nJET.report_text","category":"page"},{"location":"jetanalysis/#JET.report_file","page":"Error Analysis","title":"JET.report_file","text":"report_file(filename::AbstractString;\n            jetconfigs...) -> JETToplevelResult\n\nAnalyzes filename and returns JETToplevelResult.\n\nThis function will look for .JET.toml configuration file in the directory of filename, and search up the file tree until any .JET.toml is (or isn't) found. When found, the configurations specified in the file will be applied. See JET's configuration file for more details.\n\ntip: Tip\nWhen you want to analyze your package, but any file actually using it isn't available, the analyze_from_definitions option can be useful (see ToplevelConfig's analyze_from_definitions option). \nFor example, JET can analyze JET itself like below:# from the root directory of JET.jl\njulia> report_file(\"src/JET.jl\";\n                   analyze_from_definitions = true)See also: report_package\n\nnote: Note\nThis function will enable the toplevel_logger configuration by default with the default logging level. You can still explicitly specify and configure it:report_file(args...;\n            toplevel_logger = nothing, # suppress toplevel logger\n            jetconfigs...) # other configurationsSee JET's logging configurations for more details.\n\n\n\n\n\n","category":"function"},{"location":"jetanalysis/#JET.report_and_watch_file","page":"Error Analysis","title":"JET.report_and_watch_file","text":"report_and_watch_file(filename::AbstractString;\n                      jetconfigs...)\n\nWatches filename and keeps re-triggering analysis with report_file on code update. JET will try to analyze all the included files reachable from filename, and it will re-trigger analysis if there is code update detected in any of the included files.\n\nThis function internally uses Revise.jl to track code updates. Revise also offers possibilities to track changes in files that are not directly analyzed by JET, or even changes in Base files. See watch configurations for more details.\n\nSee also: report_file\n\n\n\n\n\n","category":"function"},{"location":"jetanalysis/#JET.report_package","page":"Error Analysis","title":"JET.report_package","text":"report_package(package::Union{AbstractString,Module};\n               jetconfigs...) -> JETToplevelResult\n\nAnalyzes package in the same way as report_file with the special default configurations, which are especially tuned for package analysis (see below for details). package can be either a Module or a String. In the latter case it must be the name of a package in your current environment.\n\nThis function configures analysis with the following configurations:\n\nanalyze_from_definitions = true: allows JET to enter analysis without top-level call sites; this is useful for package analysis since a package itself usually has only definitions but not usages (i.e. call sites)\nconcretization_patterns = [:(x_)]: concretizes every top-level code in a given package; concretizations are generally preferred for successful analysis as far as they're cheap, and a package definition doesn't contain heavy computations in general cases\n\nSee ToplevelConfig for more details.\n\n\n\nreport_package([io::IO = stdout];\n               jetconfigs...) -> res::ReportResult\n\nLike above but analyzes the package of the current project.\n\nSee also: report_file\n\n\n\n\n\n","category":"function"},{"location":"jetanalysis/#JET.report_text","page":"Error Analysis","title":"JET.report_text","text":"report_text(text::AbstractString,\n            filename::AbstractString = \"top-level\";\n            jetconfigs...) -> JETToplevelResult\n\nAnalyzes text and returns JETToplevelResult.\n\n\n\n\n\n","category":"function"},{"location":"jetanalysis/#jetanalysis-config","page":"Error Analysis","title":"Configurations","text":"","category":"section"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"In addition to general configurations, the error analysis can take the following specific configurations:","category":"page"},{"location":"jetanalysis/","page":"Error Analysis","title":"Error Analysis","text":"JET.JETAnalyzer\nJET.BasicPass\nJET.SoundPass\nJET.TypoPass","category":"page"},{"location":"jetanalysis/#JET.JETAnalyzer","page":"Error Analysis","title":"JET.JETAnalyzer","text":"Every entry point of error analysis can accept any of general JET configurations as well as the following additional configurations that are specific to the error analysis.\n\n\n\nmode::Symbol = :basic:\nSwitches the error analysis pass. Each analysis pass reports errors according to their own \"error\" definition. JET by default offers the following modes:\nmode = :basic: the default error analysis pass. This analysis pass is tuned to be useful for general Julia development by reporting common problems, but also note that it is not enough strict to guarantee that your program never throws runtime errors.\nSee BasicPass for more details.\nmode = :sound: the sound error analysis pass. If this pass doesn't report any errors, then your program is assured to run without any runtime errors (unless JET's error definition is not accurate and/or there is an implementation flaw).\nSee SoundPass for more details.\nmode = :typo: a typo detection pass A simple analysis pass to detect \"typo\"s in your program. This analysis pass is essentially a subset of the default basic pass (BasicPass), and it only reports undefined global reference and undefined field access. This might be useful especially for a very complex code base, because even the basic pass tends to be too noisy (spammed with too many errors) for such a case.\nSee TypoPass for more details.\nnote: Note\nYou can also set up your own analysis using JET's AbstractAnalyzer-Framework.\n\n\n\n\n\n\n\n","category":"type"},{"location":"jetanalysis/#JET.BasicPass","page":"Error Analysis","title":"JET.BasicPass","text":"The basic (default) error analysis pass.\n\nTODO: elaborate the definitions of \"error\"s.\n\n\n\n\n\n","category":"type"},{"location":"jetanalysis/#JET.SoundPass","page":"Error Analysis","title":"JET.SoundPass","text":"The sound error analysis pass.\n\nTODO: elaborate the definitions of \"error\"s.\n\n\n\n\n\n","category":"type"},{"location":"jetanalysis/#JET.TypoPass","page":"Error Analysis","title":"JET.TypoPass","text":"A typo detection pass.\n\nTODO: elaborate the definitions of \"error\"s.\n\n\n\n\n\n","category":"type"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"EditURL = \"https://github.com/aviatesk/JET.jl/blob/master/examples/dispatch_analysis.jl\"","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/#Dispatch-Analysis","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"","category":"section"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"CurrentModule = JET","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/#Motivation","page":"Dispatch Analysis","title":"Motivation","text":"","category":"section"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"When Julia compiles your code and type inference on it was not so successful, the compiler is likely to be unable to determine which method should be called at each generic function callsite, and then it will be looked up at runtime. That is called \"runtime dispatch\", which is known as a common source of performance problem – the compiler can't do various kinds of optimizations including inlining when it can't determine a single matching method, and method lookup itself can also be a bottleneck if the call happens many times.","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"In order to avoid this problem, we usually use code_typed, inspect its output, and check if there is anywhere type is not well inferred (i.e. where is \"type-instable\") and optimization was not successful. But the problem is that code_typed can only present the \"final\" output of inference or optimization, and we can't inspect an entire call graph and may not be able to find where a problem happened and how the \"type instability\" has been propagated.","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"There is a nice package called Cthulhu.jl, which allows us to inspect the output of code_typed by descending into a call tree, recursively and interactively. The workflow with Cthulhu is much more powerful, but still, it's tedious.","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"So, why not automate it ? We can use JET's pluggable analysis framework and create such an analyzer that automatically analyzes your code and alarms you when it detects anywhere Julia can't determine matching method statically and thus runtime dispatch will happen at runtime.","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/#Implementation","page":"Dispatch Analysis","title":"Implementation","text":"","category":"section"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"In this analysis, the analyzer will be designed to detect:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"where Julia compiler gives up optimization\nwhere a runtime dispatch will happen","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"The case 1. will happen when there are (mutually) recursive calls and Julia compiler decided not to do inference in order to make sure the inference's termination. In such a case, optimization won't happen and method dispatches aren't resolved statically, so we will just report it (as OptimizationFailureReport). In order to detect the case 2., we will inspect the optimized IR and look for :call expressions. :call expressions are such calls that were not resolved statically and will be dispatched at runtime (as opposed to :invoke expressions, that represent staticall resolved generic function calls).","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"We will define DispatchAnalyzer <: AbstractAnalyzer, and overload some of Core.Compiler methods with it:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"Core.Compiler.finish(frame::CC.InferenceState, analyzer::DispatchAnalyzer) to check if optimization will happen or not (the case 1.)\nCore.Compiler.finish!(analyzer::DispatchAnalyzer, caller::CC.InferenceResult) to inspect an optimized IR (the case 2.)","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"using JET.JETInterface\nconst CC = Core.Compiler\nimport JET:\n    JET,\n    @invoke,\n    isexpr\n\nstruct DispatchAnalyzer{T} <: AbstractAnalyzer\n    state::AnalyzerState\n    opts::BitVector\n    frame_filter::T\n    __cache_key::UInt\nend\nfunction DispatchAnalyzer(;\n    # a predicate, which takes `CC.InfernceState` and returns whether we want to analyze the call or not\n    frame_filter = x::Core.MethodInstance->true,\n    jetconfigs...)\n    state = AnalyzerState(; jetconfigs...)\n    # we want to run different analysis with a different filter, so include its hash into the cache key\n    cache_key = state.param_key\n    cache_key = hash(frame_filter, cache_key)\n    return DispatchAnalyzer(state, BitVector(), frame_filter, cache_key)\nend\n\n# AbstractAnalyzer API requirements\nJETInterface.AnalyzerState(analyzer::DispatchAnalyzer)                          = analyzer.state\nJETInterface.AbstractAnalyzer(analyzer::DispatchAnalyzer, state::AnalyzerState) = DispatchAnalyzer(state, analyzer.opts, analyzer.frame_filter, analyzer.__cache_key)\nJETInterface.ReportPass(analyzer::DispatchAnalyzer)                             = DispatchAnalysisPass()\nJETInterface.get_cache_key(analyzer::DispatchAnalyzer)                          = analyzer.__cache_key\n\nstruct DispatchAnalysisPass <: ReportPass end\n\n# ignore all reports defined by JET, since we'll just define our own reports\n(::DispatchAnalysisPass)(T::Type{<:InferenceErrorReport}, @nospecialize(_...)) = return\n\nfunction CC.finish!(analyzer::DispatchAnalyzer, frame::CC.InferenceState)\n    caller = frame.result\n\n    # get the source before running `finish!` to keep the reference to `OptimizationState`\n    src = caller.src\n\n    # run `finish!(::AbstractAnalyzer, ::CC.InferenceState)` first to convert the optimized `IRCode` into optimized `CodeInfo`\n    ret = @invoke CC.finish!(analyzer::AbstractAnalyzer, frame::CC.InferenceState)\n\n    if analyzer.frame_filter(frame.linfo)\n        if isa(src, Core.Const) # the optimization was very successful, nothing to report\n        elseif isnothing(src) # means, compiler decides not to do optimization\n            ReportPass(analyzer)(OptimizationFailureReport, analyzer, caller, src)\n        elseif isa(src, CC.OptimizationState) # the compiler optimized it, analyze it\n            ReportPass(analyzer)(RuntimeDispatchReport, analyzer, caller, src)\n        else # and thus this pass should never happen\n            # as we should already report `OptimizationFailureReport` for this case\n            throw(\"got $src, unexpected source found\")\n        end\n    end\n\n    return ret\nend\n\n@reportdef struct OptimizationFailureReport <: InferenceErrorReport end\nJETInterface.get_msg(::Type{OptimizationFailureReport}, args...) =\n    return \"failed to optimize\" #: signature of this MethodInstance\nfunction (::DispatchAnalysisPass)(::Type{OptimizationFailureReport}, analyzer::DispatchAnalyzer, result::CC.InferenceResult)\n    add_new_report!(analyzer, result, OptimizationFailureReport(result.linfo))\nend\n\n@reportdef struct RuntimeDispatchReport <: InferenceErrorReport end\nJETInterface.get_msg(::Type{RuntimeDispatchReport}, _) =\n    return \"runtime dispatch detected\" #: call signature\n\nfunction (::DispatchAnalysisPass)(::Type{RuntimeDispatchReport}, analyzer::DispatchAnalyzer, caller::CC.InferenceResult, opt::CC.OptimizationState)\n    (; sptypes, slottypes) = opt\n    for (pc, x) in enumerate(opt.src.code)\n        if isexpr(x, :call)\n            ft = CC.widenconst(CC.argextype(first(x.args), opt.src, sptypes, slottypes))\n            ft <: Core.Builtin && continue # ignore `:call`s of the builtin intrinsics\n            add_new_report!(analyzer, caller, RuntimeDispatchReport((opt, pc)))\n        end\n    end\nend","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/#Usages","page":"Dispatch Analysis","title":"Usages","text":"","category":"section"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"So we defined our analyzer. Let's setup utility analysis entries first:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"using JET, InteractiveUtils # to use analysis entry points\n\nfunction report_dispatch(@nospecialize(f), @nospecialize(types = Tuple{});\n                         analyzer = DispatchAnalyzer,\n                         jetconfigs...)\n    @assert analyzer === DispatchAnalyzer \"analyzer is fixed to $DispatchAnalyzer\"\n    report_call(f, types; analyzer, jetconfigs...)\nend\nmacro report_dispatch(ex0...)\n    return InteractiveUtils.gen_call_with_extracted_types_and_kwargs(__module__, :report_dispatch, ex0)\nend","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"Now we can just call @report_dispatch f(args...) and check if there are any problematic part within the entire call tree of f(args...).","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/#Simple-cases","page":"Dispatch Analysis","title":"Simple cases","text":"","category":"section"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"First, let's play with simple and factitious examples and check if DispatchAnalyzer works as expected.","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"getsomething(x::Any) = x\ngetsomething(x::Array) = x[]\ngetsomething(::Nothing) = throw(ArgumentError(\"nothing is nothing\"))\ngetsomething(::Missing) = throw(ArgumentError(\"too philosophical\"))","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"If callsite is type-stable (i.e. dispatched with concretely-typed arguments), any problem shouldn't be reported:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"@report_dispatch getsomething(42) # should be ok","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"But if the argument isn't well-typed, compiler can't determine which method to call, and it will lead to runtime dispatch:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"report_dispatch((Any,)) do a\n    getsomething(a) # runtime dispatch !\nend","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"Note that even if a call is not \"well-typed\" (i.e. it's not a concrete call), runtime dispatch won't happen as far as a single method can be resovled statically:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"report_dispatch((AbstractString,)) do a\n    getsomething(a) # this call isn't very concrete, but ok, Julia can optimize it\nend","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"Ok, working nicely so far. Let's move on to a bit more complicated examples. When working on inherently-untyped code base where we somehow need to deal with arbitrarily-typed objects at runtime (as like Julia's high-level compiler), the @nospecialize annotation can be very useful – it helps us avoids excessive code specialization by suppressing runtime dispatches with runtime object types. For example, let's assume we have a vector of arbitrary untyped objects used within an user-program and need to check if its element is Type-like object with the following logic:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"function isTypelike(x)\n    if isa(x, DataType)\n        return isa(x, DataType) && x.name === Type.body.name\n    elseif isa(x, Union)\n        return isTypelike(x.a) && isTypelike(x.b)\n    elseif isa(x, UnionAll)\n        return isTypelike(x.body)\n    else\n        return false\n    end\nend","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"But without @nospecialize, we gonna see runtime dispatches at the recursive call sites as they will be specialized at runtime. In this setup, we can suppress the runtime dipsatches and achieve a best performance by applying @nospecialize annotation to the argument x:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"function isTypelike′(@nospecialize x)\n    if isa(x, DataType)\n        return isa(x, DataType) && x.name === Type.body.name\n    elseif isa(x, Union)\n        return isTypelike′(x.a) && isTypelike′(x.b)\n    elseif isa(x, UnionAll)\n        return isTypelike′(x.body)\n    else\n        return false\n    end\nend","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"We can confirm the effect of @nospecialize with DispatchAnalyzer:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"report_dispatch((Vector{Any},)) do xs\n    x  = xs[1]\n    r  = isTypelike(x)  # this call will be runtime-dispatched\n    r′ = isTypelike′(x) # this call will be statically resolved (not runtime-dispatched)\n    return r, r′\nend","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"We can assert this report by looking at the output of code_typed, where isTypelike(x) remains as :call expression (meaning it will be dispatched at runtime) while isTypelike′(x) has been statically resolved and even inlined:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"code_typed((Vector{Any},)) do xs\n    x  = xs[1]\n    r  = isTypelike(x)  # this call will be runtime-dispatched\n    r′ = isTypelike′(x) # this call will be statically resolved (not runtime-dispatched)\n    return r, r′\nend","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/#Real-world-targets","page":"Dispatch Analysis","title":"Real-world targets","text":"","category":"section"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"Let's run DispatchAnalyzer on real-world code and check how it works. Here we will test with Julia's Base module.","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"Random number generation might be one of the most important feature for numerical computations, and so Julia's rand function should run fast. Let's see if it is free from runtime-dispatch.","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"@report_dispatch rand(1:1000)","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"Oh no, runtime dispatch happens there even in Base. Well, actually, this specific dispatch is expected. Especially, https://github.com/JuliaLang/julia/pull/35982 implements an heuristic to intentionally disable inference (and so succeeding optimizations too) in order to ease the latency problem, a.k.a. \"first-time-to-plot\". The report trace certainly suggests a dispatch was detected where ArgumentError can be thrown. We can turn off the heuristic by turning off the unoptimize_throw_blocks::Bool configuration, and this time any runtime dispatch won't be reported:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"@report_dispatch unoptimize_throw_blocks=false rand(1:1000) # nothing should be reported","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"Finally, let's see an example of very \"type-instable\" code maintained within Base. Typically, anything involving I/O is written in a very dynamic way for good reasons, and certainly, e.g. println(QuoteNode(nothing)) will yield bunch of runtime dispatches:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"@report_dispatch println(QuoteNode(nothing))\n═════ 585 possible errors found ═════\n┌ @ coreio.jl:4 Base.println(Core.tuple(Core.typeassert(Base.stdout, Base.IO)), xs...)\n│┌ @ strings/io.jl:73 Base.print(Core.tuple(io), xs, Core.tuple(\"\\n\")...)\n││┌ @ strings/io.jl:43 Base.lock(io)\n│││┌ @ show.jl:334 Base.lock(Base.getproperty(io, :io))\n# so many reports follow ...","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"But what if your code contains a single println call, which you're absolutely okay with the type instabilities involved with it (e.g. it's only called once or only in debug mode, or such), but still you want to assert that any other part of code is type-stable and dispatch-free ?","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"# problem: when ∑1/n exceeds 30 ?\nfunction compute(x)\n    r = 1\n    s = 0.0\n    n = 1\n    @time while r < x\n        s += 1/n\n        if s ≥ r\n            println(\"round $r/$x has been finished\") # we're not interested type-instabilities within this call\n            r += 1\n        end\n        n += 1\n    end\n    return n, s\nend","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"DispatchAnalyzer's frame_filter option can be useful for this, by allowing us to specify where it should and shouldn't run analysis. For example, we can limit the scope of analysis to the current module like this:","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"function module_filter(m) # fiter by module\n    return function (linfo::Core.MethodInstance)\n        def = linfo.def\n        isa(def, Method) ? def.module === m : def === m\n    end\nend\n\n# NOTE:\n# `compute(30)` will take more than hours in actual execution, according to https://twitter.com/genkuroki/status/1401332946707963909,\n# but `@report_dispatch` will just do abstract interpretation of the call, so will finish instantly\n@report_dispatch frame_filter=module_filter(@__MODULE__) compute(30)","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"","category":"page"},{"location":"generated-plugin-examples/dispatch_analysis/","page":"Dispatch Analysis","title":"Dispatch Analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#JET.jl","page":"README","title":"JET.jl","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"(Image: ) (Image: ) (Image: CI) (Image: codecov)","category":"page"},{"location":"","page":"README","title":"README","text":"JET.jl employs Julia's type inference to detect potential bugs.","category":"page"},{"location":"","page":"README","title":"README","text":"note: Note\nThe latest version of JET requires Julia versions 1.7 and higher; JET is tested against the current stable release as well as nightly version.  Also note that JET deeply relies on the type inference routine implemented in the Julia compiler, and so the analysis result can vary depending on your Julia version. In general, the newer your Julia version is, more accurately and quickly your can expect JET to analyze your code, assuming the Julia compiler keeps evolving all the time from now on.","category":"page"},{"location":"","page":"README","title":"README","text":"tip: Tip\nHold on tight and fasten your seatbelt while JET is analyzing your code for the first time. Once the caches get accumulated, subsequent analysis will run at ✈ speed.","category":"page"},{"location":"#Demo","page":"README","title":"Demo","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"Say you have this strange and buggy file and want to know where to fix:","category":"page"},{"location":"","page":"README","title":"README","text":"demo.jl","category":"page"},{"location":"","page":"README","title":"README","text":"# demo\n# ====\n\n# fibonacci\n# ---------\n\nfib(n) = n ≤ 2 ? n : fib(n-1) + fib(n-2)\n\nfib(1000)   # never terminates in ordinal execution\nfib(m)      # undef var\nfib(\"1000\") # obvious type error\n\n\n# language features\n# -----------------\n\n# user-defined types, macros\nstruct Ty{T}\n    fld::T\nend\n\nfunction foo(a)\n    v = Ty(a)\n    return bar(v)\nend\n\n# macros will be expanded\n@inline bar(n::T)     where {T<:Number} = n < 0 ? zero(T) : one(T)\n@inline bar(v::Ty{T}) where {T<:Number} = bar(v.fdl) # typo \"fdl\"\n@inline bar(v::Ty)                      = bar(convert(Number, v.fld))\n\nfoo(1.2)\nfoo(\"1\") # `String` can't be converted to `Number`\n\n# even staged programming\n# adapted from https://github.com/JuliaLang/julia/blob/9f665c19e076ab37cbca2d0cc99283b82e99c26f/base/namedtuple.jl#L253-L264\n@generated function badmerge(a::NamedTuple{an}, b::NamedTuple{bn}) where {an, bn}\n    names = Base.merge_names(an, bn)\n    types = Base.merge_types(names, a, b)\n    vals = Any[ :(getfield($(Base.sym_in(names[n], bn) ? :b : :a), $(names[n]))) for n in 1:length(names) ] # missing quote, just ends up with under vars\n    :( NamedTuple{$names,$types}(($(vals...),)) )\nend\n\nbadmerge((x=1,y=2), (y=3,z=1))","category":"page"},{"location":"","page":"README","title":"README","text":"You can have JET.jl detect possible errors:","category":"page"},{"location":"","page":"README","title":"README","text":"julia> using JET\n\njulia> report_and_watch_file(\"demo.jl\"; annotate_types = true)\n[toplevel-info] virtualized the context of Main (took 0.013 sec)\n[toplevel-info] entered into demo.jl\n[toplevel-info]  exited from demo.jl (took 3.254 sec)\n═════ 7 possible errors found ═════\n┌ @ demo.jl:10 fib(m)\n│ variable m is not defined: fib(m)\n└──────────────\n┌ @ demo.jl:11 fib(\"1000\")\n│┌ @ demo.jl:7 ≤(n::String, 2)\n││┌ @ operators.jl:401 Base.<(x::String, y::Int64)\n│││┌ @ operators.jl:352 Base.isless(x::String, y::Int64)\n││││ no matching method found for call signature (Tuple{typeof(isless), String, Int64}): Base.isless(x::String, y::Int64)\n│││└────────────────────\n┌ @ demo.jl:32 foo(1.2)\n│┌ @ demo.jl:24 bar(v::Ty{Float64})\n││┌ @ demo.jl:29 Base.getproperty(v::Ty{Float64}, :fdl::Symbol)\n│││┌ @ Base.jl:33 Base.getfield(x::Ty{Float64}, f::Symbol)\n││││ type Ty{Float64} has no field fdl\n│││└──────────────\n┌ @ demo.jl:33 foo(\"1\")\n│┌ @ demo.jl:24 bar(v::Ty{String})\n││┌ @ demo.jl:30 convert(Number, Base.getproperty(v::Ty{String}, :fld::Symbol)::String)\n│││ no matching method found for call signature (Tuple{typeof(convert), Type{Number}, String}): convert(Number, Base.getproperty(v::Ty{String}, :fld::Symbol)::String)\n││└──────────────\n┌ @ demo.jl:44 badmerge(Core.apply_type(Core.NamedTuple, Core.tuple(:x::Symbol, :y::Symbol)::Tuple{Symbol, Symbol})::Type{NamedTuple{(:x, :y)}}(Core.tuple(1, 2)::Tuple{Int64, Int64})::NamedTuple{(:x, :y), Tuple{Int64, Int64}}, Core.apply_type(Core.NamedTuple, Core.tuple(:y::Symbol, :z::Symbol)::Tuple{Symbol, Symbol})::Type{NamedTuple{(:y, :z)}}(Core.tuple(3, 1)::Tuple{Int64, Int64})::NamedTuple{(:y, :z), Tuple{Int64, Int64}})\n│┌ @ demo.jl:37 getfield(a::NamedTuple{(:x, :y), Tuple{Int64, Int64}}, x)\n││ variable x is not defined: getfield(a::NamedTuple{(:x, :y), Tuple{Int64, Int64}}, x)\n│└──────────────\n│┌ @ demo.jl:37 getfield(b::NamedTuple{(:y, :z), Tuple{Int64, Int64}}, y)\n││ variable y is not defined: getfield(b::NamedTuple{(:y, :z), Tuple{Int64, Int64}}, y)\n│└──────────────\n│┌ @ demo.jl:37 getfield(b::NamedTuple{(:y, :z), Tuple{Int64, Int64}}, z)\n││ variable z is not defined: getfield(b::NamedTuple{(:y, :z), Tuple{Int64, Int64}}, z)\n│└──────────────","category":"page"},{"location":"","page":"README","title":"README","text":"Hooray ! JET.jl found possible error points (e.g. MethodError: no method matching isless(::String, ::Int64)) given toplevel call signatures of generic functions (e.g. fib(\"1000\")).","category":"page"},{"location":"","page":"README","title":"README","text":"Note that JET can find these errors while demo.jl is so inefficient (especially the fib implementation) that it would never terminate in actual execution. That is possible because JET analyzes code only on type level. This technique is often called \"abstract interpretation\" and JET internally uses Julia's native type inference implementation, so it can analyze code as fast/correctly as Julia's code generation.","category":"page"},{"location":"","page":"README","title":"README","text":"Lastly let's apply the following diff to demo.jl so that it works nicely:","category":"page"},{"location":"","page":"README","title":"README","text":"fix-demo.jl.diff","category":"page"},{"location":"","page":"README","title":"README","text":"diff --git a/demo.jl b/demo.jl\nindex f868d2f..634e130 100644\n--- a/demo.jl\n+++ b/demo.jl\n@@ -4,11 +4,21 @@\n # fibonacci\n # ---------\n\n-fib(n) = n ≤ 2 ? n : fib(n-1) + fib(n-2)\n+# cache, cache, cache\n+function fib(n::T) where {T<:Number}\n+    cache = Dict(zero(T)=>zero(T), one(T)=>one(T))\n+    return _fib(n, cache)\n+end\n+_fib(n, cache) = if haskey(cache, n)\n+    cache[n]\n+else\n+    cache[n] = _fib(n-1, cache) + _fib(n-2, cache)\n+end\n\n-fib(1000)   # never terminates in ordinal execution\n-fib(m)      # undef var\n-fib(\"1000\") # obvious type error\n+fib(BigInt(1000)) # will terminate in ordinal execution as well\n+m = 1000          # define m\n+fib(m)\n+fib(parse(Int, \"1000\"))\n\n\n # language features\n@@ -26,19 +36,19 @@ end\n\n # macros will be expanded\n @inline bar(n::T)     where {T<:Number} = n < 0 ? zero(T) : one(T)\n-@inline bar(v::Ty{T}) where {T<:Number} = bar(v.fdl) # typo \"fdl\"\n+@inline bar(v::Ty{T}) where {T<:Number} = bar(v.fld) # typo fixed\n @inline bar(v::Ty)                      = bar(convert(Number, v.fld))\n\n foo(1.2)\n-foo(\"1\") # `String` can't be converted to `Number`\n+foo('1') # `Char` will be converted to `UInt32`\n\n # even staged programming\n # adapted from https://github.com/JuliaLang/julia/blob/9f665c19e076ab37cbca2d0cc99283b82e99c26f/base/namedtuple.jl#L253-L264\n-@generated function badmerge(a::NamedTuple{an}, b::NamedTuple{bn}) where {an, bn}\n+@generated function goodmerge(a::NamedTuple{an}, b::NamedTuple{bn}) where {an, bn}\n     names = Base.merge_names(an, bn)\n     types = Base.merge_types(names, a, b)\n-    vals = Any[ :(getfield($(Base.sym_in(names[n], bn) ? :b : :a), $(names[n]))) for n in 1:length(names) ] # missing quote, just ends up with under vars\n+    vals = Any[ :(getfield($(Base.sym_in(names[n], bn) ? :b : :a), $(QuoteNode(names[n])))) for n in 1:length(names) ] # names quoted, should work as expected\n     :( NamedTuple{$names,$types}(($(vals...),)) )\n end\n\n-badmerge((x=1,y=2), (y=3,z=1))\n+goodmerge((x=1,y=2), (y=3,z=1))","category":"page"},{"location":"","page":"README","title":"README","text":"If you apply the diff (i.e. update and save the demo.jl), JET will automatically re-trigger analysis, and this time, won't complain anything:","category":"page"},{"location":"","page":"README","title":"README","text":"git apply fix-demo.jl.diff","category":"page"},{"location":"","page":"README","title":"README","text":"[toplevel-info] virtualized the context of Main (took 0.004 sec)\n[toplevel-info] entered into demo.jl\n[toplevel-info]  exited from demo.jl (took 3.061 sec)\nNo errors detected","category":"page"},{"location":"#Limitations","page":"README","title":"Limitations","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"JET explores the functions you call directly as well as their inferrable callees. However, if the argument-types for a call cannot be inferred, JET does not analyze the callee. Consequently, a report of No errors detected does not imply that your entire codebase is free of errors.","category":"page"},{"location":"","page":"README","title":"README","text":"JET integrates with SnoopCompile, and you can sometimes use SnoopCompile to collect the data to perform more comprehensive analyses. SnoopCompile's limitation is that it only collects data for calls that have not been previously inferred, so you must perform this type of analysis in a fresh session.","category":"page"},{"location":"","page":"README","title":"README","text":"See SnoopCompile's JET-integration documentation for further details.","category":"page"},{"location":"#Roadmap","page":"README","title":"Roadmap","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"more accuracy: abstract interpretation can be improved yet more\nswitch to new type lattice design: to simplify the addition of further improvements\ndesign and introduce a more proper backward-analysis pass, e.g. effect and escape analysis: to enable further constraint propagation\nmore performance: JET should be much faster\naggregate similar errors more smartly and aggressively\nintroduce parallelism to Julia's native type inference routine\nbetter documentation: especially JET needs a specification of its error reports\neditor/IDE integration: GUI would definitely be more appropriate for showing JET's analysis result\nsmarter code dependency tracking: the watch mode currently re-analyzes the whole code on each update, which is the most robust and least efficient option. When integrated with an IDE, fancier incremental analysis based on smarter code dependency tracking like what Revise.jl does would be needed\nLSP support: ideally I hope to extend JET to provide some of LSP features other than diagnostics, e.g. auto-completions, rename refactor, taking type-level information into account","category":"page"},{"location":"#Acknowledgement","page":"README","title":"Acknowledgement","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"This project started as my undergrad thesis project at Kyoto University, supervised by Prof. Takashi Sakuragawa. We were heavily inspired by ruby/typeprof, an experimental type understanding/checking tool for Ruby. The grad thesis about this project is published at https://github.com/aviatesk/grad-thesis, but currently it's only available in Japanese.","category":"page"},{"location":"internals/#Internals-of-JET.jl","page":"Internals","title":"Internals of JET.jl","text":"","category":"section"},{"location":"internals/#abstractinterpret","page":"Internals","title":"Abstract Interpretation","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"In order to perform type level program analysis, JET.jl uses Core.Compiler.AbstractInterpreter interface, and customizes its abstract interpretation by overloading subset of Core.Compiler functions, that are originally developed for Julia compiler's type inference and optimizations that aim at generating efficient native code for CPU execution.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"JET.AbstractAnalyzer overloads a set of Core.Compiler functions to implement the \"core\" functionalities of JET's analysis, including inter-procedural error report propagation and caching of analysis result. And each plugin analyzer (e.g. JET.JETAnalyzer) will overload more Core.Compiler functions so that it can perform its own program analysis on top of the core AbstractAnalyzer infrastructure.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Most overloads use the invoke reflection, which allows AbstractAnalyzer to dispatch to the original AbstractInterpreter's abstract interpretation methods while still passing AbstractAnalyzer to the subsequent (maybe overloaded) callees (see JET.@invoke macro).","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"JET.JETResult\nJET.islineage\nJET.bail_out_toplevel_call\nJET.bail_out_call\nJET.add_call_backedges!\nJET.const_prop_entry_heuristic\nJET.analyze_task_parallel_code!","category":"page"},{"location":"internals/#JET.JETResult","page":"Internals","title":"JET.JETResult","text":"JETResult\n\nanalyzer::AbstractAnalyzer manages InferenceErrorReport associating it with InferenceResult. InferenceErrorReports found within currently-analyzed result::InferenceResult can be accessed with get_reports(analyzer, result).\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.islineage","page":"Internals","title":"JET.islineage","text":"islineage(parent::MethodInstance, current::MethodInstance) ->\n    (report::InferenceErrorReport) -> Bool\n\nReturns a function that checks if a given InferenceErrorReport\n\nis generated from current, and\nis \"lineage\" of parent (i.e. entered from it).\n\nThis function is supposed to be used when additional analysis with extended lattice information happens in order to filter out reports collected from current by analysis without using that extended information. When a report should be filtered out, the first virtual stack frame represents parent and the second does current.\n\nExample:\n\nentry\n└─ linfo1 (report1: linfo1->linfo2)\n   ├─ linfo2 (report1: linfo2)\n   ├─ linfo3 (report2: linfo3->linfo2)\n   │  └─ linfo2 (report2: linfo2)\n   └─ linfo3′ (~~report2: linfo3->linfo2~~)\n\nIn the example analysis above, report2 should be filtered out on re-entering into linfo3′ (i.e. when we're analyzing linfo3 with constant arguments), nevertheless report1 shouldn't because it is not detected within linfo3 but within linfo1 (so it's not a \"lineage of linfo3\"):\n\nislineage(linfo1, linfo3)(report2) === true\nislineage(linfo1, linfo3)(report1) === false\n\n\n\n\n\n","category":"function"},{"location":"internals/#Core.Compiler.bail_out_toplevel_call","page":"Internals","title":"Core.Compiler.bail_out_toplevel_call","text":"bail_out_toplevel_call(analyzer::AbstractAnalyzer, ...)\n\nAn overload for abstract_call_gf_by_type(analyzer::AbstractAnalyzer, ...), which keeps inference on non-concrete call sites in a toplevel frame created by virtual_process.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Core.Compiler.bail_out_call","page":"Internals","title":"Core.Compiler.bail_out_call","text":"bail_out_call(analyzer::JETAnalyzer, ...)\n\nWith this overload, abstract_call_gf_by_type(analyzer::JETAnalyzer, ...) doesn't bail out inference even after the current return type grows up to Any and collects as much error points as possible. Of course this slows down inference performance, but hoopefully it stays to be \"practical\" speed since the number of matching methods are limited beforehand.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Core.Compiler.add_call_backedges!","page":"Internals","title":"Core.Compiler.add_call_backedges!","text":"add_call_backedges!(analyzer::JETAnalyzer, ...)\n\nAn overload for abstract_call_gf_by_type(analyzer::JETAnalyzer, ...), which always add backedges (even if a new method can't refine the return type grew up to Any). This is because a new method definition always has a potential to change JETAnalyzer's analysis result.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Core.Compiler.const_prop_entry_heuristic","page":"Internals","title":"Core.Compiler.const_prop_entry_heuristic","text":"const_prop_entry_heuristic(analyzer::JETAnalyzer, result::MethodCallResult, sv::InferenceState)\n\nThis overload for abstract_call_method_with_const_args(analyzer::JETAnalyzer, ...) forces constant prop' even if an inference result can't be improved anymore with respect to the return type, e.g. when result.rt is already Const. Especially, this overload implements an heuristic to force constant prop' when any error points have been reported while the previous abstract method call without constant arguments. The reason we want much more aggressive constant propagation by that heuristic is that it's highly possible constant prop' can produce more accurate analysis result, by throwing away false positive error reports by cutting off the unreachable control flow or detecting must-reachable throw calls.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JET.analyze_task_parallel_code!","page":"Internals","title":"JET.analyze_task_parallel_code!","text":"analyze_task_parallel_code!(analyzer::AbstractAnalyzer, argtypes::Argtypes, sv::InferenceState)\n\nAdds special cased analysis pass for task parallelism. In Julia's task parallelism implementation, parallel code is represented as closure and it's wrapped in a Task object. NativeInterpreter doesn't infer nor optimize the bodies of those closures when compiling code that creates parallel tasks, but JET will try to run additional analysis pass by recurring into the closures.\n\nSee also: https://github.com/aviatesk/JET.jl/issues/114\n\nnote: Note\nJET won't do anything other than doing JET analysis, e.g. won't annotate return type of wrapped code block in order to not confuse the original AbstractInterpreter routine track https://github.com/JuliaLang/julia/pull/39773 for the changes in native abstract interpretation routine.\n\n\n\n\n\n","category":"function"},{"location":"internals/#How-AbstractAnalyzer-manages-caches","page":"Internals","title":"How AbstractAnalyzer manages caches","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"JET.JET_CACHE\nJET.JETCachedResult\nJET.inlining_policy","category":"page"},{"location":"internals/#JET.JET_CACHE","page":"Internals","title":"JET.JET_CACHE","text":"JET_CACHE::IdDict{UInt64, IdDict{Core.MethodInstance, Core.CodeInstance}}\n\nKeeps src::CodeInstance cache associated with mi::MethodInstace that represents the analysis result on mi performed by analyzer::AbstractAnalyzer, where src.inferred::JETCachedResult caches JET's analysis result. This cache is separated by the identities of AbstractAnalyzers, which are hash keys computed by get_cache_key(analyzer::AbstractAnalyzer).\n\nJET_CACHE is completely separated from the NativeInterpreter's global cache, so that JET's analysis never interacts with actual code execution.\n\n\n\n\n\n","category":"constant"},{"location":"internals/#JET.JETCachedResult","page":"Internals","title":"JET.JETCachedResult","text":"JETCachedResult\n\nJETResult is transformed into JETCachedResult and then cached into codeinf::CodeInstance. When working with AbstractAnalyzer, we can expect codeinf to have its field codeinf.inferred::JETCachedResult as far as it's managed by JET_CACHE.\n\nInferenceErrorReportCaches found within already-analyzed result::InferenceResult can be accessed with get_cached_reports(analyzer, result).\n\n\n\n\n\n","category":"type"},{"location":"internals/#Core.Compiler.inlining_policy","page":"Internals","title":"Core.Compiler.inlining_policy","text":"inlining_policy(\n    analyzer::AbstractAnalyzer, @nospecialize(src), stmt_flag::UInt8,\n    mi::MethodInstance, argtypes::Argtypes) -> source::Any\n\nImplements inlining policy for AbstractAnalyzer. Since AbstractAnalyzer works on InferenceResult whose src field keeps JETResult or JETCachedResult, this implementation just forwards their wrapped source to inlining_policy(::AbstractInterpreter, ::Any, ::UInt8).\n\n\n\n\n\n","category":"function"},{"location":"internals/#toplevel","page":"Internals","title":"Top-level Analysis","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"JET.virtual_process\nJET.VirtualProcessResult\nJET.virtualize_module_context\nJET.ConcreteInterpreter\nJET.partially_interpret!","category":"page"},{"location":"internals/#JET.virtual_process","page":"Internals","title":"JET.virtual_process","text":"virtual_process(s::AbstractString,\n                filename::AbstractString,\n                analyzer::AbstractAnalyzer,\n                config::ToplevelConfig,\n                ) -> res::VirtualProcessResult\n\nSimulates Julia's toplevel execution and collects error points, and finally returns res::VirtualProcessResult\n\nres.included_files::Set{String}: files that have been analyzed\nres.defined_modules::Set{Module}: module contexts created while this top-level analysis\nres.toplevel_error_reports::Vector{ToplevelErrorReport}: toplevel errors found during the   text parsing or partial (actual) interpretation; these reports are \"critical\" and should   have precedence over inference_error_reports\nres.inference_error_reports::Vector{InferenceErrorReport}: possible error reports found   by AbstractAnalyzer\nres.toplevel_signatures: signatures of methods defined within the analyzed files\nres.actual2virtual::Pair{Module, Module}: keeps actual and virtual module\n\nThis function first parses s::AbstractString into toplevelex::Expr and then iterate the following steps on each code block (blk) of toplevelex:\n\nif blk is a :module expression, recusively enters analysis into an newly defined virtual module\nlowers blk into :thunk expression lwr (macros are also expanded in this step)\nif the context module is virtualized, replaces self-references of the original context module with virtualized one: see fix_self_references\nConcreteInterpreter partially interprets some statements in lwr that should not be abstracted away (e.g. a :method definition); see also partially_interpret!\nfinally, AbstractAnalyzer analyzes the remaining statements by abstract interpretation\n\nwarning: Warning\nIn order to process the toplevel code sequentially as Julia runtime does, virtual_process splits the entire code, and then iterate a simulation process on each code block. With this approach, we can't track the inter-code-block level dependencies, and so a partial interpretation of toplevle definitions will fail if it needs an access to global variables defined in other code blocks that are not interpreted but just abstracted. We can circumvent this issue using JET's concretization_patterns configuration, which allows us to customize JET's concretization strategy. See ToplevelConfig for more details.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JET.VirtualProcessResult","page":"Internals","title":"JET.VirtualProcessResult","text":"res::VirtualProcessResult\n\nres.included_files::Set{String}: files that have been analyzed\nres.defined_modules::Set{Module}: module contexts created while this top-level analysis\nres.toplevel_error_reports::Vector{ToplevelErrorReport}: toplevel errors found during the   text parsing or partial (actual) interpretation; these reports are \"critical\" and should   have precedence over inference_error_reports\nres.inference_error_reports::Vector{InferenceErrorReport}: possible error reports found   by AbstractAnalyzer\nres.toplevel_signatures: signatures of methods defined within the analyzed files\nres.actual2virtual::Pair{Module, Module}: keeps actual and virtual module\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.virtualize_module_context","page":"Internals","title":"JET.virtualize_module_context","text":"virtualize_module_context(actual::Module)\n\nHACK: Returns a module where the context of actual is virtualized.\n\nThe virtualization will be done by 2 steps below:\n\nloads the module context of actual into a sandbox module, and export the whole context from there\nthen uses names exported from the sandbox\n\nThis way, JET's runtime simulation in the virtual module context will be able to define a name that is already defined in actual without causing \"cannot assign a value to variable ... from module ...\" error, etc. It allows JET to virtualize the context of already-existing module other than Main.\n\nwarning: TODO\nCurrently this function relies on Base.names, and thus it can't restore the usinged names.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JET.ConcreteInterpreter","page":"Internals","title":"JET.ConcreteInterpreter","text":"ConcreteInterpreter\n\nThe trait to inject code into JuliaInterpreter's interpretation process; JET.jl overloads:\n\nJuliaInterpreter.step_expr! to add error report pass for module usage expressions and support package analysis\nJuliaInterpreter.evaluate_call_recurse! to special case include calls\nJuliaInterpreter.handle_err to wrap an error happened during interpretation into ActualErrorWrapped\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.partially_interpret!","page":"Internals","title":"JET.partially_interpret!","text":"partially_interpret!(interp::ConcreteInterpreter, mod::Module, src::CodeInfo)\n\nPartially interprets statements in src using JuliaInterpreter.jl:\n\nconcretizes \"toplevel definitions\", i.e. :method, :struct_type, :abstract_type and :primitive_type expressions and their dependencies\nconcretizes user-specified toplevel code (see ToplevelConfig)\ndirectly evaluates module usage expressions and report error of invalid module usages (TODO: enter into the loaded module and keep JET analysis)\nspecial-cases include calls so that top-level analysis recursively enters the included file\n\n\n\n\n\n","category":"function"},{"location":"internals/#How-top-level-analysis-is-bridged-to-AbstractAnalyzer","page":"Internals","title":"How top-level analysis is bridged to AbstractAnalyzer","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"JET.AbstractGlobal","category":"page"},{"location":"internals/#JET.AbstractGlobal","page":"Internals","title":"JET.AbstractGlobal","text":"mutable struct AbstractGlobal\n    t::Any     # analyzed type\n    iscd::Bool # is this abstract global variable declarared as constant or not\nend\n\nWraps a global variable whose type is analyzed by abtract interpretation. AbstractGlobal object will be actually evaluated into the context module, and a later analysis may refer to or alter its type on future load and store operations.\n\nnote: Note\nThe type of the wrapped global variable will be propagated only when in a toplevel frame, and thus we don't care about the analysis cache invalidation on a refinement of the wrapped global variable, since JET doesn't cache the toplevel frame.\n\n\n\n\n\n","category":"type"},{"location":"internals/#analysis-result","page":"Internals","title":"Analysis Result","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"JET.JETToplevelResult\nJET.JETCallResult","category":"page"},{"location":"internals/#JET.JETToplevelResult","page":"Internals","title":"JET.JETToplevelResult","text":"res::JETToplevelResult\n\nRepresents the result of JET's analysis on a top-level script.\n\nres.analyzer::AbstractAnalyzer: AbstractAnalyzer used for this analysis\nres.res::VirtualProcessResult: VirtualProcessResult collected from this analysis\nres.source::String: the identity key of this analysis\nres.jetconfigs: JET configurations used for this analysis\n\nJETToplevelResult implements show methods for each different frontend. An appropriate show method will be automatically choosen and render the analysis result.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.JETCallResult","page":"Internals","title":"JET.JETCallResult","text":"res::JETCallResult\n\nRepresents the result of JET's analysis on a function call.\n\nres.result::InferenceResult: the result of this analysis\nres.analyzer::AbstractAnalyzer: AbstractAnalyzer used for this analysis\nres.source::String: the identity key of this analysis\nres.jetconfigs: JET configurations used for this analysis\n\nJETCallResult implements show methods for each different frontend. An appropriate show method will be automatically choosen and render the analysis result.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Error-Report-Interface","page":"Internals","title":"Error Report Interface","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"JET.VirtualFrame\nJET.VirtualStackTrace\nJET.Signature\nJET.InferenceErrorReport\nJET.ToplevelErrorReport","category":"page"},{"location":"internals/#JET.VirtualFrame","page":"Internals","title":"JET.VirtualFrame","text":"VirtualFrame\n\nStack information representing virtual execution context:\n\nfile::Symbol: the path to the file containing the virtual execution context\nline::Int: the line number in the file containing the virtual execution context\nsig::Signature: a signature of this frame\nlinfo::MethodInstance: The MethodInstance containing the execution context\n\nThis type is very similar to Base.StackTraces.StackFrame, but its execution context is collected during abstract interpration, not collected from actual execution.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.VirtualStackTrace","page":"Internals","title":"JET.VirtualStackTrace","text":"VirtualStackTrace\n\nRepresents a virtual stack trace in the form of a vector of VirtualFrame. The vector holds VirtualFrames in order of \"from entry call site to error point\", i.e. the first element is the VirtualFrame of the entry call site, and the last element is that contains the error.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.Signature","page":"Internals","title":"JET.Signature","text":"Signature\n\nRepresents an expression signature. print_signature implements a frontend functionality to show this type.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.ToplevelErrorReport","page":"Internals","title":"JET.ToplevelErrorReport","text":"ToplevelErrorReport\n\nAn interface type of error reports that JET collects while top-level concrete interpration. All ToplevelErrorReport should have the following fields:\n\nfile::String: the path to the file containing the interpretation context\nline::Int: the line number in the file containing the interpretation context\n\nSee also: virtual_process, ConcreteInterpreter\n\n\n\n\n\n","category":"type"},{"location":"internals/#Utilities","page":"Internals","title":"Utilities","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"JET.@invoke\nJET.@withmixedhash\nJET.@jetconfigurable","category":"page"},{"location":"internals/#JET.@invoke","page":"Internals","title":"JET.@invoke","text":"@invoke f(arg::T, ...; kwargs...)\n\nProvides a convenient way to call invoke; @invoke f(arg1::T1, arg2::T2; kwargs...) will be expanded into invoke(f, Tuple{T1,T2}, arg1, arg2; kwargs...). When an argument's type annotation is omitted, it's specified as Any argument, e.g. @invoke f(arg1::T, arg2) will be expanded into invoke(f, Tuple{T,Any}, arg1, arg2).\n\nThis could be used to call down to NativeInterpreter's abstract interpretation method of f while passing AbstractAnalyzer so that subsequent calls of abstract interpretation functions overloaded against AbstractAnalyzer can be called from the native method of f. E.g. @invoke can be used to call down to NativeInterpreter's abstract_call_gf_by_type:\n\n@invoke abstract_call_gf_by_type(analyzer::AbstractInterpreter, f, argtypes::Argtypes, atype, sv::InferenceState,\n                                 max_methods::Int)\n\n\n\n\n\n","category":"macro"},{"location":"internals/#JET.@withmixedhash","page":"Internals","title":"JET.@withmixedhash","text":"@withmixedhash (mutable) struct T\n    fields ...\nend\n\nDefines struct T while automatically defining its Base.hash(::T, ::UInt) method which mixes hashes of all of T's fields (and also corresponding Base.:(==)(::T, ::T) method).\n\nThis macro is supposed to abstract the following kind of pattern:\n\nhttps://github.com/aviatesk/julia/blob/999973df2850d6b2e0bd4bcf03ef90a14217b63c/base/pkgid.jl#L3-L25\n\nstruct PkgId\n    uuid::Union{UUID,Nothing}\n    name::String\nend\n\n==(a::PkgId, b::PkgId) = a.uuid == b.uuid && a.name == b.name\n\nfunction hash(pkg::PkgId, h::UInt)\n    h += 0xc9f248583a0ca36c % UInt\n    h = hash(pkg.uuid, h)\n    h = hash(pkg.name, h)\n    return h\nend\n\nwith @withmixedhash\n\n@withmixedhash struct PkgId\n    uuid::Union{UUID,Nothing}\n    name::String\nend\n\n\n\n\n\n","category":"macro"},{"location":"internals/#JET.@jetconfigurable","page":"Internals","title":"JET.@jetconfigurable","text":"@jetconfigurable function config_func(args...; configurations...)\n    ...\nend\n\nThis macro asserts that there's no configuration naming conflict across the @jetconfigurable functions so that a configuration for a @jetconfigurable function  doesn't affect the other @jetconfigurable functions. This macro also adds a dummy splat keyword arguments (jetconfigs...) to the function definition so that any configuration of other @jetconfigurable functions can be passed on to it.\n\n\n\n\n\n","category":"macro"},{"location":"config/#JET-configurations","page":"Configurations","title":"Configurations","text":"","category":"section"},{"location":"config/","page":"Configurations","title":"Configurations","text":"JET analysis can be flexibly fine-tuned. Any entry point explained in JET's default error analysis and the optimization analysis can accept any of the configuration parameters described below as keyword arguments (or optional parameters for the interactive macros). For example, if you want to analyze path/to/file.jl with specifying target_defined_modules configuration and also logs inference process into stdout, you can do:","category":"page"},{"location":"config/","page":"Configurations","title":"Configurations","text":"report_file(\"path/to/file.jl\";\n            target_defined_modules = true,\n            inference_logger = stdout)","category":"page"},{"location":"config/","page":"Configurations","title":"Configurations","text":"note: Note\nPlease ignore the names of documented objects appearing below, like \"JET._get_configured_reports\". They are just remnants of documentation internals, and you will never directly interact with them.","category":"page"},{"location":"config/#result-config","page":"Configurations","title":"Configurations for Analysis Result","text":"","category":"section"},{"location":"config/","page":"Configurations","title":"Configurations","text":"JET._get_configured_reports","category":"page"},{"location":"config/#JET._get_configured_reports","page":"Configurations","title":"JET._get_configured_reports","text":"Configurations for JET's analysis results. These configurations should be active always.\n\n\n\ntarget_modules = nothing \nFilters out collected reports based on their module context. By default (target_modules = nothing), JET prints any collected reports. If specified target_modules should be an iterator of Modules, and then JET will ignore whose error point is not in the specified module context.\nExamples:\njulia> function foo(a)\n           r1 = sum(a)       # => Base: MethodError(+(::Char, ::Char)), MethodError(zero(::Type{Any}))\n           r2 = undefsum(a)  # => @__MODULE__: UndefVarError(:undefsum)\n           return r1, r2\n       end;\n\n# by default, JET will print all the collected reports:\njulia> @report_call foo(\"juila\")\n════ 3 possible errors found ═════\n┌ @ none:2 r1 = Main.sum(a)\n│┌ @ reduce.jl:544 Base.#sum#258(Base.pairs(Core.NamedTuple()), #self#, a)\n││┌ @ reduce.jl:544 Base.sum(Base.identity, a)\n│││┌ @ reduce.jl:515 Base.#sum#257(Base.pairs(Core.NamedTuple()), #self#, f, a)\n││││┌ @ reduce.jl:515 Base.mapreduce(f, Base.add_sum, a)\n│││││┌ @ reduce.jl:289 Base.#mapreduce#254(Base.pairs(Core.NamedTuple()), #self#, f, op, itr)\n││││││┌ @ reduce.jl:289 Base.mapfoldl(f, op, itr)\n│││││││┌ @ reduce.jl:162 Base.#mapfoldl#250(Base._InitialValue(), #self#, f, op, itr)\n││││││││┌ @ reduce.jl:162 Base.mapfoldl_impl(f, op, init, itr)\n│││││││││┌ @ reduce.jl:44 Base.foldl_impl(op′, nt, itr′)\n││││││││││┌ @ reduce.jl:48 v = Base._foldl_impl(op, nt, itr)\n│││││││││││┌ @ reduce.jl:62 v = op(v, Base.getindex(y, 1))\n││││││││││││┌ @ reduce.jl:81 Base.getproperty(op, :rf)(acc, x)\n│││││││││││││┌ @ reduce.jl:24 Base.+(x, y)\n││││││││││││││ no matching method found for call signature (Tuple{typeof(+), Char, Char}): Base.+(x::Char, y::Char)\n│││││││││││││└────────────────\n││││││││││┌ @ reduce.jl:49 Base.reduce_empty_iter(op, itr)\n│││││││││││┌ @ reduce.jl:365 Base.reduce_empty_iter(op, itr, Base.IteratorEltype(itr))\n││││││││││││┌ @ reduce.jl:366 Base.reduce_empty(op, Base.eltype(itr))\n│││││││││││││┌ @ reduce.jl:342 Base.reduce_empty(Base.getproperty(op, :rf), _)\n││││││││││││││┌ @ reduce.jl:334 Base.reduce_empty(Base.+, _)\n│││││││││││││││┌ @ reduce.jl:325 Base.zero(_)\n││││││││││││││││ no matching method found for call signature (Tuple{typeof(zero), Type{Char}}): Base.zero(_::Type{Char})\n│││││││││││││││└─────────────────\n┌ @ none:3 r2 = Main.undefsum(a)\n│ variable Main.undefsum is not defined: r2 = Main.undefsum(a::String)\n└──────────\n\n# with `target_modules=(@__MODULE__,)`, JET will ignore the errors detected within the `Base` module:\njulia> @report_call target_modules=(@__MODULE__,) foo(\"juila\")\n════ 1 possible error found ═════\n┌ @ none:3 r2 = Main.undefsum(a)\n│ variable Main.undefsum is not defined: r2 = Main.undefsum(a::String)\n└──────────\n\n\n\n\n\n\n\n","category":"function"},{"location":"config/#toplevel-config","page":"Configurations","title":"Configurations for Top-level Analysis","text":"","category":"section"},{"location":"config/","page":"Configurations","title":"Configurations","text":"JET.ToplevelConfig","category":"page"},{"location":"config/#JET.ToplevelConfig","page":"Configurations","title":"JET.ToplevelConfig","text":"Configurations for top-level analysis. These configurations will be active for all the top-level entries explained in the top-level analysis entry points section.\n\n\n\ncontext::Bool = Main \nThe module context in which the top-level execution will be simulated.\nThis configuration can be useful when you just want to analyze a submodule, without starting entire analysis from the root module. For example, we can analyze Base.Math like below:\njulia> report_file(JET.fullbasepath(\"math.jl\");\n                   context = Base,                  # `Base.Math`'s root module\n                   analyze_from_definitions = true, # there're only definitions in `Base`\n                   )\nNote that this module context will be virtualized by default so that JET can repeat analysis in the same session without having \"invalid redefinition of constant ...\" error etc. In other word, JET virtualize the module context of context and make sure the original module context isn't polluted by JET.\n\n\n\ntarget_defined_modules::Bool = false \nIf true, automatically set the target_modules configuration so that JET filters out errors that are reported within modules that JET doesn't analyze directly.\n\n\n\nanalyze_from_definitions::Bool = false \nIf true, JET will start analysis using signatures of top-level definitions (e.g. method signatures), after the top-level interpretation has been done (unless no serious top-level error has happened, like errors involved within a macro expansion).\nThis can be handy when you want to analyze a package, which usually contains only definitions but not their usages (i.e. top-level callsites). With this option, JET can enter analysis just with method or type definitions, and we don't need to pass a file that uses the target package.\nwarning: Warning\nThis feature is very experimental at this point, and you may face lots of false positive errors, especially when trying to analyze a big package with lots of dependencies. If a file that contains top-level callsites (e.g. test/runtests.jl) is available, JET analysis using the file is generally preferred, since analysis entered from concrete call sites will produce more accurate results than analysis entered from (maybe not concrete-typed) method signatures.\nAlso see: report_file, report_and_watch_file\n\n\n\nconcretization_patterns::Vector{<:Any} = Expr[] \nSpecifies a customized top-level code concretization strategy.\nWhen analyzing a top-level code, JET first splits the entire code into appropriate units of code (i.e. code blocks), and then iterate a virtual top-level code execution process on each code block in order to simulate Julia's sequential top-level code execution. In virtual code execution, JET will selectively interpret \"top-level definitions\" (like a function definition) just like Julia's top-level code execution, while it tries to avoid executing any other parts of code like function calls and leaves them to succeeding static analysis by abstract interpretation.\nHowever, currently, JET doesn't track the \"inter-code-block\" level code dependencies, and so the selective interpretation of top-level definitions can fail if it needs an access to global variables defined in other code blocks that are not actually interpreted (i.e. \"concretized\") but just left for abstract interpreation (i.e. \"abstracted\").\nFor example, the issue happens when your macro accesses to a global variable during its expansion, e.g.:\ntest/fixtures/concretization_patterns.jl\n# JET doesn't conretize this by default, but just analyzes its type\nconst GLOBAL_CODE_STORE = Dict()\n\nmacro with_code_record(a)\n    GLOBAL_CODE_STORE[__source__] = a # record the code location in the global store\n    esc(a)\nend\n\n# here JET will try to actually expand `@with_code_record`,\n# but since `GLOBAL_CODE_STORE` didn't get concretized (i.e. instantiated), JET analysis will fail at this point\n@with_code_record foo(a) = identity(a)\n\nfoo(10) # top-level callsite, abstracted away\n\nTo circumvent this issue, JET offers the concretization_patterns::Vector{<:Any} configuration, which allows us to customize JET's top-level code concretization strategy. concretization_patterns specifies the patterns of code that should be concretized. To put in other word, when JET sees a code that matches any of code patterns specified by an user, JET will try to interpret and concretize the code, regardless of whether JET's code selection logic decides to concretize it or not.\nJET uses MacroTools.jl's expression pattern match, and we can specify whatever code pattern expected by MacroTools.@capture macro. For example, in order to solve the issue explained above, we can have:\nconcretization_patterns = [:(const GLOBAL_CODE_STORE = Dict())]\nThen GLOBAL_CODE_STORE will just be concretized and so any top-level error won't happen at the macro expansion.\nAlthough configuring concretization_patterns properly could be really tricky, we can effectively debug JET's top-level code concretization plan using toplevel_logger configuration with the logging level above than 1 (\"debug\") level. With the toplevel_logger configuration, we can see:\nwhich code is matched with concretization_patterns and forcibly concretized\nwhich code is selected to be concretized or not by JET's code selection logic: where t-annotated statements are concretized while f-annotated statements are abstracted and left abstract interpretation\njulia> report_file(\"test/fixtures/concretization_patterns.jl\";\n                   concretization_patterns = [:(const GLOBAL_CODE_STORE = Dict())],\n                   toplevel_logger = IOContext(stdout, :JET_LOGGER_LEVEL => 1))\n[toplevel-debug] virtualized the context of Main (took 0.003 sec)\n[toplevel-debug] entered into test/fixtures/concretization_patterns.jl\n[toplevel-debug] concretization pattern `const GLOBAL_CODE_STORE = Dict()` matched `const GLOBAL_CODE_STORE = Dict()` at test/fixtures/concretization_patterns.jl:2\n[toplevel-debug] concretization plan at test/fixtures/concretization_patterns.jl:4:\n1 f 1 ─      $(Expr(:thunk, CodeInfo(\n    @ none within `top-level scope`\n1 ─     return $(Expr(:method, Symbol(\"@with_code_record\")))\n)))\n2 t │        $(Expr(:method, Symbol(\"@with_code_record\")))\n3 t │   %3 = Core.Typeof(var\"@with_code_record\")\n4 t │   %4 = Core.svec(%3, Core.LineNumberNode, Core.Module, Core.Any)\n5 t │   %5 = Core.svec()\n6 t │   %6 = Core.svec(%4, %5, $(QuoteNode(:(#= test/fixtures/concretization_patterns.jl:4 =#))))\n7 t │        $(Expr(:method, Symbol(\"@with_code_record\"), :(%6), CodeInfo(\n    @ test/fixtures/concretization_patterns.jl:5 within `none`\n1 ─      $(Expr(:meta, :nospecialize, :(a)))\n│        Base.setindex!(GLOBAL_CODE_STORE, a, __source__)\n│   @ test/fixtures/concretization_patterns.jl:6 within `none`\n│   %3 = esc(a)\n└──      return %3\n)))\n8 f └──      return var\"@with_code_record\"\n[toplevel-debug] concretization plan at test/fixtures/concretization_patterns.jl:11:\n1 f 1 ─      $(Expr(:thunk, CodeInfo(\n    @ none within `top-level scope`\n1 ─     return $(Expr(:method, :foo))\n)))\n2 t │        $(Expr(:method, :foo))\n3 t │   %3 = Core.Typeof(foo)\n4 t │   %4 = Core.svec(%3, Core.Any)\n5 t │   %5 = Core.svec()\n6 t │   %6 = Core.svec(%4, %5, $(QuoteNode(:(#= test/fixtures/concretization_patterns.jl:11 =#))))\n7 t │        $(Expr(:method, :foo, :(%6), CodeInfo(\n    @ test/fixtures/concretization_patterns.jl:11 within `none`\n1 ─ %1 = identity(a)\n└──      return %1\n)))\n8 f └──      return foo\n[toplevel-debug] concretization plan at test/fixtures/concretization_patterns.jl:13:\n1 f 1 ─ %1 = foo(10)\n2 f └──      return %1\n[toplevel-debug]  exited from test/fixtures/concretization_patterns.jl (took 0.032 sec)\nAlso see: JET's logging configurations, virtual_process.\n\n\n\nvirtualize::Bool = true \nWhen true, JET will virtualize the given root module context.\nThis configuration is supposed to be used only for testing or debugging. See virtualize_module_context for the internal.\n\n\n\n\n\n\n\n","category":"type"},{"location":"config/#abstractinterpret-config","page":"Configurations","title":"Configurations for Abstract Interpretation","text":"","category":"section"},{"location":"config/","page":"Configurations","title":"Configurations","text":"JET.JETInferenceParams","category":"page"},{"location":"config/#JET.JETInferenceParams","page":"Configurations","title":"JET.JETInferenceParams","text":"Configurations for abstract interpretation performed by JET. These configurations will be active for all the entries.\n\nYou can configure any of the keyword parameters that Core.Compiler.InferenceParams or Core.Compiler.OptimizationParams can take, e.g. max_methods::Int = 3, union_splitting::Int = 4. Listed below are selections of those parameters that can have a potent influence on JET analysis.\n\n\n\nipo_constant_propagation::Bool = true \nEnables constant propagation in abstract interpretation. It is highly recommended that you keep this configuration true to get reasonable analysis result, because constant propagation can cut off lots of false positive errorenous code paths and thus produce more accurate and useful analysis results.\n\n\n\naggressive_constant_propagation::Bool = true \nIf true, JET will try to do constant propagation more \"aggressively\". It can lead to more accurate analysis as explained above, but also it may incur a performance cost. JET by default enables this configuration to get more accurate analysis result.\n\n\n\nunoptimize_throw_blocks::Bool = false \nTurn this on to skip analysis on code blocks that will eventually lead to a throw call. This configuration improves the analysis performance, but it's better to be turned off to get a \"proper\" analysis result, just because there may be other errors even in those \"throw blocks\".\n\n\n\n\n\n\n\n","category":"function"},{"location":"config/#print-config","page":"Configurations","title":"Print Configurations","text":"","category":"section"},{"location":"config/","page":"Configurations","title":"Configurations","text":"JET.PrintConfig","category":"page"},{"location":"config/#JET.PrintConfig","page":"Configurations","title":"JET.PrintConfig","text":"Configurations for report printing. The configurations below will be active whenever showing JET's analysis result within REPL.\n\n\n\nannotate_types::Bool = false \nWhen set to true, annotates types when printing analyzed call stack.\nExamples:\nwith annotate_types = false (default):\njulia> @report_call sum(\"julia\")\n═════ 2 possible errors found ═════\n┌ @ reduce.jl:530 Base.#sum#241(Base.pairs(Core.NamedTuple()), #self#, a)\n│┌ @ reduce.jl:530 Base.sum(Base.identity, a)\n││┌ @ reduce.jl:503 Base.#sum#240(Base.pairs(Core.NamedTuple()), #self#, f, a)\n│││┌ @ reduce.jl:503 Base.mapreduce(f, Base.add_sum, a)\n││││┌ @ reduce.jl:289 Base.#mapreduce#237(Base.pairs(Core.NamedTuple()), #self#, f, op, itr)\n│││││┌ @ reduce.jl:289 Base.mapfoldl(f, op, itr)\n││││││┌ @ reduce.jl:162 Base.#mapfoldl#233(Base._InitialValue(), #self#, f, op, itr)\n│││││││┌ @ reduce.jl:162 Base.mapfoldl_impl(f, op, init, itr)\n││││││││┌ @ reduce.jl:44 Base.foldl_impl(op′, nt, itr′)\n│││││││││┌ @ reduce.jl:48 Base._foldl_impl(op, nt, itr)\n││││││││││┌ @ reduce.jl:62 op(v, Base.getindex(y, 1))\n│││││││││││┌ @ reduce.jl:81 Base.getproperty(op, :rf)(acc, x)\n││││││││││││┌ @ reduce.jl:24 Base.+(x, y)\n│││││││││││││ no matching method found for call signature: Base.+(x::Char, y::Char)\n││││││││││││└────────────────\n│││││││││┌ @ reduce.jl:49 Base.reduce_empty_iter(op, itr)\n││││││││││┌ @ reduce.jl:356 Base.reduce_empty_iter(op, itr, Base.IteratorEltype(itr))\n│││││││││││┌ @ reduce.jl:357 Base.reduce_empty(op, Base.eltype(itr))\n││││││││││││┌ @ reduce.jl:330 Base.reduce_empty(Base.getproperty(op, :rf), _)\n│││││││││││││┌ @ reduce.jl:322 Base.reduce_empty(Base.+, _)\n││││││││││││││┌ @ reduce.jl:313 Base.zero(_)\n│││││││││││││││ no matching method found for call signature: Base.zero(_::Type{Char})\n││││││││││││││└─────────────────\nChar\nwith annotate_types = true\njulia> @report_call annotate_types = true sum(\"julia\")\n═════ 2 possible errors found ═════\n┌ @ reduce.jl:530 Base.#sum#241(Base.pairs(Core.NamedTuple()::NamedTuple{(), Tuple{}})::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, #self#::typeof(sum), a::String)\n│┌ @ reduce.jl:530 Base.sum(Base.identity, a::String)\n││┌ @ reduce.jl:503 Base.#sum#240(Base.pairs(Core.NamedTuple()::NamedTuple{(), Tuple{}})::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, #self#::typeof(sum), f::typeof(identity), a::String)\n│││┌ @ reduce.jl:503 Base.mapreduce(f::typeof(identity), Base.add_sum, a::String)\n││││┌ @ reduce.jl:289 Base.#mapreduce#237(Base.pairs(Core.NamedTuple()::NamedTuple{(), Tuple{}})::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, #self#::typeof(mapreduce), f::typeof(identity), op::typeof(Base.add_sum), itr::String)\n│││││┌ @ reduce.jl:289 Base.mapfoldl(f::typeof(identity), op::typeof(Base.add_sum), itr::String)\n││││││┌ @ reduce.jl:162 Base.#mapfoldl#233(Base._InitialValue()::Base._InitialValue, #self#::typeof(mapfoldl), f::typeof(identity), op::typeof(Base.add_sum), itr::String)\n│││││││┌ @ reduce.jl:162 Base.mapfoldl_impl(f::typeof(identity), op::typeof(Base.add_sum), init::Base._InitialValue, itr::String)\n││││││││┌ @ reduce.jl:44 Base.foldl_impl(op′::Base.BottomRF{typeof(Base.add_sum)}, nt::Base._InitialValue, itr′::String)\n│││││││││┌ @ reduce.jl:49 Base.reduce_empty_iter(op::Base.BottomRF{typeof(Base.add_sum)}, itr::String)\n││││││││││┌ @ reduce.jl:356 Base.reduce_empty_iter(op::Base.BottomRF{typeof(Base.add_sum)}, itr::String, Base.IteratorEltype(itr::String)::Base.HasEltype)\n│││││││││││┌ @ reduce.jl:357 Base.reduce_empty(op::Base.BottomRF{typeof(Base.add_sum)}, Base.eltype(itr::String)::Type{Char})\n││││││││││││┌ @ reduce.jl:330 Base.reduce_empty(Base.getproperty(op::Base.BottomRF{typeof(Base.add_sum)}, :rf::Symbol)::typeof(Base.add_sum), _::Type{Char})\n│││││││││││││┌ @ reduce.jl:322 Base.reduce_empty(Base.+, _::Type{Char})\n││││││││││││││┌ @ reduce.jl:313 Base.zero(_::Type{Char})\n│││││││││││││││ no matching method found for call signature: Base.zero(_::Type{Char})\n││││││││││││││└─────────────────\n│││││││││┌ @ reduce.jl:48 Base._foldl_impl(op::Base.BottomRF{typeof(Base.add_sum)}, nt::Base._InitialValue, itr::String)\n││││││││││┌ @ reduce.jl:62 op::Base.BottomRF{typeof(Base.add_sum)}(v::Char, Base.getindex(y::Tuple{Char, Int64}, 1)::Char)\n│││││││││││┌ @ reduce.jl:81 Base.getproperty(op::Base.BottomRF{typeof(Base.add_sum)}, :rf::Symbol)::typeof(Base.add_sum)(acc::Char, x::Char)\n││││││││││││┌ @ reduce.jl:24 Base.+(x::Char, y::Char)\n│││││││││││││ no matching method found for call signature: Base.+(x::Char, y::Char)\n││││││││││││└────────────────\nChar\nnote: Note\nJET always annotates types when printing the error point, e.g. in the example above, the error points below are always type-annotated regardless of this configuration:no matching method found for call signature: Base.zero(_::Type{Char})\nno matching method found for call signature: Base.+(x::Char, y::Char)\n\n\n\nfullpath::Bool = false \nControls whether or not expand a file path to full path when printing analyzed call stack. Note that paths of Julia's Base files will also be expanded when set to true.\n\n\n\nprint_toplevel_success::Bool = false \nIf true, prints a message when there is no toplevel errors found.\n\n\n\nprint_inference_success::Bool = true \nIf true, print a message when there is no errors found in abstract interpretation based analysis pass.\n\n\n\n\n\n\n\n","category":"type"},{"location":"config/#vscode-config","page":"Configurations","title":"Configurations for VSCode Integration","text":"","category":"section"},{"location":"config/","page":"Configurations","title":"Configurations","text":"JET.VSCode.VSCodeConfig","category":"page"},{"location":"config/#JET.VSCode.VSCodeConfig","page":"Configurations","title":"JET.VSCode.VSCodeConfig","text":"Configurations for the VSCode integration. These configurations are active only when used in the integrated Julia REPL.\n\n\n\nvscode_console_output::Union{Nothing,IO} = stdout \nJET will show analysis result in VSCode's \"PROBLEMS\" pane and inline annotations. If vscode_console_output::IO is specified, JET will also print the result into the specified output stream in addition to showing the result in the integrated views. When nothing, the result will be only shown in the integrated views.\n\n\n\n\n\n\n\n","category":"type"},{"location":"config/#watch-config","page":"Configurations","title":"Watch Configurations","text":"","category":"section"},{"location":"config/","page":"Configurations","title":"Configurations","text":"JET.WatchConfig","category":"page"},{"location":"config/#JET.WatchConfig","page":"Configurations","title":"JET.WatchConfig","text":"Configurations for \"watch\" mode. The configurations will only be active when used with report_and_watch_file.\n\n\n\nrevise_all::Bool = true \nRedirected to Revise.entr's all keyword argument. When set to true, JET will retrigger analysis as soon as code updates are detected in any module tracked by Revise. Currently when encountering import/using statements, JET won't perform analysis, but rather will just load the modules as usual execution (this also means Revise will track those modules). So if you're editing both files analyzed by JET and modules that are used within the files, this configuration should be enabled.\n\n\n\nrevise_modules = nothing \nRedirected to Revise.entr's modules positional argument. If a iterator of Module is given, JET will retrigger analysis whenever code in modules updates.\ntip: Tip\nThis configuration is useful when your're also editing files that are not tracked by Revise, e.g. editing functions defined in Base:# re-performe analysis when you make a change to `Base`\njulia> report_and_watch_file(yourfile; revise_modules = [Base])\n\n\n\n\n\n\n\n","category":"type"},{"location":"config/#logging-config","page":"Configurations","title":"Logging Configurations","text":"","category":"section"},{"location":"config/","page":"Configurations","title":"Configurations","text":"JET.JETLogger","category":"page"},{"location":"config/#JET.JETLogger","page":"Configurations","title":"JET.JETLogger","text":"Logging configurations for JET analysis.\n\n\n\ntoplevel_logger::Union{Nothing,IO} = nothing \nIf IO object is given, it will track JET's toplevel analysis. Logging level can be specified with :JET_LOGGER_LEVEL IO property. Currently supported logging levels are either of 0 (\"info\" level, default), 1 (\"debug\" level).\nExamples:\nlogs into stdout\njulia> report_file(filename; toplevel_logger = stdout)\nlogs into io::IOBuffer with \"debug\" logger level\njulia> report_file(filename; toplevel_logger = IOContext(io, :JET_LOGGER_LEVEL => 1));\n\n\n\ninference_logger::Union{Nothing,IO} = nothing \nIf IO object is given, it will track JET's abstract interpretation routine. Logging level can be specified with :JET_LOGGER_LEVEL IO property. Currently supported logging levels are either of 0 (\"info\" level, default), 1 (\"debug\" level).\nExamples:\nlogs into stdout\njulia> report_call(f, args...; inference_logger = stdout)\nlogs into io::IOBuffer with \"debug\" logger level\njulia> report_call(f, args...; inference_logger = IOContext(io, :JET_LOGGER_LEVEL => 1))\n\n\n\ntip: Tip\nOf course you can specify both toplevel_logger and inference_logger at the same time like below:julia> report_and_watch_file(filename;\n                             toplevel_logger = IOContext(logger_io, :JET_LOGGER_LEVEL => 1),\n                             inference_logger = inference_io)\n\n\n\n\n\n","category":"type"},{"location":"config/#config-file","page":"Configurations","title":"Configuration File","text":"","category":"section"},{"location":"config/","page":"Configurations","title":"Configurations","text":"JET.parse_config_file","category":"page"},{"location":"config/#JET.parse_config_file","page":"Configurations","title":"JET.parse_config_file","text":"JET.jl offers .prettierrc style configuration file support. This means you can use .JET.toml configuration file to specify any of configurations explained above and share that with others.\n\nWhen report_file or report_and_watch_file is called, it will look for .JET.toml in the directory of the given file, and search up the file tree until a JET configuration file is (or isn't) found. When found, the configurations specified in the file will be applied.\n\nA configuration file can specify any of JET configurations like:\n\naggressive_constant_propagation = false # turn off aggressive constant propagation\n... # other configurations\n\nNote that the following configurations should be string(s) of valid Julia code:\n\ncontext: string of Julia code, which can be parsed and evaluated into Module\nconcretization_patterns: vector of string of Julia code, which can be parsed into a Julia expression pattern expected by MacroTools.@capture macro.\ntoplevel_logger: string of Julia code, which can be parsed and evaluated into Union{IO,Nothing}\ninference_logger: string of Julia code, which can be parsed and evaluated into Union{IO,Nothing}\n\nE.g. the configurations below are equivalent:\n\nconfigurations via keyword arguments\nreport_file(somefile;\n            concretization_patterns = [:(const GLOBAL_CODE_STORE = x_)],\n            toplevel_logger = IOContext(open(\"toplevel.txt\", \"w\"), :JET_LOGGER_LEVEL => 1))\nconfigurations via a configuration file\n# supposed to concretize `const GLOBAL_CODE_STORE = Dict()` in test/fixtures/concretization_patterns.jl\nconcretization_patterns = [\"const GLOBAL_CODE_STORE = Dict()\"]\n\n# logs toplevel analysis into toplevel.txt with debug logging level\ntoplevel_logger = \"\"\"IOContext(open(\"toplevel.txt\", \"w\"), :JET_LOGGER_LEVEL => 1)\"\"\"\n\n\nnote: Note\nJET configurations specified as keyword arguments have precedence over those specified via a configuration file.\n\n\n\n\n\n","category":"function"}]
}
