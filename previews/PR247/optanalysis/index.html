<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimization Analysis · JET.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">JET.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">README</a></li><li><a class="tocitem" href="../usages/">Usages</a></li><li><a class="tocitem" href="../config/">Configurations</a></li><li class="is-active"><a class="tocitem" href>Optimization Analysis</a><ul class="internal"><li><a class="tocitem" href="#optanalysis-quick-start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#optanalysis-entry"><span>Entry Points</span></a></li><li><a class="tocitem" href="#optanalysis-config"><span>Configurations</span></a></li></ul></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><span class="tocitem">JET Analyzer Framework</span><ul><li><a class="tocitem" href="../generated-plugin-api/">API</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../generated-plugin-examples/dispatch_analysis/">Dispatch Analysis</a></li><li><a class="tocitem" href="../generated-plugin-examples/find_unstable_api/">&quot;Unstable API&quot; Analysis</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Optimization Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimization Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aviatesk/JET.jl/blob/master/docs/src/optanalysis.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="optanalysis"><a class="docs-heading-anchor" href="#optanalysis">Optimization Analysis</a><a id="optanalysis-1"></a><a class="docs-heading-anchor-permalink" href="#optanalysis" title="Permalink"></a></h1><p>Successful type inference and optimization is key to high-performing Julia programs. But as mentioned in <a href="https://docs.julialang.org/en/v1/manual/performance-tips/">the performance tips</a>, there are some chances where Julia can not infer the types of your program very well and can not optimize it well accordingly.</p><p>While there are many possibilities of &quot;type-instabilities&quot;, like usage of non-constant global variable most notably, probably the most tricky one would be <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-captured">&quot;captured variable&quot;</a> – Julia can not really well infer the type of variable that is observed and modified by both inner function and enclosing one. And such type instabilities can lead to various optimization failures. One of the most common barrier to the performance is known as &quot;runtime dispatch&quot;, which happens when a matching method can&#39;t be resolved by the compiler due to the lack of type information and it is looked up at runtime instead. Since runtime dispatch is caused by poor type information, it often indicates the compiler could not do other optimizations including inlining and scalar replacements of aggregates.</p><p>In order to avoid such problems, we usually insect output of <a href="https://docs.julialang.org/en/v1/base/base/#Base.code_typed"><code>code_typed</code></a> or its family, and check if there is anywhere type is not well inferred and optimization was not successful. But the problem is that one needs to have enough knowledge about the inference and optimization in order to interpret the output. Another problem is that they can only present the &quot;final&quot; output of the inference and optimization, and we can not inspect the entire call graph and may miss to find where a problem actually happened and how the type-instability has been propagated. There is a nice package called <a href="https://github.com/JuliaDebug/Cthulhu.jl">Cthulhu.jl</a>, which allows us to look at the outputs of <code>code_typed</code> by <em>descending</em> into a call tree, recursively and interactively. The workflow with Cthulhu is much more efficient and powerful, but still, it requires much familiarity with Julia compiler and it tends to be tedious.</p><p>So, why not automate it ? JET implements such an analyzer that investigates optimized representation of your program and <em>automatically</em> detects anywhere the compiler failed in optimization. Especially, it can find where Julia creates captured variables, where runtime dispatch will happen, and where Julia gives up the optimization work due to unresolvable recursive function call.</p><h2 id="optanalysis-quick-start"><a class="docs-heading-anchor" href="#optanalysis-quick-start">Quick Start</a><a id="optanalysis-quick-start-1"></a><a class="docs-heading-anchor-permalink" href="#optanalysis-quick-start" title="Permalink"></a></h2><p>JET exports <a href="#JET.@report_opt"><code>@report_opt</code></a>, which analyzes the entire call graph of a given generic function call, and then reports detected performance pitfalls:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JET</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>As a first example, let&#39;s see how we can find and fix runtime dispatches using JET:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; n = rand(Int); # non-constant global variable</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; make_vals(n) = n ≥ 0 ? (zero(n):n) : (n:zero(n));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function sumup(f)
           # this function uses the non-constant global variable `n` here
           # and it makes every succeeding operations type-unstable
           vals = make_vals(n)
           s = zero(eltype(vals))
           for v in vals
               s += f(v)
           end
           return s
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_opt sumup(sin) # runtime dispatches will be reported</code><code class="nohighlight hljs ansi" style="display:block;">═════ 7 possible errors found ═════
┌ @ REPL[3]:4 Main.make_vals(%1)
│ runtime dispatch detected: Main.make_vals(%1::Any)
└─────────────
┌ @ REPL[3]:5 Main.eltype(%2)
│ runtime dispatch detected: Main.eltype(%2::Any)
└─────────────
┌ @ REPL[3]:5 Main.zero(%3)
│ runtime dispatch detected: Main.zero(%3::Any)
└─────────────
┌ @ REPL[3]:6 Base.iterate(%2)
│ runtime dispatch detected: Base.iterate(%2::Any)
└─────────────
┌ @ REPL[3]:7 f(%11)
│ runtime dispatch detected: f::typeof(sin)(%11::Any)
└─────────────
┌ @ REPL[3]:7 Main.+(%10, %13)
│ runtime dispatch detected: Main.+(%10::Any, %13::Any)
└─────────────
┌ @ REPL[3]:8 Base.iterate(%2, %12)
│ runtime dispatch detected: Base.iterate(%2::Any, %12::Any)
└─────────────</code></pre><p>JET&#39;s analysis result will be dynamically updated when we update fucntion definition<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>, and we can &quot;hot-fix&quot; the runtime dispatches within the same running Julia session like this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # we can pass parameters as a function argument instead, and then everything will be type-stable
       function sumup(f, n)
           vals = make_vals(n)
           s = zero(eltype(vals))
           for v in vals
               # NOTE here we may get union type like `s::Union{Int,Float64}`,
               # but Julia can optimize away such small unions (thus no runtime dispatch)
               s += f(v)
           end
           return s
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_opt sumup(sin, rand(Int)) # now runtime dispatch free !</code><code class="nohighlight hljs ansi" style="display:block;">No errors !</code></pre><p><code>@report_opt</code> can also report existence of captured variables, which are really better to be eliminated within performance-sensitive context:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # the examples below are all adapted from https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-captured
       function abmult(r::Int)
           if r &lt; 0
               r = -r
           end
           # the closure assigned to `f` make the variable `r` captured
           f = x -&gt; x * r
           return f
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_opt abmult(42)</code><code class="nohighlight hljs ansi" style="display:block;">═════ 3 possible errors found ═════
┌ @ REPL[1]:2 r = Core.Box(:(_7::Int64))
│ captured variable `r` detected
└─────────────
┌ @ REPL[1]:2 Main.&lt;(%7, 0)
│ runtime dispatch detected: Main.&lt;(%7::Any, 0)
└─────────────
┌ @ REPL[1]:3 Main.-(%14)
│ runtime dispatch detected: Main.-(%14::Any)
└─────────────</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function abmult(r0::Int)
           # we can improve the type stability of the variable `r` like this,
           # but it is still captured
           r::Int = r0
           if r &lt; 0
               r = -r
           end
           f = x -&gt; x * r
           return f
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_opt abmult(42)</code><code class="nohighlight hljs ansi" style="display:block;">═════ 1 possible error found ═════
┌ @ REPL[3]:4 r = Core.Box()
│ captured variable `r` detected
└─────────────</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function abmult(r::Int)
           if r &lt; 0
               r = -r
           end
           # we can try to eliminate the capturing
           # and now this function would be most high-performing
           f = let r = r
               x -&gt; x * r
           end
           return f
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_opt abmult(42)</code><code class="nohighlight hljs ansi" style="display:block;">No errors !</code></pre><p>With the <a href="#optanalysis-config"><code>frame_filter</code></a> configuration, we can easily limit the scope of analysis to specific module context:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # problem: when ∑1/n exceeds `x` ?
       function compute(x)
           r = 1
           s = 0.0
           n = 1
           @time while r &lt; x
               s += 1/n
               if s ≥ r
                   # `println` call is full of runtime dispatches for good reasons
                   # and we&#39;re not interested in type-instabilities within this call
                   # since we know it&#39;s only called few times
                   println(&quot;round $r/$x has been finished&quot;)
                   r += 1
               end
               n += 1
           end
           return n, s
       end</code><code class="nohighlight hljs ansi" style="display:block;">compute (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_opt compute(30) # bunch of reports will be reported from the `println` call</code><code class="nohighlight hljs ansi" style="display:block;">═════ 23 possible errors found ═════
┌ @ REPL[1]:11 Main.println(Base.string(&quot;round &quot;, r, &quot;/&quot;, x, &quot; has been finished&quot;))
│┌ @ coreio.jl:4 Base.println(Core.tuple(Core.typeassert(Base.stdout, Base.IO)), xs...)
││┌ @ strings/io.jl:73 Base.print(Core.tuple(io), xs, Core.tuple(&quot;\n&quot;)...)
│││┌ @ strings/io.jl:43 Base.lock(io)
││││┌ @ stream.jl:283 Base.lock(Base.getproperty(s, :lock))
│││││┌ @ lock.jl:100 Base.wait(Base.getproperty(rl, :cond_wait))
││││││┌ @ condition.jl:112  = Base.wait()
│││││││┌ @ task.jl:824 result = Base.try_yieldto(Base.ensure_rescheduled)
││││││││┌ @ task.jl:761 Base.getproperty(%7, :result)
│││││││││ runtime dispatch detected: Base.getproperty(%7::Task, :result::Symbol)
││││││││└───────────────
││││││││┌ @ task.jl:762 Base.setproperty!(%7, :result, Base.nothing)
│││││││││ runtime dispatch detected: Base.setproperty!(%7::Task, :result::Symbol, Base.nothing)
││││││││└───────────────
││││││││┌ @ task.jl:763 Base.setproperty!(%7, :_isexception, false)
│││││││││ runtime dispatch detected: Base.setproperty!(%7::Task, :_isexception::Symbol, false)
││││││││└───────────────
││││││┌ @ condition.jl:114 Base.list_deletefirst!(Base.getproperty(ct, :queue), ct)
│││││││┌ @ linked_list.jl:145 Base.isequal(Base.getproperty(h, :value), val)
││││││││┌ @ gcutils.jl:4 Base.isequal(%1, v)
│││││││││ runtime dispatch detected: Base.isequal(%1::Any, v::Task)
││││││││└────────────────
││││││┌ @ condition.jl:114 Base.list_deletefirst!(%56, %50)
│││││││ runtime dispatch detected: Base.list_deletefirst!(%56::Any, %50::Task)
││││││└────────────────────
│││┌ @ strings/io.jl:49 Base.unlock(io)
││││┌ @ show.jl:335 Base.unlock(Base.getproperty(io, :io))
│││││┌ @ stream.jl:284 Base.unlock(Base.getproperty(s, :lock))
││││││┌ @ lock.jl:132 Base.notify(Base.getproperty(rl, :cond_wait))
│││││││┌ @ condition.jl:130 #self#(c, Base.nothing)
││││││││┌ @ condition.jl:130 Base.#notify#564(true, false, #self#, c, arg)
│││││││││┌ @ condition.jl:130 Base.notify(c, arg, all, error)
││││││││││┌ @ condition.jl:136 Core.kwfunc(Base.schedule)(Core.apply_type(Core.NamedTuple, (:error,))(Core.tuple(error)), Base.schedule, t, arg)
│││││││││││┌ @ task.jl:684 Base.#schedule#585(error, _3, t, arg)
││││││││││││┌ @ task.jl:686 %10(%11, t)
│││││││││││││ runtime dispatch detected: %10::typeof(Base.list_deletefirst!)(%11::Any, t::Task)
││││││││││││└───────────────
│┌ @ coreio.jl:4 Base.println(%3, %4)
││ runtime dispatch detected: Base.println(%3::IO, %4::String)
│└───────────────
┌ @ timing.jl:214 Base.time_print(elapsedtime, Base.getproperty(diff, :allocd), Base.getproperty(diff, :total_time), Base.gc_alloc_count(diff), compile_elapsedtime, true)
│┌ @ timing.jl:120 str = Base.sprint(#866)
││┌ @ strings/io.jl:106 Base.#sprint#430(Core.tuple(Base.nothing, 0, #self#, f), args...)
│││┌ @ strings/io.jl:112 f(Core.tuple(s), args...)
││││┌ @ timing.jl:123 Base.!=(%32, 0)
│││││ runtime dispatch detected: Base.!=(%32::Any, 0)
││││└─────────────────
││││┌ @ timing.jl:125 Base.!=(%65, 0)
│││││ runtime dispatch detected: Base.!=(%65::Any, 0)
││││└─────────────────
││││┌ @ timing.jl:126 Base.prettyprint_getunits(%73, %75, 1000)
│││││ runtime dispatch detected: Base.prettyprint_getunits(%73::Any, %75::Int64, 1000)
││││└─────────────────
││││┌ @ timing.jl:127 Base.==(%80, 1)
│││││ runtime dispatch detected: Base.==(%80::Any, 1)
││││└─────────────────
││││┌ @ timing.jl:128 Base.Int(%88)
│││││ runtime dispatch detected: Base.Int(%88::Any)
││││└─────────────────
││││┌ @ timing.jl:128 Base.getindex(Base._cnt_units, %80)
│││││ runtime dispatch detected: Base.getindex(Base._cnt_units, %80::Any)
││││└─────────────────
││││┌ @ timing.jl:128 Base.==(%96, 1)
│││││ runtime dispatch detected: Base.==(%96::Any, 1)
││││└─────────────────
││││┌ @ timing.jl:128 Base.print(io, %89, %90, %101)
│││││ runtime dispatch detected: Base.print(io::IOBuffer, %89::Any, %90::Any, %101::String)
││││└─────────────────
││││┌ @ timing.jl:130 Base.Float64(%110)
│││││ runtime dispatch detected: Base.Float64(%110::Any)
││││└─────────────────
││││┌ @ timing.jl:130 %104(%111, 2)
│││││ runtime dispatch detected: %104::typeof(Base.Ryu.writefixed)(%111::Any, 2)
││││└─────────────────
││││┌ @ timing.jl:130 Base.getindex(Base._cnt_units, %80)
│││││ runtime dispatch detected: Base.getindex(Base._cnt_units, %80::Any)
││││└─────────────────
││││┌ @ timing.jl:130 Base.print(io, %112, %113, &quot; allocations: &quot;)
│││││ runtime dispatch detected: Base.print(io::IOBuffer, %112::String, %113::Any, &quot; allocations: &quot;)
││││└─────────────────
││││┌ @ timing.jl:135 Base.!=(%138, 0)
│││││ runtime dispatch detected: Base.!=(%138::Any, 0)
││││└─────────────────
││││┌ @ timing.jl:141 Base.!=(%173, 0)
│││││ runtime dispatch detected: Base.!=(%173::Any, 0)
││││└─────────────────
│┌ @ timing.jl:148 Base.print(str)
││┌ @ coreio.jl:3 Base.print(%3, %4)
│││ runtime dispatch detected: Base.print(%3::IO, %4::String)
││└───────────────
│┌ @ timing.jl:119 allocs = Core.Box(:(_11::Int64))
││ captured variable `allocs` detected
│└─────────────────</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; this_module_filter(sv) = sv.mod === @__MODULE__;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_opt frame_filter=this_module_filter compute(30) # focus on what we wrote, and no error should be reported</code><code class="nohighlight hljs ansi" style="display:block;">No errors !</code></pre><p>There is also <a href="#optanalysis-config"><code>function_filter</code></a>, which can ignore specific function call.</p><p><a href="#JET.@test_opt"><code>@test_opt</code></a> can be used to assert that a given function call is free from the performance pitfalls. It is fully integrated with <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code> standard library&#39;s unit-testing infrastructure</a>, and we can use it as like other <code>Test</code> macros e.g. <code>@test</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_opt sumup(cos)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">JET-test failed</span></span> at <span class="sgr1">REPL[1]:1</span>
  Expression: <span class="sgr90">#= REPL[1]:1 =#</span> JET.@test_call analyzer = JET.OptAnalyzer sumup(cos)
  <span class="sgr7">═════ 7 possible errors found ═════</span>
  <span class="sgr91">┌ @ REPL[3]:4 </span>Main.make_vals(%1)
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Main.make_vals(%1<span class="sgr96">::Any</span>)</span>
  <span class="sgr91">└─────────────</span>
  <span class="sgr91">┌ @ REPL[3]:5 </span>Main.eltype(%2)
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Main.eltype(%2<span class="sgr96">::Any</span>)</span>
  <span class="sgr91">└─────────────</span>
  <span class="sgr91">┌ @ REPL[3]:5 </span>Main.zero(%3)
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Main.zero(%3<span class="sgr96">::Any</span>)</span>
  <span class="sgr91">└─────────────</span>
  <span class="sgr91">┌ @ REPL[3]:6 </span>Base.iterate(%2)
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Base.iterate(%2<span class="sgr96">::Any</span>)</span>
  <span class="sgr91">└─────────────</span>
  <span class="sgr91">┌ @ REPL[3]:7 </span>f(%11)
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">f<span class="sgr96">::typeof(cos)</span>(%11<span class="sgr96">::Any</span>)</span>
  <span class="sgr91">└─────────────</span>
  <span class="sgr91">┌ @ REPL[3]:7 </span>Main.+(%10, %13)
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Main.+(%10<span class="sgr96">::Any</span>, %13<span class="sgr96">::Any</span>)</span>
  <span class="sgr91">└─────────────</span>
  <span class="sgr91">┌ @ REPL[3]:8 </span>Base.iterate(%2, %12)
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Base.iterate(%2<span class="sgr96">::Any</span>, %12<span class="sgr96">::Any</span>)</span>
  <span class="sgr91">└─────────────</span>
  
ERROR: There was an error during testing</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_opt frame_filter=this_module_filter compute(30)</code><code class="nohighlight hljs ansi" style="display:block;">Test Passed
  Expression: #= REPL[2]:1 =# JET.@test_call analyzer = JET.OptAnalyzer frame_filter = this_module_filter compute(30)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Test</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @testset &quot;check type-stabilities&quot; begin
           @test_opt sumup(cos) # should fail
       
           n = rand(Int)
           @test_opt sumup(cos, n) # should pass
       
           @test_opt frame_filter=this_module_filter compute(30) # should pass
       
           @test_opt broken=true compute(30) # should pass with the &quot;broken&quot; annotation
       end</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr37">check type-stabilities: </span><span class="sgr91"><span class="sgr1">JET-test failed</span></span> at <span class="sgr1">REPL[4]:2</span>
  Expression: <span class="sgr90">#= REPL[4]:2 =#</span> JET.@test_call analyzer = JET.OptAnalyzer sumup(cos)
  <span class="sgr7">═════ 7 possible errors found ═════</span>
  <span class="sgr91">┌ @ REPL[3]:4 </span>Main.make_vals(%1)
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Main.make_vals(%1<span class="sgr96">::Any</span>)</span>
  <span class="sgr91">└─────────────</span>
  <span class="sgr91">┌ @ REPL[3]:5 </span>Main.eltype(%2)
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Main.eltype(%2<span class="sgr96">::Any</span>)</span>
  <span class="sgr91">└─────────────</span>
  <span class="sgr91">┌ @ REPL[3]:5 </span>Main.zero(%3)
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Main.zero(%3<span class="sgr96">::Any</span>)</span>
  <span class="sgr91">└─────────────</span>
  <span class="sgr91">┌ @ REPL[3]:6 </span>Base.iterate(%2)
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Base.iterate(%2<span class="sgr96">::Any</span>)</span>
  <span class="sgr91">└─────────────</span>
  <span class="sgr91">┌ @ REPL[3]:7 </span>f(%11)
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">f<span class="sgr96">::typeof(cos)</span>(%11<span class="sgr96">::Any</span>)</span>
  <span class="sgr91">└─────────────</span>
  <span class="sgr91">┌ @ REPL[3]:7 </span>Main.+(%10, %13)
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Main.+(%10<span class="sgr96">::Any</span>, %13<span class="sgr96">::Any</span>)</span>
  <span class="sgr91">└─────────────</span>
  <span class="sgr91">┌ @ REPL[3]:8 </span>Base.iterate(%2, %12)
  <span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Base.iterate(%2<span class="sgr96">::Any</span>, %12<span class="sgr96">::Any</span>)</span>
  <span class="sgr91">└─────────────</span>
  
<span class="sgr37"><span class="sgr1">Test Summary:          | </span></span><span class="sgr1"><span class="sgr32">Pass  </span><span class="sgr91">Fail  </span><span class="sgr33">Broken  </span><span class="sgr36">Total</span></span>
check type-stabilities | <span class="sgr32">   2  </span><span class="sgr91">   1  </span><span class="sgr33">     1  </span><span class="sgr36">    4</span>
ERROR: Some tests did not pass: 2 passed, 1 failed, 0 errored, 1 broken.</code></pre><h2 id="optanalysis-entry"><a class="docs-heading-anchor" href="#optanalysis-entry">Entry Points</a><a id="optanalysis-entry-1"></a><a class="docs-heading-anchor-permalink" href="#optanalysis-entry" title="Permalink"></a></h2><p>These macros/functions are the entries of dispatch analysis:</p><article class="docstring"><header><a class="docstring-binding" id="JET.@report_opt" href="#JET.@report_opt"><code>JET.@report_opt</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@report_opt [jetconfigs...] f(args...)</code></pre><p>Evaluates the arguments to the function call, determines its types, and then calls <a href="#JET.report_opt"><code>report_opt</code></a> on the resulting expression. As with <code>@code_typed</code> and its family, any of <a href="https://aviatesk.github.io/JET.jl/dev/config/">JET configurations</a> or <a href="#optanalysis-config">optimization analysis specific configurations</a> can be given as the optional arguments like this:</p><pre><code class="language-julia-repl hljs"># reports `rand(::Type{Bool})` with `unoptimize_throw_blocks` configuration turned on
julia&gt; @report_opt unoptimize_throw_blocks=true rand(Bool)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/8210720d552d7e5032c7903ce0b5cb51e83a6498/src/analyzers/optanalyzer.jl#L297-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.report_opt" href="#JET.report_opt"><code>JET.report_opt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">report_opt(f, types = Tuple{}; jetconfigs...) -&gt; JETCallResult
report_opt(tt::Type{&lt;:Tuple}; jetconfigs...) -&gt; JETCallResult</code></pre><p>Analyzes the generic function call with the given type signature with <a href="#optanalysis">the optimization analyzer</a>, which collects optimization failures and runtime dispatches involved within the call stack.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/8210720d552d7e5032c7903ce0b5cb51e83a6498/src/analyzers/optanalyzer.jl#L281-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.@test_opt" href="#JET.@test_opt"><code>JET.@test_opt</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@test_opt [jetconfigs...] [broken=false] [skip=false] f(args...)</code></pre><p>Tests the generic function call <code>f(args...)</code> is free from runtime dispatch. Returns a <code>Pass</code> result if it is, a <code>Fail</code> result if if contains any location where runtime dispatch or optimization failure happens, or an <code>Error</code> result if this macro encounters an unexpected error. When the test <code>Fail</code>s, abstract call stack to each problem location will also be printed to <code>stdout</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; @test_opt sincos(10)
Test Passed
  Expression: #= none:1 =# JET.@test_opt sincos(10)</code></pre><p>As with <a href="#JET.@report_opt"><code>@report_opt</code></a>, any of <a href="https://aviatesk.github.io/JET.jl/dev/config/">JET configurations</a> or <a href="#optanalysis-config">optimization analysis specific configurations</a> can be given as the optional arguments like this:</p><pre><code class="language-julia-repl hljs">julia&gt; function f(n)
            r = sincos(n)
            println(r) # `println` is full of runtime dispatches, but we can ignore the corresponding reports from `Base` by explicit frame filter
            return r
       end;
julia&gt; this_module_filter(x) = x.mod === @__MODULE__;

julia&gt; @test_opt frame_filter=this_module_filter f(10)
Test Passed
  Expression: #= none:1 =# JET.@test_opt frame_filter = this_module_filter f(10)</code></pre><p><code>@test_opt</code> is fully integrated with <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code> standard library&#39;s unit-testing infrastructure</a>. It means, the result of <code>@test_opt</code> will be included in the final <code>@testset</code> summary, it supports <code>skip</code> and <code>broken</code> annotations as <code>@test</code> macro does, etc.</p><pre><code class="language-julia-repl hljs">julia&gt; using Test

julia&gt; f(params) = sin(params.value); # type-stable
julia&gt; params = (; value = 10);       # non-constant global variable
julia&gt; g() = sin(params.value);       # very type-instable

julia&gt; @testset &quot;check optimizations&quot; begin
           @test_opt f((; value = 10)) # pass
           @test_opt g()               # fail
           @test_opt broken=true g()   # annotated as broken, thus still &quot;pass&quot;
       end
check optimizations: Dispatch Test Failed at none:3
  Expression: #= none:3 =# JET.@test_opt g()
  ═════ 2 possible errors found ═════
  ┌ @ none:1 Base.getproperty(%1, :value)
  │ runtime dispatch detected: Base.getproperty(%1::Any, :value::Symbol)
  └──────────
  ┌ @ none:1 Main.sin(%2)
  │ runtime dispatch detected: Main.sin(%2::Any)
  └──────────

Test Summary:       | Pass  Fail  Broken  Total
check optimizations |    1     1       1      3
ERROR: Some tests did not pass: 1 passed, 1 failed, 0 errored, 1 broken.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/8210720d552d7e5032c7903ce0b5cb51e83a6498/src/analyzers/optanalyzer.jl#L313-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.test_opt" href="#JET.test_opt"><code>JET.test_opt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">test_opt(f, types = Tuple{}; broken::Bool = false, skip::Bool = false, jetconfigs...)
test_opt(tt::Type{&lt;:Tuple}; broken::Bool = false, skip::Bool = false, jetconfigs...)</code></pre><p>Tests the generic function call with the given type signature is free from runtime dispatch. Except that it takes a type signature rather than a call expression, this function works in the same way as <a href="#JET.@test_opt"><code>@test_opt</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/8210720d552d7e5032c7903ce0b5cb51e83a6498/src/analyzers/optanalyzer.jl#L377-L384">source</a></section></article><h2 id="optanalysis-config"><a class="docs-heading-anchor" href="#optanalysis-config">Configurations</a><a id="optanalysis-config-1"></a><a class="docs-heading-anchor-permalink" href="#optanalysis-config" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JET.OptAnalyzer" href="#JET.OptAnalyzer"><code>JET.OptAnalyzer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Every <a href="#optanalysis-entry">entry point of optimization analysis</a> can accept any of <a href="../config/#JET-configurations">JET configurations</a> as well as the following additional configurations that are specific to optimization analysis.</p><hr/><ul><li><p><code>frame_filter = x::Union{Core.Compiler.InferenceState, Core.Compiler.OptimizationState}-&gt;true</code>:<br/>A predicate which takes <code>InfernceState</code> or <code>OptimizationState</code> and returns <code>false</code> to skip analysis on the frame.</p><pre><code class="language-julia-repl hljs"># only checks code within the current module:
julia&gt; mymodule_filter(x) = x.mod === @__MODULE__;

julia&gt; @test_opt frame_filter=mymodule_filter f(args...)
...</code></pre></li></ul><hr/><ul><li><p><code>function_filter = @nospecialize(ft)-&gt;true</code>:<br/>A predicate which takes a function type and returns <code>false</code> to skip analysis on the call.</p><pre><code class="language-julia-repl hljs"># ignores `Core.Compiler.widenconst` calls (since it&#39;s designed to be runtime-dispatched):
julia&gt; myfunction_filter(@nospecialize(ft)) = ft !== typeof(Core.Compiler.widenconst)

julia&gt; @test_opt function_filter=myfunction_filter f(args...)
...</code></pre></li></ul><hr/><ul><li><p><code>skip_nonconcrete_calls::Bool = true</code>:<br/>Julia&#39;s runtime dispatch is &quot;powerful&quot; because it can always compile code with concrete runtime arguments so that <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#kernel-functions">a &quot;kernel&quot; function</a> runs very effectively even if it&#39;s called from a type-instable call site. This means, we (really) often accept that some parts of our code are not inferred statically, and rather we want to just rely on information that is only available at runtime. To model this programming style, the optimization analyzer does NOT report any optimization failures or runtime dispatches detected within non-concrete calls under the default configuration. We can turn off this <code>skip_nonconcrete_calls</code> configuration to get type-instabilities within non-concrete calls.</p><pre><code class="language-julia-repl hljs"># the following examples are adapted from https://docs.julialang.org/en/v1/manual/performance-tips/#kernel-functions
julia&gt; function fill_twos!(a)
           for i = eachindex(a)
               a[i] = 2
           end
       end;

julia&gt; function strange_twos(n)
           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)
           fill_twos!(a)
           return a
       end;

# by default, only type-instabilities within concrete call (i.e. `strange_twos(3)`) are reported
# and those within non-concrete calls (`fill_twos!(a)`) are not reported
julia&gt; @report_opt strange_twos(3)
═════ 2 possible errors found ═════
┌ @ REPL[2]:2 %45(Main.undef, n)
│ runtime dispatch detected: %45::Type{Vector{_A}} where _A(Main.undef, n::Int64)
└─────────────
┌ @ REPL[2]:3 Main.fill_twos!(%46)
│ runtime dispatch detected: Main.fill_twos!(%46::Vector)
└─────────────
Vector (alias for Array{_A, 1} where _A)

# we can get reports from non-concrete calls with `skip_nonconcrete_calls=false`
julia&gt; @report_opt skip_nonconcrete_calls=false strange_twos(3)
═════ 4 possible errors found ═════
┌ @ REPL[2]:3 Main.fill_twos!(a)
│┌ @ REPL[1]:3 Base.setindex!(a, 2, %14)
││ runtime dispatch detected: Base.setindex!(a::Vector, 2, %14::Int64)
│└─────────────
│┌ @ REPL[1]:3 Base.setindex!(a, 2, i)
││┌ @ array.jl:877 Base.convert(_, x)
│││ runtime dispatch detected: Base.convert(_::Any, x::Int64)
││└────────────────
┌ @ REPL[2]:2 %45(Main.undef, n)
│ runtime dispatch detected: %45::Type{Vector{_A}} where _A(Main.undef, n::Int64)
└─────────────
┌ @ REPL[2]:3 Main.fill_twos!(%46)
│ runtime dispatch detected: Main.fill_twos!(%46::Vector)
└─────────────
Vector (alias for Array{_A, 1} where _A)</code></pre></li></ul><hr/><ul><li><p><code>skip_unoptimized_throw_blocks::Bool = true</code>:<br/>By default, Julia&#39;s native compilation pipeline intentionally disables inference (and so succeeding optimizations too) on &quot;throw blocks&quot;, which are code blocks that will eventually lead to <code>throw</code> calls, in order to ease <a href="https://julialang.org/blog/2020/08/invalidations/">the compilation latency problem, a.k.a. &quot;first-time-to-plot&quot;</a>. Accordingly, the optimization analyzer also ignores any performance pitfalls detected within those blocks since we <em>usually</em> don&#39;t mind if code involved with error handling isn&#39;t optimized. If <code>skip_unoptimized_throw_blocks</code> is set to <code>false</code>, it doesn&#39;t ignore them and will report type instabilities detected within &quot;throw blocks&quot;.</p><p>See also <a href="https://github.com/JuliaLang/julia/pull/35982">https://github.com/JuliaLang/julia/pull/35982</a>.</p><pre><code class="language-julia-repl hljs"># by default, unoptimized &quot;throw blocks&quot; are not analyzed
julia&gt; @test_opt sin(10)
Test Passed
  Expression: #= none:1 =# JET.@test_opt sin(10)

# we can turn on the analysis on unoptimized &quot;throw blocks&quot; with `skip_unoptimized_throw_blocks=false`
julia&gt; @test_opt skip_unoptimized_throw_blocks=false sin(10)
JET-test failed at none:1
  Expression: #= REPL[6]:1 =# JET.@test_call analyzer = JET.OptAnalyzer skip_unoptimized_throw_blocks = false sin(10)
  ═════ 1 possible error found ═════
  ┌ @ math.jl:1221 Base.Math.sin(xf)
  │┌ @ special/trig.jl:39 Base.Math.sin_domain_error(x)
  ││┌ @ special/trig.jl:28 Base.Math.DomainError(x, &quot;sin(x) is only defined for finite x.&quot;)
  │││ runtime dispatch detected: Base.Math.DomainError(x::Float64, &quot;sin(x) is only defined for finite x.&quot;)
  ││└──────────────────────

ERROR: There was an error during testing

# we can also turns off the heuristic itself
julia&gt; @test_opt unoptimize_throw_blocks=false skip_unoptimized_throw_blocks=false sin(10)
Test Passed
  Expression: #= REPL[7]:1 =# JET.@test_call analyzer = JET.OptAnalyzer unoptimize_throw_blocks = false skip_unoptimized_throw_blocks = false sin(10)</code></pre></li></ul><hr/></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/8210720d552d7e5032c7903ce0b5cb51e83a6498/src/analyzers/optanalyzer.jl#L4-L127">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Technically, it&#39;s fully integrated with <a href="https://julialang.org/blog/2020/08/invalidations/">Julia&#39;s method invalidation system</a>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../config/">« Configurations</a><a class="docs-footer-nextpage" href="../internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Tuesday 7 September 2021 05:29">Tuesday 7 September 2021</span>. Using Julia version 1.8.0-DEV.477.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
