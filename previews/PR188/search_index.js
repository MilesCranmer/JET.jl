var documenterSearchIndex = {"docs":
[{"location":"usages/#Usages","page":"Usages","title":"How to Use JET.jl","text":"","category":"section"},{"location":"usages/","page":"Usages","title":"Usages","text":"note: Note\nJET's analysis entry points follow the naming conventions below:report_xxx: runs analysis, and then prints the collected error points\nanalyze_xxx: just runs analysis, and returns the final state of the analysisThe report_xxx entries are for general users, while analyze_xxx is mainly for internal usages or debugging purposes.","category":"page"},{"location":"usages/#Analysis-entry-points","page":"Usages","title":"Entry Points into Analysis","text":"","category":"section"},{"location":"usages/","page":"Usages","title":"Usages","text":"JET can analyze your \"top-level\" code. This means you can just give your Julia file or code to JET and get error reports. report_file, report_and_watch_file, report_package and report_text are the main entry points for that.","category":"page"},{"location":"usages/","page":"Usages","title":"Usages","text":"JET will analyze your code \"half-statically\" – JET will selectively interpret \"top-level definitions\" (like a function definition) and try to simulate Julia's top-level code execution, while it tries to avoid executing any other parts of code like function calls, but analyze them using abstract interpretation (this is a part where JET \"statically\" analyzes your code). If you're interested in how JET selects \"top-level definitions\", please see JET.virtual_process.","category":"page"},{"location":"usages/","page":"Usages","title":"Usages","text":"warning: Warning\nBecause JET will actually interpret \"top-level definitions\" in your code, it certainly runs your code. So we should note that JET can cause some side effects from your code; for example JET will try to expand all the macros used in your code, and so the side effects involved with macro expansions will also happen in JET's analysis process.","category":"page"},{"location":"usages/","page":"Usages","title":"Usages","text":"report_file\nreport_and_watch_file\nreport_package\nreport_text","category":"page"},{"location":"usages/#JET.report_file","page":"Usages","title":"JET.report_file","text":"report_file([io::IO = stdout],\n            filename::AbstractString;\n            jetconfigs...) -> res::ReportResult\n\nAnalyzes filename, prints the collected error reports to the io stream, and finally returns res::ReportResult\n\nres.included_files::Set{String}: files analyzed by JET\nres.any_reported::Bool: indicates if there was any error point reported\n\nThis function will look for .JET.toml configuration file in the directory of filename,   and search up the file tree until any .JET.toml is (or isn't) found. When found, the configurations specified in the file will overwrite the given jetconfigs. See Configuration File for more details.\n\ntip: Tip\nWhen you want to analyze your package, but any file using it isn't available, the   analyze_from_definitions option can be useful (see ToplevelConfig's analyze_from_definitions option). \nFor example, JET can analyze JET itself like below:# from the root directory of JET.jl\njulia> report_file(\"src/JET\";\n                   analyze_from_definitions = true)See also: report_package\n\nnote: Note\nThis function will enable the toplevel_logger configuration by default with the default logging level. You can still explicitly specify and configure it:report_file(args...;\n            toplevel_logger = nothing, # suppress toplevel logger\n            jetconfigs...) # other configurationsSee Logging Configurations for more details.\n\n\n\n\n\n","category":"function"},{"location":"usages/#JET.report_and_watch_file","page":"Usages","title":"JET.report_and_watch_file","text":"report_and_watch_file([io::IO = stdout],\n                      filename::AbstractString;\n                      jetconfigs...)\n\nWatches filename and keeps re-triggering analysis with report_file on code update. JET will try to analyze all the included files reachable from filename, and it will   re-trigger analysis if there is code update detected in any of the included files.\n\nThis function internally uses Revise.jl to   track code updates. Revise also offers possibilities to track changes in files that are   not directly analyzed by JET, or even changes in Base files. See Watch Configurations   for more details.\n\nSee also: report_file\n\n\n\n\n\n","category":"function"},{"location":"usages/#JET.report_package","page":"Usages","title":"JET.report_package","text":"report_package([io::IO = stdout],\n               package::Union{AbstractString,Module};\n               jetconfigs...) -> res::ReportResult\n\nAnalyzes package in the same way as report_file with the option analyze_from_definitions=true. See report_file for details. package can be either a module or a string. In the latter case it must be the name of a package in your current environment.\n\nreport_package([io::IO = stdout];\n               jetconfigs...) -> res::ReportResult\n\nLike above but analyzes the package in the current project.\n\nSee also: report_file\n\n\n\n\n\n","category":"function"},{"location":"usages/#JET.report_text","page":"Usages","title":"JET.report_text","text":"report_text([io::IO = stdout],\n            text::AbstractString,\n            filename::AbstractString = \"top-level\";\n            jetconfigs...) -> res::ReportResult\n\nAnalyzes text, prints the collected error reports to the io stream, and finally returns res::ReportResult\n\nres.included_files::Set{String}: files analyzed by JET\nres.any_reported::Bool: indicates if there was any error point reported\n\n\n\n\n\n","category":"function"},{"location":"usages/#Testing,-Interactive-Usage","page":"Usages","title":"Testing, Interactive Usage","text":"","category":"section"},{"location":"usages/","page":"Usages","title":"Usages","text":"There are utilities for checking JET analysis in a running Julia session like REPL or such.","category":"page"},{"location":"usages/","page":"Usages","title":"Usages","text":"report_call\n@report_call\nanalyze_call\n@analyze_call","category":"page"},{"location":"usages/#JET.report_call","page":"Usages","title":"JET.report_call","text":"report_call(f, types = Tuple{}; jetconfigs...) -> result_type::Any\n\nAnalyzes the generic function call with the given type signature, and then prints collected   error points to stdout, and finally returns the result type of the call.\n\n\n\n\n\n","category":"function"},{"location":"usages/#JET.@report_call","page":"Usages","title":"JET.@report_call","text":"@report_call [jetconfigs...] f(args...)\n\nEvaluates the arguments to the function call, determines its types, and then calls   report_call on the resulting expression. As with @code_typed and its family, any of JET configurations can be given as the optional   arguments like this:\n\n# reports `rand(::Type{Bool})` with `aggressive_constant_propagation` configuration turned off\njulia> @report_call aggressive_constant_propagation=false rand(Bool)\n\n\n\n\n\n","category":"macro"},{"location":"usages/#JET.analyze_call","page":"Usages","title":"JET.analyze_call","text":"analyze_call(f, types = Tuple{}; jetconfigs...) -> (interp::JETInterpreter, frame::InferenceFrame)\n\nAnalyzes the generic function call with the given type signature, and returns:\n\ninterp::JETInterpreter, which contains analyzed error reports and such\nframe::InferenceFrame, which is the final state of the abstract interpretation\n\n\n\n\n\n","category":"function"},{"location":"usages/#JET.@analyze_call","page":"Usages","title":"JET.@analyze_call","text":"@analyze_call [jetconfigs...] f(args...)\n\nEvaluates the arguments to the function call, determines its types, and then calls   analyze_call on the resulting expression. As with @code_typed and its family, any of JET configurations can be given as the optional   arguments like this:\n\n# analyzes `rand(::Type{Bool})` with `aggressive_constant_propagation` configuration turned off\njulia> @analyze_call aggressive_constant_propagation=false rand(Bool)\n\n\n\n\n\n","category":"macro"},{"location":"#JET.jl-–-experimental-type-checker-for-Julia,-no-need-for-additional-type-annotations","page":"README","title":"JET.jl – experimental type checker for Julia, no need for additional type annotations","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"JET","category":"page"},{"location":"#JET","page":"README","title":"JET","text":"(Image: ) (Image: CI) (Image: codecov)\n\nbehind the moar for performance ...\n\nJET.jl employs Julia's type inference for bug reports.\n\nnote: Note\nJET.jl needs Julia versions 1.6 and higher; JET is tested against the current stable release and an nightly version. \nAlso note that JET deeply relies on the type inference routine implemented in Julia's compiler, and so JET analysis result can vary depending on your Julia version. In general, the newer your Julia version is, more accurately and quickly your can expect JET to analyze your code, assuming Julia's compiler keeps evolving all the time from now on.\n\nDocumentation\n\nJET's documentation is now available at here ! Any kind of feedback or help will be very appreciated.\n\nDemo\n\nSay you have this strange and buggy file and want to know where to fix:\n\ndemo.jl\n\n# demo\n# ====\n\n# fibonacci\n# ---------\n\nfib(n) = n ≤ 2 ? n : fib(n-1) + fib(n-2)\n\nfib(1000)   # never terminates in ordinal execution\nfib(m)      # undef var\nfib(\"1000\") # obvious type error\n\n\n# language features\n# -----------------\n\n# user-defined types\nstruct Ty{T}\n    fld::T\nend\n\nfunction foo(a)\n    v = Ty(a)\n    return bar(v)\nend\n\n# macros will be expanded\n@inline bar(n::T)     where {T<:Number} = n < 0 ? zero(T) : one(T)\n@inline bar(v::Ty{T}) where {T<:Number} = bar(v.fdl) # typo \"fdl\"\n@inline bar(v::Ty)                      = bar(convert(Number, v.fld))\n\nfoo(1.2)\nfoo(\"1\") # `String` can't be converted to `Number`\n\nYou can have JET.jl detect possible errors:\n\njulia> using JET\n\njulia> report_and_watch_file(\"demo.jl\"; annotate_types = true)\n[toplevel-info] analysis entered into demo.jl\n[toplevel-info] analysis from demo.jl finished in 3.455 sec\n═════ 4 possible errors found ═════\n┌ @ demo.jl:10 fib(m)\n│ variable m is not defined: fib(m)\n└──────────────\n┌ @ demo.jl:11 fib(\"1000\")\n│┌ @ demo.jl:7 ≤(n::String, 2)\n││┌ @ operators.jl:385 Base.<(x::String, y::Int64)\n│││┌ @ operators.jl:336 Base.isless(x::String, y::Int64)\n││││ no matching method found for call signature: Base.isless(x::String, y::Int64)\n│││└────────────────────\n┌ @ demo.jl:32 foo(1.2)\n│┌ @ demo.jl:24 bar(v::Ty{Float64})\n││┌ @ demo.jl:29 Base.getproperty(v::Ty{Float64}, :fdl::Symbol)\n│││┌ @ Base.jl:33 Base.getfield(x::Ty{Float64}, f::Symbol)\n││││ type Ty{Float64} has no field fdl\n│││└──────────────\n┌ @ demo.jl:33 foo(\"1\")\n│┌ @ demo.jl:24 bar(v::Ty{String})\n││┌ @ demo.jl:30 convert(Number, Base.getproperty(v::Ty{String}, :fld::Symbol)::String)\n│││ no matching method found for call signature: convert(Number, Base.getproperty(v::Ty{String}, :fld::Symbol)::String)\n││└──────────────\n\nHooray ! JET.jl found possible error points (e.g. MethodError: no method matching isless(::String, ::Int64)) given toplevel call signatures of generic functions (e.g. fib(\"1000\")).\n\nNote that JET can find these errors while demo.jl is so inefficient (especially the fib implementation) that it would never terminate in actual execution. That is possible because JET analyzes code only on type level. This technique is often called \"abstract interpretation\" and JET internally uses Julia's native type inference implementation, so it can analyze code as fast/correctly as Julia's code generation.\n\nLastly let's apply the following diff to demo.jl so that it works nicely:\n\nfix-demo.jl.diff\n\ndiff --git a/demo.jl b/demo-fixed.jl\nindex d2b188a..1d1b3da 100644\n--- a/demo.jl\n+++ b/demo.jl\n@@ -5,11 +5,21 @@\n # fibonacci\n # ---------\n\n-fib(n) = n ≤ 2 ? n : fib(n-1) + fib(n-2)\n+# cache, cache, cache\n+function fib(n::T) where {T<:Number}\n+    cache = Dict(zero(T)=>zero(T), one(T)=>one(T))\n+    return _fib(n, cache)\n+end\n+_fib(n, cache) = if haskey(cache, n)\n+    cache[n]\n+else\n+    cache[n] = _fib(n-1, cache) + _fib(n-2, cache)\n+end\n\n-fib(1000)   # never terminates in ordinal execution\n-fib(m)      # undef var\n-fib(\"1000\") # obvious type error\n+fib(BigInt(1000)) # will terminate in ordinal execution as well\n+m = 1000          # define m\n+fib(m)\n+fib(parse(Int, \"1000\"))\n\n\n # language features\n@@ -27,8 +37,8 @@ end\n\n # macros will be expanded\n @inline bar(n::T)     where {T<:Number} = n < 0 ? zero(T) : one(T)\n-@inline bar(v::Ty{T}) where {T<:Number} = bar(v.fdl) # typo \"fdl\"\n+@inline bar(v::Ty{T}) where {T<:Number} = bar(v.fld) # typo fixed\n @inline bar(v::Ty)                      = bar(convert(Number, v.fld))\n\n foo(1.2)\n-foo(\"1\") # `String` can't be converted to `Number`\n+foo('1') # `Char` will be converted to `UInt32`\n\nIf you apply the diff (i.e. update and save the demo.jl), JET will automatically re-trigger analysis, and this time, won't complain anything:\n\ngit apply fix-demo.jl.diff\n\n[toplevel-info] entered into demo.jl\n[toplevel-info]  exited from demo.jl (took 3.423 sec)\nNo errors !\n\nRoadmap\n\neditor/IDE integration: GUI would definitely be more appropriate for showing JET's analysis result\nsmarter code dependency tracking: the watch mode currently re-analyzes the whole code on each update, which is the most robust and least efficient option. When integrated with an IDE, fancier incremental analysis based on smarter code dependency tracking like what Revise.jl does would be needed\nLSP support: ideally I hope to extend JET to provide some of LSP features other than diagnostics, e.g. auto-completions, rename refactor, taking type-level information into account\nmore documentation: especially JET needs a specification of its error reports\nmore accurate and faster analysis: abstract interpretation can be improved yet more, e.g. with alias analysis\nconfigurable strictness: there're cases where more strict check is appropriate, and vice versa\nperformance linting: JET can be used to report performance pitfalls, e.g. report a dynamic dispatch found inside a heavy loop\n\nAcknowledgement\n\nThis project started as my grad thesis project at Kyoto University, supervised by Prof. Takashi Sakuragawa. We were heavily inspired by ruby/typeprof, an experimental type understanding/checking tool for Ruby. The grad thesis about this project is published at https://github.com/aviatesk/grad-thesis, but currently it's only available in Japanese.\n\n\n\n\n\n","category":"module"},{"location":"internals/#Internals-of-JET.jl","page":"Internals","title":"Internals of JET.jl","text":"","category":"section"},{"location":"internals/#Abstract-Interpretation-Based-Analysis","page":"Internals","title":"Abstract Interpretation Based Analysis","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"JET.jl overloads functions with the Core.Compiler.AbstractInterpreter interface, and customizes its abstract interpretation routine. The overloads are done on JETInterpreter <: AbstractInterpreter so that typeinf(::JETInterpreter, ::InferenceState) will do the customized abstract interpretation and collect type errors.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Most overloads use the invoke reflection, which allows JETInterpreter to dispatch to the original AbstractInterpreter's abstract interpretation methods and still keep passing it to the subsequent (maybe overloaded) callees (see JET.@invoke macro).","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"JET.bail_out_toplevel_call\nJET.bail_out_call\nJET.add_call_backedges!\nJET.const_prop_entry_heuristic\nJET.analyze_task_parallel_code!\nJET.is_from_same_frame\nJET.AbstractGlobal\nJET.JET_REPORT_CACHE\nJET.JET_CODE_CACHE","category":"page"},{"location":"internals/#Core.Compiler.bail_out_toplevel_call","page":"Internals","title":"Core.Compiler.bail_out_toplevel_call","text":"bail_out_toplevel_call(interp::JETInterpreter, ...)\n\nAn overload for abstract_call_gf_by_type(interp::JETInterpreter, ...), which keeps   inference on non-concrete call sites in a toplevel frame created by   virtual_process.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Core.Compiler.bail_out_call","page":"Internals","title":"Core.Compiler.bail_out_call","text":"bail_out_call(interp::JETInterpreter, ...)\n\nWith this overload, abstract_call_gf_by_type(interp::JETInterpreter, ...) doesn't bail out   inference even after the current return type grows up to Any and collects as much error   points as possible. Of course this slows down inference performance, but hoopefully it stays to be \"practical\"   speed since the number of matching methods are limited beforehand.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Core.Compiler.add_call_backedges!","page":"Internals","title":"Core.Compiler.add_call_backedges!","text":"add_call_backedges!(interp::JETInterpreter, ...)\n\nAn overload for abstract_call_gf_by_type(interp::JETInterpreter, ...), which always add   backedges (even if a new method can't refine the return type grew up to Any). This is because a new method definition always has a potential to change the JET analysis result.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Core.Compiler.const_prop_entry_heuristic","page":"Internals","title":"Core.Compiler.const_prop_entry_heuristic","text":"const_prop_entry_heuristic(interp::JETInterpreter, @nospecialize(rettype), sv::InferenceState, edgecycle::Bool)\n\nAn overload for abstract_call_method_with_const_args(interp::JETInterpreter, ...), which   forces constant prop' even if the inference result can't be improved anymore, e.g. when   rettype is already Const; this is because constant prop' can still produce more accurate   analysis by throwing away false positive error reports by cutting off the unreachable   control flow.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JET.analyze_task_parallel_code!","page":"Internals","title":"JET.analyze_task_parallel_code!","text":"analyze_task_parallel_code!(interp::JETInterpreter, @nospecialize(f), argtypes::Vector{Any}, sv::InferenceState)\n\nAdds special cased analysis pass for task parallelism (xref: https://github.com/aviatesk/JET.jl/issues/114). In Julia's task parallelism implementation, parallel code is represented as closure and it's   wrapped in a Task object. NativeInterpreter doesn't run type inference nor optimization   on the body of those closures when compiling code that creates parallel tasks, but JET will   try to run additional analysis pass by recurring into the closures.\n\nnote: Note\nJET won't do anything other than doing JET analysis, e.g. won't annotate return type of wrapped code block in order to not confuse the original AbstractInterpreter routine track https://github.com/JuliaLang/julia/pull/39773 for the changes in native abstract interpretation routine.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JET.is_from_same_frame","page":"Internals","title":"JET.is_from_same_frame","text":"is_from_same_frame(parent_linfo::MethodInstance, current_linfo::MethodInstance) ->\n    (report::InferenceErrorReport) -> Bool\n\nReturns a function that checks if a given InferenceErrorReport is generated from current_linfo. It also checks current_linfo is a \"lineage\" of parent_linfo (i.e. entered from it).\n\nThis function is supposed to be used to filter out reports collected from analysis on current_linfo   without using constants when entering into the constant analysis. As such, this function   assumes that when a report should be filtered out, the first elment of its virtual stack   frame st is for parent_linfo and the second element of that is for current_linfo.\n\nExample: Assume linfo2 will produce a report for some reason.\n\nentry\n└─ linfo1\n   ├─ linfo2 (report1: linfo2)\n   ├─ linfo3 (report1: linfo1->linfo2, report2: linfo3->linfo2)\n   │  └─ linfo2 (report1: linfo1->linfo2, report2: linfo2)\n   └─ linfo3′ (report1: linfo1->linfo2, ~~report2: linfo1->linfo3->linfo2~~)\n\nIn the example analysis above, report2 will be filtered out on re-entering into linfo3′   (i.e. we're analyzing linfo3 with constants argument), because   is_from_same_frame(linfo1, linfo3)(report2) returns true. Note that report1 is still kept there because of the lineage check, i.e.   is_from_same_frame(linfo1, linfo3)(report1) returns false.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JET.AbstractGlobal","page":"Internals","title":"JET.AbstractGlobal","text":"mutable struct AbstractGlobal\n    t::Any     # analyzed type\n    iscd::Bool # whether this abstract global variable is declarared as constant or not\nend\n\nWraps a global variable whose type is analyzed by abtract interpretation. AbstractGlobal object will be actually evaluated into the context module, and a later   analysis may refer to its type or alter it on another assignment.\n\nnote: Note\nThe type of the wrapped global variable will be propagated only when in a toplevel frame,   and thus we don't care about the analysis cache invalidation on a refinement of the   wrapped global variable, since JET doesn't cache the toplevel frame.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.JET_REPORT_CACHE","page":"Internals","title":"JET.JET_REPORT_CACHE","text":"JET_REPORT_CACHE::IdDict{UInt64, IdDict{Core.MethodInstance, Vector{JET.InferenceErrorReportCache}}}\n\nKeeps JET report cache for a MethodInstance. Reports are cached when JETInterpreter exits from _typeinf.\n\n\n\n\n\n","category":"constant"},{"location":"internals/#JET.JET_CODE_CACHE","page":"Internals","title":"JET.JET_CODE_CACHE","text":"JET_CODE_CACHE::IdDict{UInt64, IdDict{Core.MethodInstance, Core.CodeInstance}}\n\nKeeps CodeInstance cache associated with mi::MethodInstace that represent the result of   an inference on mi performed by JETInterpreter. This cache is completely separated from the NativeInterpreter's global cache, so that   JET analysis never interacts with actual code execution.\n\n\n\n\n\n","category":"constant"},{"location":"internals/#Top-level-Analysis","page":"Internals","title":"Top-level Analysis","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"JET.virtual_process\nJET.virtualize_module_context\nJET.ConcreteInterpreter\nJET.partially_interpret!","category":"page"},{"location":"internals/#JET.virtual_process","page":"Internals","title":"JET.virtual_process","text":"virtual_process(s::AbstractString,\n                filename::AbstractString,\n                interp::JETInterpreter,\n                config::ToplevelConfig,\n                ) -> res::VirtualProcessResult\n\nSimulates Julia's toplevel execution and collects error points, and finally returns res::VirtualProcessResult\n\nres.included_files::Set{String}: files that have been analyzed\nres.toplevel_error_reports::Vector{ToplevelErrorReport}: toplevel errors found during the   text parsing or partial (actual) interpretation; these reports are \"critical\" and should   have precedence over inference_error_reports\nres.inference_error_reports::Vector{InferenceErrorReport}: possible error reports found   by JETInterpreter\nres.toplevel_signatures: signatures of methods defined within the analyzed files\nres.actual2virtual::Pair{Module, Module}: keeps actual and virtual module\n\nThis function first parses s::AbstractString into toplevelex::Expr and then iterate the   following steps on each code block (blk) of toplevelex:\n\nif blk is a :module expression, recusively enters analysis into an newly defined   virtual module\nlowers blk into :thunk expression lwr (macros are also expanded in this step)\nif the context module is virtualized, replaces self-references of the original context   module with virtualized one: see fix_self_references\nConcreteInterpreter partially interprets some statements in lwr that should not be   abstracted away (e.g. a :method definition); see also partially_interpret!\nfinally, JETInterpreter analyzes the remaining statements by abstract interpretation\n\nwarning: Warning\nIn order to process the toplevel code sequentially as Julia runtime does, virtual_process   splits the entire code, and then iterate a simulation process on each code block. With this approach, we can't track the inter-code-block level dependencies, and so a   partial interpretation of toplevle definitions will fail if it needs an access to global   variables defined in other code blocks that are not interpreted but just abstracted. We can circumvent this issue using JET's concretization_patterns configuration, which   allows us to customize JET's concretization strategy. See ToplevelConfig for more details.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JET.virtualize_module_context","page":"Internals","title":"JET.virtualize_module_context","text":"virtualize_module_context(actual::Module)\n\nHACK: Returns a module where the context of actual is virtualized.\n\nThe virtualization will be done by 2 steps below:\n\nloads the module context of actual into a sandbox module, and export the whole context from there\nthen uses names exported from the sandbox\n\nThis way, JET's runtime simulation in the virtual module context will be able to define a name   that is already defined in actual without causing   \"cannot assign a value to variable ... from module ...\" error, etc. It allows JET to virtualize the context of already-existing module other than Main.\n\nwarning: TODO\nCurrently this function relies on Base.names, and thus it can't restore the usinged   names.\n\n\n\n\n\n","category":"function"},{"location":"internals/#JET.ConcreteInterpreter","page":"Internals","title":"JET.ConcreteInterpreter","text":"ConcreteInterpreter\n\nThe trait to inject code into JuliaInterpreter's interpretation process; JET.jl overloads:\n\nJuliaInterpreter.step_expr! to add error report pass for module usage expressions and   support package analysis\nJuliaInterpreter.evaluate_call_recurse! to special case include calls\nJuliaInterpreter.handle_err to wrap an error happened during interpretation into   ActualErrorWrapped\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.partially_interpret!","page":"Internals","title":"JET.partially_interpret!","text":"partially_interpret!(interp::ConcreteInterpreter, mod::Module, src::CodeInfo)\n\nPartially interprets statements in src using JuliaInterpreter.jl:\n\nconcretizes \"toplevel definitions\", i.e. :method, :struct_type, :abstract_type and   :primitive_type expressions and their dependencies\nconcretizes user-specified toplevel code (see ToplevelConfig)\ndirectly evaluates module usage expressions and report error of invalid module usages (TODO: enter into the loaded module and keep JET analysis)\nspecial-cases include calls so that top-level analysis recursively enters the included file\n\n\n\n\n\n","category":"function"},{"location":"internals/#Error-Report-Interface","page":"Internals","title":"Error Report Interface","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"JET.VirtualFrame\nJET.VirtualStackTrace\nJET.InferenceErrorReport\nJET.ToplevelErrorReport","category":"page"},{"location":"internals/#JET.VirtualFrame","page":"Internals","title":"JET.VirtualFrame","text":"VirtualFrame\n\nStack information representing virtual execution context:\n\nfile::Symbol: the path to the file containing the virtual execution context\nline::Int: the line number in the file containing the virtual execution context\nsig::Vector{Any}: a signature of this frame\nlinfo::MethodInstance: The MethodInstance containing the execution context\n\nThis type is very similar to Base.StackTraces.StackFrame, but its execution context is collected during abstract interpration, not collected from actual execution.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.VirtualStackTrace","page":"Internals","title":"JET.VirtualStackTrace","text":"VirtualStackTrace\n\nRepresents a virtual stack trace in the form of a vector of VirtualFrame. The vector holds VirtualFrames in order of \"from entry call site to error point\", i.e. the first element is the VirtualFrame of the entry call site, and the last element is that contains the error.\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.InferenceErrorReport","page":"Internals","title":"JET.InferenceErrorReport","text":"InferenceErrorReport\n\nAn interface type of error reports that JET collects by abstract interpration.\n\nIf T implements this interface, the following requirements should be satisfied:\n\n\n\nFields\n\nT should have the following fields:\n\nvst::VirtualStackTrace: a virtual stack trace of the error\nmsg::String: explains why this error is reported\nsig::Vector{Any}: a signature of the error point\n\nNote that T can still have additional fields specific to it.\n\n\n\nA constructor interface to create T from abstraction interpretation\n\nT<:InferenceErrorReport can be created anywhere from JETInterpreter's abstract interpretation routine using the constructor T(interp::JETInterpreter, ::InferenceState, spec_args...). T can optionally overload any of the following interfaces to customize how it's created:\n\n(::Type{T})(::JETInterpreter, ::InferenceState, spec_args...) -> T\nget_vst(::Type{T}, ::JETInterpreter, ::InferenceState, spec_args...) -> vst::VirtualStackTrace:\nget_msg(::Type{T}, ::JETInterpreter, ::InferenceState, spec_args...) -> msg::String:\nget_sig(::Type{T}, ::JETInterpreter, ::InferenceState, spec_args...) -> sig::Vector{Any}\n\nnote: Note\nget_msg(::Type{T}, ::JETInterpreter, ::InferenceState, spec_args...) must be overloaded, otherwise the senseless default message will be rendered.\n\n\n\nSee also: VirtualStackTrace, VirtualFrame\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.ToplevelErrorReport","page":"Internals","title":"JET.ToplevelErrorReport","text":"ToplevelErrorReport\n\nAn interface type of error reports that JET collects while top-level concrete interpration. All ToplevelErrorReport should have the following fields:\n\nfile::String: the path to the file containing the interpretation context\nline::Int: the line number in the file containing the interpretation context\n\nSee also: virtual_process, ConcreteInterpreter\n\n\n\n\n\n","category":"type"},{"location":"internals/#Utilities","page":"Internals","title":"Utilities","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"JET.@invoke\nJET.@invokelatest\nJET.@withmixedhash\nJET.@jetconfigurable","category":"page"},{"location":"internals/#JET.@invoke","page":"Internals","title":"JET.@invoke","text":"@invoke f(arg::T, ...; kwargs...)\n\nProvides a convenient way to call invoke; @invoke f(arg1::T1, arg2::T2; kwargs...) will be expanded into invoke(f, Tuple{T1,T2}, arg1, arg2; kwargs...). When an argument's type annotation is omitted, it's specified as Any argument, e.g. @invoke f(arg1::T, arg2) will be expanded into invoke(f, Tuple{T,Any}, arg1, arg2).\n\nThis could be used to call down to NativeInterpreter's abstract interpretation method of   f while passing JETInterpreter so that subsequent calls of abstract interpretation   functions overloaded against JETInterpreter can be called from the native method of f; e.g. calls down to NativeInterpreter's abstract_call_gf_by_type method:\n\n@invoke abstract_call_gf_by_type(interp::AbstractInterpreter, f, argtypes::Vector{Any}, atype, sv::InferenceState,\n                                 max_methods::Int)\n\n\n\n\n\n","category":"macro"},{"location":"internals/#JET.@invokelatest","page":"Internals","title":"JET.@invokelatest","text":"@invokelatest f(args...; kwargs...)\n\nProvides a convenient way to call Base.invokelatest. @invokelatest f(args...; kwargs...) will simply be expanded into Base.invokelatest(f, args...; kwargs...).\n\n\n\n\n\n","category":"macro"},{"location":"internals/#JET.@withmixedhash","page":"Internals","title":"JET.@withmixedhash","text":"@withmixedhash (mutable) struct T\n    fields ...\nend\n\nDefines struct T while automatically defining its Base.hash(::T, ::UInt) method which   mixes hashes of all of T's fields (and also corresponding Base.:(==)(::T, ::T) method).\n\nThis macro is supposed to abstract the following kind of pattern:\n\nhttps://github.com/aviatesk/julia/blob/999973df2850d6b2e0bd4bcf03ef90a14217b63c/base/pkgid.jl#L3-L25\n\nstruct PkgId\n    uuid::Union{UUID,Nothing}\n    name::String\nend\n\n==(a::PkgId, b::PkgId) = a.uuid == b.uuid && a.name == b.name\n\nfunction hash(pkg::PkgId, h::UInt)\n    h += 0xc9f248583a0ca36c % UInt\n    h = hash(pkg.uuid, h)\n    h = hash(pkg.name, h)\n    return h\nend\n\nwith @withmixedhash\n\n@withmixedhash struct PkgId\n    uuid::Union{UUID,Nothing}\n    name::String\nend\n\nSee also: EGAL_TYPES\n\n\n\n\n\n","category":"macro"},{"location":"internals/#JET.@jetconfigurable","page":"Internals","title":"JET.@jetconfigurable","text":"@jetconfigurable function config_func(args...; configurations...)\n    ...\nend\n\nThis macro asserts that there's no configuration naming conflict across the @jetconfigurable   functions so that a configuration for a @jetconfigurable function  doesn't affect the other   @jetconfigurable functions. This macro also adds a dummy splat keyword arguments (jetconfigs...) to the function definition   so that any configuration of other @jetconfigurable functions can be passed on to it.\n\n\n\n\n\n","category":"macro"},{"location":"config/#JET-configurations","page":"Configurations","title":"Configurations","text":"","category":"section"},{"location":"config/","page":"Configurations","title":"Configurations","text":"JET analysis can be flexibly fine-tuned. Any entry point explained in Usages can accept any of the configuration parameter described below as keyword arguments (or optional parameters for macros). For example, if you want to analyze some/awesome/code.jl with turning on strict_condition_check configuration and also logs inference process into stdout, your can do:","category":"page"},{"location":"config/","page":"Configurations","title":"Configurations","text":"report_file(\"some/awesome/code.jl\";\n            strict_condition_check = true,\n            inference_logger = stdout)","category":"page"},{"location":"config/","page":"Configurations","title":"Configurations","text":"note: Note\nPlease ignore the names of documented objects below, like \"JET.ToplevelConfig\". They are just remnants of documentation internals, and you will never directly interact with them.","category":"page"},{"location":"config/#Configurations-for-Top-level-Analysis","page":"Configurations","title":"Configurations for Top-level Analysis","text":"","category":"section"},{"location":"config/","page":"Configurations","title":"Configurations","text":"JET.ToplevelConfig","category":"page"},{"location":"config/#JET.ToplevelConfig","page":"Configurations","title":"JET.ToplevelConfig","text":"Configurations for top-level analysis. These configurations will be active for all the top-level entries explained in Analysis entry points.\n\n\n\ncontext::Bool = Main \nThe module context in which the top-level execution will be simulated.\nThis module context will be virtualized by default so that JET can repeat analysis in the   same session by avoiding \"invalid redefinition of constant ...\" error etc., without   polluting the original context module.\nThis configuration can be useful when you just want to analyze a submodule, without   analyzing from the root module. For example, we can analyze Base.Math like below:\njulia> report_file(JET.fullbasepath(\"math.jl\");\n                   context = Base,                  # `Base.Math`'s root module\n                   analyze_from_definitions = true, # there're only definitions in `Base`\n                   )\n\n\n\nanalyze_from_definitions::Bool = false \nIf true, JET will start analysis using signatures of top-level definitions (e.g. method signatures),   after the top-level interpretation has been done (unless no serious top-level error has   happened, like errors involved within a macro expansion).\nThis is useful when you want to analyze a package, which usually contains only definitions   but not top-level callsites. With this option, JET can enter analysis just with method or type definitions, and we don't   need to pass a file that uses the target package.\nwarning: Warning\nThis feature is very experimental at this point, and you may face lots of false positive   errors, especially when trying to analyze a big package with lots of dependencies. If a file that contains top-level callsites (e.g. test/runtests.jl) is available,   JET analysis entered from there will produce more accurate analysis results than   with this configuration.\nAlso see: report_file, report_and_watch_file\n\n\n\nconcretization_patterns::Vector{<:Any} = Expr[] \nSpecifies a customized top-level code concretization strategy.\nWhen analyzing a top-level code, JET first splits the entire code and then iterate a virtual   top-level code execution process on each code block, in order to simulate Julia's sequential   top-level code execution. However, with this approach, JET can't track the \"inter-code-block\" level dependencies, and   so a partial interpretation of top-level definitions can fail if it needs an access to   global variables defined in other code blocks that are not actually interpreted (\"concretized\")   but just abstract-interpreted (\"abstracted\").\nFor example, the issue happens when your macro accesses to a global variable during its expansion, e.g.:\ntest/fixtures/concretization_patterns.jl\n# JET doesn't conretize this by default, but just analyze its type\nconst GLOBAL_CODE_STORE = Dict()\n\nmacro with_code_record(a)\n    GLOBAL_CODE_STORE[__source__] = a # record the code location in the global store\n    esc(a)\nend\n\n# here JET will try to actually expand `@with_code_record`,\n# but since `GLOBAL_CODE_STORE` didn't get concretized (i.e. instantiated), JET analysis fails at this point\n@with_code_record foo(a) = identity(a)\n\nfoo(10) # top-level callsite, abstracted away\n\nTo circumvent this issue, JET offers the concretization_patterns::Vector{<:Any} configuration,   which allows us to customize JET's top-level code concretization strategy. concretization_patterns specifies the patterns of code that should be concretized. JET internally uses MacroTools.jl's expression pattern match,   and we can specify any expression pattern that is expected by MacroTools.@capture macro. For example, in order to solve the issue explained above, we can have:\nconcretization_patterns = [:(GLOBAL_CODE_STORE = x_)]\nPlease note that we must use :(GLOBAL_CODE_STORE = x_) rather than :(const GLOBAL_CODE_STORE = x_). This is because currently the specified patterns will be matched against the lowered code representation,   in which const x = y has been lowered to the sequence of 1.) the declaration const x,   2.) value computation %2 = Dict() and 3.) actual assignment part x = %2. Although this could be really tricky, we can effectively debug JET's top-level code concretization plan   using JETLogger's toplevel_logger with the logging level above than 1 (\"debug\") level,   where t-annotated statements will be concretize while f-annotated statements will be analyzed by abstract interpretation.\njulia> report_file(\"test/fixtures/concretization_patterns.jl\";\n                   concretization_patterns = [:(GLOBAL_CODE_STORE = x_)],\n                   toplevel_logger = IOContext(stdout, :JET_LOGGER_LEVEL => 1))\n[toplevel-debug] entered into test/fixtures/concretization_patterns.jl\n[toplevel-debug] concretization plan:\n1 f 1 ─      const GLOBAL_CODE_STORE\n2 t │   %2 = Dict()\n3 t │        GLOBAL_CODE_STORE = %2\n4 f └──      return %2\n[toplevel-debug] concretization plan:\n1 f 1 ─      $(Expr(:thunk, CodeInfo(\n    @ none within `top-level scope'\n1 ─     return $(Expr(:method, Symbol(\"@with_code_record\")))\n)))\n2 t │        $(Expr(:method, Symbol(\"@with_code_record\")))\n3 t │   %3 = Core.Typeof(var\"@with_code_record\")\n4 t │   %4 = Core.svec(%3, Core.LineNumberNode, Core.Module, Core.Any)\n5 t │   %5 = Core.svec()\n6 t │   %6 = Core.svec(%4, %5, $(QuoteNode(:(#= test/fixtures/concretization_patterns.jl:4 =#))))\n7 t │        $(Expr(:method, Symbol(\"@with_code_record\"), :(%6), CodeInfo(\n    @ test/fixtures/concretization_patterns.jl:5 within `none'\n1 ─      $(Expr(:meta, :nospecialize, :(a)))\n│        Base.setindex!(GLOBAL_CODE_STORE, a, __source__)\n│   @ test/fixtures/concretization_patterns.jl:6 within `none'\n│   %3 = esc(a)\n└──      return %3\n)))\n8 f └──      return var\"@with_code_record\"\n[toplevel-debug] concretization plan:\n1 f 1 ─      $(Expr(:thunk, CodeInfo(\n    @ none within `top-level scope'\n1 ─     return $(Expr(:method, :foo))\n)))\n2 t │        $(Expr(:method, :foo))\n3 t │   %3 = Core.Typeof(foo)\n4 t │   %4 = Core.svec(%3, Core.Any)\n5 t │   %5 = Core.svec()\n6 t │   %6 = Core.svec(%4, %5, $(QuoteNode(:(#= test/fixtures/concretization_patterns.jl:11 =#))))\n7 t │        $(Expr(:method, :foo, :(%6), CodeInfo(\n    @ test/fixtures/concretization_patterns.jl:11 within `none'\n1 ─ %1 = identity(a)\n└──      return %1\n)))\n8 f └──      return foo\n[toplevel-debug] concretization plan:\n1 f 1 ─ %1 = foo(10)\n2 f └──      return %1\n[toplevel-debug]  exited from test/fixtures/concretization_patterns.jl (took 0.018 sec)\nAlso see: Logging Configurations, virtual_process.\n\n\n\nvirtualize::Bool = true \nWhen true, JET will virtualize the given root module context.\nThis configuration is supposed to be used only for testing or debugging. See virtualize_module_context for the internal.\n\n\n\n\n\n\n\n","category":"type"},{"location":"config/#Configurations-for-Abstract-Interpretation","page":"Configurations","title":"Configurations for Abstract Interpretation","text":"","category":"section"},{"location":"config/","page":"Configurations","title":"Configurations","text":"JET.JETAnalysisParams\nJET.JETInferenceParams","category":"page"},{"location":"config/#JET.JETAnalysisParams","page":"Configurations","title":"JET.JETAnalysisParams","text":"Configurations for JET analysis. These configurations will be active for all the entries.\n\n\n\nstrict_condition_check::Bool = false \nEnables strict condition check. JET reports an error if a condition expression type is \"non-boolean\". In a case when   the condition type is Union, JET will report if either of union split case is   non-boolean type, but this can lead to lots of false positive error reports when the   code is not well-typed, because Julia Base defines generic functions that are commonly   used at a conditional context but also may return \"non-boolean\" values, e.g.:\n!(::Function) -> Function\n!(::Missing) -> Missing\n==(::Missing, ::Any) -> Missing\n==(::Any, ::Missing) -> Missing\nand thus loosely-typed conditional expression often becomes e.g. Union{Bool, Missing},   and consequently JET will report it as \"non-boolean\" type   (NOTE: in Julia Missing is certainly not valid conditional type). If this configuration is set to false, JET enables an heuristic to avoid those false   positive error reports and won't report an error if a condition expression type is   Union and either of its union split case is Function or Missing.\nThe effect of this configuration can be described with the following examples:\nwith strict_condition_check::Bool = false (default)\njulia> test_f() = Dict('a' => 1, :b => 2) # ::Dict{Any,Int}\ntest_f (generic function with 1 method)\n\njulia> @report_call test_f()\nNo errors !\nDict{Any, Int64}\nwith strict_condition_check::Bool = true\njulia> test_f() = Dict('a' => 1, :b => 2) # ::Dict{Any,Int}\ntest_f (generic function with 1 method)\n\njulia> @report_call strict_condition_check = true test_f()\n═════ 1 possible error found ═════\n┌ @ REPL[2]:1 Main.Dict(Main.=>('a', 1), Main.=>(:b, 2))\n│┌ @ dict.jl:125 Base.Dict(ps)\n││┌ @ dict.jl:129 Base.dict_with_eltype(#308, kv, Base.eltype(kv))\n│││┌ @ abstractdict.jl:539 Base.grow_to!(Base.dict_with_eltype(DT_apply, _5), kv)\n││││┌ @ dict.jl:145 Base.grow_to!(dest2, itr, st)\n│││││┌ @ dict.jl:159 Base.setindex!(new, v, k)\n││││││┌ @ dict.jl:383 Base.ht_keyindex2!(h, key)\n│││││││┌ @ dict.jl:328 goto %35 if not Base.isequal(key, Base.getindex(keys, index))\n││││││││ for 1 of union split cases, non-boolean (Missing) used in boolean context: goto %35 if not Base.isequal(key::Symbol, Base.getindex(keys::Vector{Any}, index::Int64)::Any)::Union{Missing, Bool}\n│││││││└───────────────\nDict{Any, Int64}\n\n\n\nignore_native_remarks::Bool = true \nIf true, JET won't construct nor cache reports of \"native remarks\", which may speed up analysis time. \"Native remarks\" are information that Julia's native compiler emits about how type inference routine goes, and those remarks are less interesting in term of \"error checking\", so JET ignores them by default.\n\n\n\n\n\n","category":"type"},{"location":"config/#JET.JETInferenceParams","page":"Configurations","title":"JET.JETInferenceParams","text":"Configurations for Julia's native type inference routine. These configurations will be active for all the entries.\n\nYou can specify all the keyword parameters of Core.Compiler.InferenceParams, e.g.   max_methods::Int = 3, union_splitting::Int = 4. Listed here are selections of those parameters that can have a potent influence on JET analysis.\n\n\n\nipo_constant_propagation::Bool = true \nEnables constant propagation in abstract interpretation. It is highly recommended that you keep this configuration true to get reasonable analysis, because constant propagation can cut off lots of false positive errorenous code paths and thus lead to more accurate and useful analysis results.\n\n\n\naggressive_constant_propagation::Bool = true \nIf true, JET will try to do constant propagation more \"aggressively\". As explained above, it can lead to more accurate analysis, but also lead to worse analysis performance at the cost of that.\n\n\n\nunoptimize_throw_blocks::Bool = false \nTurn this on to skip analysis on code blocks that will eventually lead to a throw call. This configuration may improve the analysis performance, but it's better to be turned off   for JET analysis, because there may be other errors even in those code blocks.\n\n\n\n\n\n","category":"function"},{"location":"config/#Print-Configurations","page":"Configurations","title":"Print Configurations","text":"","category":"section"},{"location":"config/","page":"Configurations","title":"Configurations","text":"JET.PrintConfig","category":"page"},{"location":"config/#JET.PrintConfig","page":"Configurations","title":"JET.PrintConfig","text":"JET configurations for error printing. If the entry renders the collected error points, the configurations below will be active.\n\n\n\nprint_toplevel_success::Bool = false \nIf true, prints a message when there is no toplevel errors found.\n\n\n\nprint_inference_success::Bool = true \nIf true, print a message when there is no errors found in abstract interpretation based analysis pass.\n\n\n\nannotate_types::Bool = false \nWhen set to true, annotates types when printing analyzed call stack. Here are examples:\nwith annotate_types = false (default):\njulia> @report_call sum(\"julia\")\n═════ 2 possible errors found ═════\n┌ @ reduce.jl:530 Base.#sum#241(Base.pairs(Core.NamedTuple()), #self#, a)\n│┌ @ reduce.jl:530 Base.sum(Base.identity, a)\n││┌ @ reduce.jl:503 Base.#sum#240(Base.pairs(Core.NamedTuple()), #self#, f, a)\n│││┌ @ reduce.jl:503 Base.mapreduce(f, Base.add_sum, a)\n││││┌ @ reduce.jl:289 Base.#mapreduce#237(Base.pairs(Core.NamedTuple()), #self#, f, op, itr)\n│││││┌ @ reduce.jl:289 Base.mapfoldl(f, op, itr)\n││││││┌ @ reduce.jl:162 Base.#mapfoldl#233(Base._InitialValue(), #self#, f, op, itr)\n│││││││┌ @ reduce.jl:162 Base.mapfoldl_impl(f, op, init, itr)\n││││││││┌ @ reduce.jl:44 Base.foldl_impl(op′, nt, itr′)\n│││││││││┌ @ reduce.jl:48 Base._foldl_impl(op, nt, itr)\n││││││││││┌ @ reduce.jl:62 op(v, Base.getindex(y, 1))\n│││││││││││┌ @ reduce.jl:81 Base.getproperty(op, :rf)(acc, x)\n││││││││││││┌ @ reduce.jl:24 Base.+(x, y)\n│││││││││││││ no matching method found for call signature: Base.+(x::Char, y::Char)\n││││││││││││└────────────────\n│││││││││┌ @ reduce.jl:49 Base.reduce_empty_iter(op, itr)\n││││││││││┌ @ reduce.jl:356 Base.reduce_empty_iter(op, itr, Base.IteratorEltype(itr))\n│││││││││││┌ @ reduce.jl:357 Base.reduce_empty(op, Base.eltype(itr))\n││││││││││││┌ @ reduce.jl:330 Base.reduce_empty(Base.getproperty(op, :rf), _)\n│││││││││││││┌ @ reduce.jl:322 Base.reduce_empty(Base.+, _)\n││││││││││││││┌ @ reduce.jl:313 Base.zero(_)\n│││││││││││││││ no matching method found for call signature: Base.zero(_::Type{Char})\n││││││││││││││└─────────────────\nChar\nwith annotate_types = true\njulia> @report_call annotate_types = true sum(\"julia\")\n═════ 2 possible errors found ═════\n┌ @ reduce.jl:530 Base.#sum#241(Base.pairs(Core.NamedTuple()::NamedTuple{(), Tuple{}})::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, #self#::typeof(sum), a::String)\n│┌ @ reduce.jl:530 Base.sum(Base.identity, a::String)\n││┌ @ reduce.jl:503 Base.#sum#240(Base.pairs(Core.NamedTuple()::NamedTuple{(), Tuple{}})::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, #self#::typeof(sum), f::typeof(identity), a::String)\n│││┌ @ reduce.jl:503 Base.mapreduce(f::typeof(identity), Base.add_sum, a::String)\n││││┌ @ reduce.jl:289 Base.#mapreduce#237(Base.pairs(Core.NamedTuple()::NamedTuple{(), Tuple{}})::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, #self#::typeof(mapreduce), f::typeof(identity), op::typeof(Base.add_sum), itr::String)\n│││││┌ @ reduce.jl:289 Base.mapfoldl(f::typeof(identity), op::typeof(Base.add_sum), itr::String)\n││││││┌ @ reduce.jl:162 Base.#mapfoldl#233(Base._InitialValue()::Base._InitialValue, #self#::typeof(mapfoldl), f::typeof(identity), op::typeof(Base.add_sum), itr::String)\n│││││││┌ @ reduce.jl:162 Base.mapfoldl_impl(f::typeof(identity), op::typeof(Base.add_sum), init::Base._InitialValue, itr::String)\n││││││││┌ @ reduce.jl:44 Base.foldl_impl(op′::Base.BottomRF{typeof(Base.add_sum)}, nt::Base._InitialValue, itr′::String)\n│││││││││┌ @ reduce.jl:49 Base.reduce_empty_iter(op::Base.BottomRF{typeof(Base.add_sum)}, itr::String)\n││││││││││┌ @ reduce.jl:356 Base.reduce_empty_iter(op::Base.BottomRF{typeof(Base.add_sum)}, itr::String, Base.IteratorEltype(itr::String)::Base.HasEltype)\n│││││││││││┌ @ reduce.jl:357 Base.reduce_empty(op::Base.BottomRF{typeof(Base.add_sum)}, Base.eltype(itr::String)::Type{Char})\n││││││││││││┌ @ reduce.jl:330 Base.reduce_empty(Base.getproperty(op::Base.BottomRF{typeof(Base.add_sum)}, :rf::Symbol)::typeof(Base.add_sum), _::Type{Char})\n│││││││││││││┌ @ reduce.jl:322 Base.reduce_empty(Base.+, _::Type{Char})\n││││││││││││││┌ @ reduce.jl:313 Base.zero(_::Type{Char})\n│││││││││││││││ no matching method found for call signature: Base.zero(_::Type{Char})\n││││││││││││││└─────────────────\n│││││││││┌ @ reduce.jl:48 Base._foldl_impl(op::Base.BottomRF{typeof(Base.add_sum)}, nt::Base._InitialValue, itr::String)\n││││││││││┌ @ reduce.jl:62 op::Base.BottomRF{typeof(Base.add_sum)}(v::Char, Base.getindex(y::Tuple{Char, Int64}, 1)::Char)\n│││││││││││┌ @ reduce.jl:81 Base.getproperty(op::Base.BottomRF{typeof(Base.add_sum)}, :rf::Symbol)::typeof(Base.add_sum)(acc::Char, x::Char)\n││││││││││││┌ @ reduce.jl:24 Base.+(x::Char, y::Char)\n│││││││││││││ no matching method found for call signature: Base.+(x::Char, y::Char)\n││││││││││││└────────────────\nChar\nnote: Note\nJET always annotates types when printing the error point, e.g. in the example above, the error points below are always type-annotated regardless of this configuration:no matching method found for call signature: Base.zero(_::Type{Char})\nno matching method found for call signature: Base.+(x::Char, y::Char)\n\n\n\nfullpath::Bool = false \nControls whether or not expand a file path to full path when printing analyzed call stack. Note that paths of Julia's Base files will also be expanded when set to true.\n\n\n\n\n\n","category":"type"},{"location":"config/#Watch-Configurations","page":"Configurations","title":"Watch Configurations","text":"","category":"section"},{"location":"config/","page":"Configurations","title":"Configurations","text":"JET.WatchConfig","category":"page"},{"location":"config/#JET.WatchConfig","page":"Configurations","title":"JET.WatchConfig","text":"Configurations for \"watch\" mode. The configurations will only be active when used with report_and_watch_file.\n\n\n\nrevise_all::Bool = true \nRedirected to Revise.entr's all keyword argument. When set to true, JET will retrigger analysis as soon as code updates are detected in   any module tracked by Revise. Currently when encountering import/using statements, JET won't perform analysis, but   rather will just load the modules as usual execution (this also means Revise will track   those modules). So if you're editing both files analyzed by JET and modules that are used within the files,   this configuration should be enabled.\n\n\n\nrevise_modules = nothing \nRedirected to Revise.entr's modules positional argument. If a iterator of Module is given, JET will retrigger analysis whenever code in modules updates.\ntip: Tip\nThis configuration is useful when your're also editing files that are not tracked by Revise, e.g. editing functions defined in Base:# re-performe analysis when you make a change to `Base`\njulia> report_and_watch_file(yourfile; revise_modules = [Base])\n\n\n\n\n\n","category":"type"},{"location":"config/#Logging-Configurations","page":"Configurations","title":"Logging Configurations","text":"","category":"section"},{"location":"config/","page":"Configurations","title":"Configurations","text":"JET.JETLogger","category":"page"},{"location":"config/#JET.JETLogger","page":"Configurations","title":"JET.JETLogger","text":"Logging configurations for JET analysis.\n\n\n\ntoplevel_logger::Union{Nothing,IO} = nothing \nIf IO object is given, it will track JET's toplevel analysis. Logging level can be specified with :JET_LOGGER_LEVEL IO property. Currently supported logging levels are either of 0 (\"info\" level, default), 1 (\"debug\" level).\nExamples:\nlogs into stdout\njulia> report_file(filename; toplevel_logger = stdout)\nlogs into io::IOBuffer with \"debug\" logger level\njulia> report_file(filename; toplevel_logger = IOContext(io, :JET_LOGGER_LEVEL => 1));\n\n\n\ninference_logger::Union{Nothing,IO} = nothing \nIf IO object is given, it will track JET's abstract interpretation routine. Logging level can be specified with :JET_LOGGER_LEVEL IO property. Currently supported logging levels are either of 0 (\"info\" level, default), 1 (\"debug\" level).\nExamples:\nlogs into stdout\nanalyze_call(f, args...; inference_logger = stdout)\nlogs into io::IOBuffer with \"debug\" logger level\njulia> analyze_call(f, args...; inference_logger = IOContext(io, :JET_LOGGER_LEVEL => 1))\n\n\n\ntip: Tip\nOf course you can specify both toplevel_logger and inference_logger at the same time like below:julia> report_and_watch_file(filename;\n                             toplevel_logger = IOContext(logger_io, :JET_LOGGER_LEVEL => 1),\n                             inference_logger = inference_io)\n\n\n\n\n\n","category":"type"},{"location":"config/#Configuration-File","page":"Configurations","title":"Configuration File","text":"","category":"section"},{"location":"config/","page":"Configurations","title":"Configurations","text":"JET.parse_config_file","category":"page"},{"location":"config/#JET.parse_config_file","page":"Configurations","title":"JET.parse_config_file","text":"JET.jl offers .prettierrc style   configuration file support. This means you can use .JET.toml configuration file to specify any of configurations   explained above and share that with others.\n\nWhen report_file or report_and_watch_file is called, it will look for   .JET.toml in the directory of the given file, and search up the file tree until   a JET configuration file is (or isn't) found. When found, the configurations specified in the file will be applied.\n\nA configuration file can specify any of JET configurations like:\n\naggressive_constant_propagation = false # turn off aggressive constant propagation\n... # other configurations\n\nNote that the following configurations should be string(s) of valid Julia code:\n\ncontext: string of Julia code, which can be parsed and evaluated into Module\nconcretization_patterns: vector of string of Julia code, which can be parsed into a Julia expression pattern expected by MacroTools.@capture macro.\ntoplevel_logger: string of Julia code, which can be parsed and evaluated into Union{IO,Nothing}\ninference_logger: string of Julia code, which can be parsed and evaluated into Union{IO,Nothing}\n\nE.g. the configurations below are equivalent:\n\nconfigurations via keyword arguments\nreport_file(somefile;\n            concretization_patterns = [:(GLOBAL_CODE_STORE = x_)],\n            toplevel_logger = IOContext(open(\"toplevel.txt\", \"w\"), :JET_LOGGER_LEVEL => 1))\nconfigurations via a configuration file\n# supposed to concretize `const GLOBAL_CODE_STORE = Dict()` in test/fixtures/concretization_patterns.jl\nconcretization_patterns = [\"GLOBAL_CODE_STORE = x_\"]\n\n# logs toplevel analysis into toplevel.txt with debug logging level\ntoplevel_logger = \"\"\"IOContext(open(\"toplevel.txt\", \"w\"), :JET_LOGGER_LEVEL => 1)\"\"\"\n\n\nnote: Note\nJET configurations specified as keyword arguments have precedence over those specified   via a configuration file.\n\n\n\n\n\n","category":"function"}]
}
