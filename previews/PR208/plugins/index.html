<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Pluggable Analysis Framework · JET.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JET.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">README</a></li><li><a class="tocitem" href="../usages/">Usages</a></li><li><a class="tocitem" href="../config/">Configurations</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li class="is-active"><a class="tocitem" href>Pluggable Analysis Framework</a><ul class="internal"><li><a class="tocitem" href="#Interfaces"><span>Interfaces</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Pluggable Analysis Framework</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Pluggable Analysis Framework</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aviatesk/JET.jl/blob/master/docs/src/plugins.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="JET.jl-Pluggable-Analysis-Framework"><a class="docs-heading-anchor" href="#JET.jl-Pluggable-Analysis-Framework">JET.jl Pluggable Analysis Framework</a><a id="JET.jl-Pluggable-Analysis-Framework-1"></a><a class="docs-heading-anchor-permalink" href="#JET.jl-Pluggable-Analysis-Framework" title="Permalink"></a></h1><p>The documentation for the framework is very WIP.</p><h2 id="Interfaces"><a class="docs-heading-anchor" href="#Interfaces">Interfaces</a><a id="Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Interfaces" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JET.AbstractAnalyzer" href="#JET.AbstractAnalyzer"><code>JET.AbstractAnalyzer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractAnalyzer &lt;: AbstractInterpreter end</code></pre><p>When <code>T</code> implements this interface (i.e. <code>T &lt;: AbstractAnalyzer</code>), <code>T</code> is expected to implement:</p><ul><li><code>T(; jetconfigs...) -&gt; T</code>: constructs new analyzer given <a href="@ref JET configurations">JET configurations</a>; <code>AnalyzerState</code> for this analyzer should be constructed using these configurations</li><li><code>AnalyzerState(analyzer::T) -&gt; AnalyzerState</code>: returns <code>AnalyzerState</code> instance, usually it&#39;s kept within <code>T</code> itself</li><li><code>AbstractAnalyzer(analyzer::T, state::AnalyzerState) -&gt; T</code>: constructs new analyzer given the previous analyzer and analysis state</li><li><code>ReportPass(analyzer::T) -&gt; ReportPass</code>: returns the <a href="@ref ReportPass">report pass</a> of <code>T</code></li></ul><p>For example, JET.jl defines <code>JETAnalyzer &lt;: AbstractAnalyzer</code> as the following (modified a bit for the sake of simplicity):</p><pre><code class="language-julia"># default interpreter for JET.jl
struct JETAnalyzer{RP&lt;:ReportPass} &lt;: AbstractAnalyzer
    report_pass::RP
    state::AnalyzerState
end

# AbstractAnalyzer API requirements

function JETAnalyzer(;
    report_pass::Union{Nothing,T} = nothing,
    mode::Symbol                  = :basic,
    jetconfigs...) where {T&lt;:ReportPass}
    if isnothing(report_pass)
        # if `report_pass` isn&#39;t passed explicitly, here we configure it according to `mode`
        report_pass = mode === :basic ? BasicPass() :
                      mode === :sound ? SoundPass() :
                      throw(ArgumentError(&quot;`mode` configuration should be either of `:basic` or `:sound`&quot;))
    end
    return JETAnalyzer(report_pass,
                       AnalyzerState(; jetconfigs...),
                       )
end
AnalyzerState(analyzer::JETAnalyzer)                          = analyzer.state
AbstractAnalyzer(analyzer::JETAnalyzer, state::AnalyzerState) = JETAnalyzer(ReportPass(analyzer), state)
ReportPass(analyzer::JETAnalyzer)                             = analyzer.report_pass</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/e079637c7aeb9c7e3476b5bbd7d8f9fc0d322204/src/interfaces.jl#L4-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.ReportPass" href="#JET.ReportPass"><code>JET.ReportPass</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReportPass</code></pre><p>An interface type for report passes of JET&#39;s analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/e079637c7aeb9c7e3476b5bbd7d8f9fc0d322204/src/interfaces.jl#L52-L56">source</a></section></article><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JET.PluginExamples" href="#JET.PluginExamples"><code>JET.PluginExamples</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>&quot;Unstable API&quot;s Analysis</strong></p><p>Julia doesn&#39;t have any facilities to truly hide module internals. This means, we can always access to whatever defined within a module and use it freely, but some of them may be considered as the module&#39;s &quot;internal&quot;s and subject to changes. When possible, we want to avoid using those &quot;unstable API&quot; s for better maintainability in the future. But the problem is, how can we find them already used in an existing code ?</p><p>The following code implements such an analysis as a plug-in analysis under JET.jl framework. Let&#39;s define &quot;unstable API&quot; s such that, they&#39;re</p><ul><li>not <code>export</code>ed</li><li>nor documented</li></ul><p>Then we can just check each binding discovered during abstract interpretation meets the criteria. Technically, we will overload <code>Core.Compiler.abstract_eval_special_value</code> and check <code>GlobalRef</code>s appeared there.</p><p>The implementation below is <em>almost sound</em>, under the assumption that the bindings are resolved statically. One thing to note is that, the analysis implements an heuristic to avoid false positives from &quot;language intrinsics&quot;, for example, <code>Base.indexed_iterate</code> and <code>Base.Broadcast.broadcasted</code>. They&#39;re <em>usually</em> automatically introduced into your code by Julia&#39;s iteration protocols and such, and in such cases we&#39;re not responsible for those details. But the problem is the analysis doesn&#39;t distinguish those introduced by the language and those written by ourselves, and in the latter case we&#39;re certainly uses &quot;unstable API&quot; under the definition above.</p><p>This analysis is motivated by <a href="https://github.com/JuliaLang/julia/pull/40745#issuecomment-850876150">this discussion</a>.</p><pre><code class="language-julia">module find_unstable_api

using JET

const CC = Core.Compiler

struct UnstableAPIAnalyzer{T} &lt;: JET.AbstractAnalyzer
    state::JET.AnalyzerState
    is_target_module::T
end
function UnstableAPIAnalyzer(;
    is_target_module = ==(@__MODULE__),
    jetconfigs...)
    return UnstableAPIAnalyzer(JET.AnalyzerState(; jetconfigs...), is_target_module)
end
JET.AnalyzerState(analyzer::UnstableAPIAnalyzer) = analyzer.state
JET.AbstractAnalyzer(analyzer::UnstableAPIAnalyzer, state::JET.AnalyzerState) =
    UnstableAPIAnalyzer(state, analyzer.is_target_module)
JET.ReportPass(analyzer::UnstableAPIAnalyzer) = UnstableAPIAnalysisPass()

struct UnstableAPIAnalysisPass &lt;: JET.ReportPass end

function CC.abstract_eval_special_value(analyzer::UnstableAPIAnalyzer, @nospecialize(e), vtypes::CC.VarTable, sv::CC.InferenceState)
    if analyzer.is_target_module(sv.mod) # we care only about what we wrote
        JET.report_pass!(UnstableAPI, analyzer, sv, e)
    end

    return Base.@invoke CC.abstract_eval_special_value(analyzer::JET.AbstractAnalyzer, e, vtypes::CC.VarTable, sv::CC.InferenceState)
end

function CC.builtin_tfunction(analyzer::UnstableAPIAnalyzer, @nospecialize(f), argtypes::Vector{Any}, sv::CC.InferenceState)
    if f === getfield
        if length(argtypes) ≥ 2
            a1, a2 = argtypes[1:2]
            if isa(a1, Core.Const) &amp;&amp; (v1 = a1.val; isa(v1, Module))
                if isa(a2, Core.Const) &amp;&amp; (v2 = a2.val; isa(v2, Symbol))
                    if analyzer.is_target_module(sv.mod) || # we care only about what we wrote, but with relaxed filter
                       (parent = sv.parent; isa(parent, CC.InferenceState) &amp;&amp; analyzer.is_target_module(parent.mod))
                        JET.report_pass!(UnstableAPI, analyzer, sv, GlobalRef(v1, v2))
                    end
                end
            end
        end
    end

    return Base.@invoke CC.builtin_tfunction(analyzer::JET.AbstractAnalyzer, f, argtypes::Vector{Any}, sv::CC.InferenceState)
end

# ignore report passes implemented within JET.jl
(::UnstableAPIAnalysisPass)(T::Type{&lt;:JET.InferenceErrorReport}, analyzer, linfo, @nospecialize(spec_args...)) = return

# except undefined global references
function (::UnstableAPIAnalysisPass)(T::Type{JET.GlobalUndefVarErrorReport}, analyzer, linfo, @nospecialize(spec_args...))
    JET.BasicPass()(T, analyzer, linfo, spec_args...)
end

JET.@reportdef struct UnstableAPI &lt;: JET.InferenceErrorReport
    g::GlobalRef
end
function JET.get_msg(::Type{UnstableAPI}, analyzer::UnstableAPIAnalyzer, sv::CC.InferenceState, g::GlobalRef)
    (; mod, name) = Base.resolve(g) # resolve to original name
    return &quot;$mod.$name is unstable !&quot;
end

function (::UnstableAPIAnalysisPass)(::Type{UnstableAPI}, analyzer::UnstableAPIAnalyzer, sv::CC.InferenceState, @nospecialize(e))
    if isa(e, GlobalRef)
        isdefined(e.mod, e.name) || return false # will be caught by GlobalUndefVarErrorReport

        (; mod, name) = Base.resolve(e) # safely resolve this reference
        analyzer.is_target_module(mod) &amp;&amp; return # we don&#39;t care about what we defined ourselves

        if isunstable(mod, name)
            JET.report!(UnstableAPI, analyzer, sv, e)
        end
    end
end

# we define &quot;unstable API&quot; such that, it&#39;s
# - not `export`ed
# - nor documented
function isunstable(mod, name)
    # exclude language intrinsics
    mod === Core &amp;&amp; return false
    x = getfield(mod, name)
    x isa Core.Builtin &amp;&amp; return false
    (x === Base.indexed_iterate || x === Base.SizeUnknown) &amp;&amp; return false # iteration protocol
    (x === Base.Iterators.Filter || x === Base.Iterators.Flatten) &amp;&amp; return false # iterator protocol
    x === Base.Broadcast.broadcasted &amp;&amp; return false # broadcase protocol
    x === Base.kwerr &amp;&amp; return false # ignore keyword lowering

    return !isexported(mod, name) &amp;&amp; !hasdoc(mod, name)
end

function isexported(mod, name)
    (; mod, name) = Base.resolve(GlobalRef(mod, name))
    return Base.isexported(mod, name)
end

# adapted from https://github.com/JunoLab/CodeTools.jl/blob/56e7f0b514a7476864c27523bcf9d4bc04699ce1/src/summaries.jl#L24-L34

using Base.Docs
function hasdoc(mod, name)
    binding = Docs.Binding(mod, name)
    for m in Docs.modules
        meta = Docs.meta(m)
        haskey(meta, binding) &amp;&amp; return true
        (; mod, var) = binding
        isdefined(mod, var) &amp;&amp; haskey(meta, getfield(mod, var)) &amp;&amp; return true
    end
    return false
end

# test simple case
# ================

# a function
function some_reflection_code(@nospecialize(f))
    return any(Base.hasgenerator, methods(f)) # Base.hasgenerator is unstable
end
@report_call analyzer=UnstableAPIAnalyzer some_reflection_code(sin)

# global variable
module foo
bar = 1
end
report_call((Any,); analyzer=UnstableAPIAnalyzer) do a
    foo.bar + a # foo.bar is unstable
end

# supports imported binding, also nested reference (, which will be resolve to `getproperty`)
import Base: hasgenerator
@test report_call((Any,); analyzer=UnstableAPIAnalyzer) do mi
    # every function call appearing here is unstable
    ci = hasgenerator(mi) ? Core.Compiler.get_staged(mi) : Base.uncompressed_ast(mi)
end

# test target
# ===========

# IRTools uses `Base.isgenerator` and leaded to the discussion at https://github.com/JuliaLang/julia/pull/40745#issuecomment-850876150

is_irtools(mod) = occursin(&quot;IRTools&quot;, string(Symbol(mod))) # module context will be virtualized, thus use string match
report_package(&quot;IRTools&quot;; analyzer=UnstableAPIAnalyzer, is_target_module=is_irtools)

end # module find_unstable_api</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/e079637c7aeb9c7e3476b5bbd7d8f9fc0d322204/docs/make.jl#L47-L220">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../internals/">« Internals</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 3 June 2021 05:08">Thursday 3 June 2021</span>. Using Julia version 1.7.0-DEV.1223.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
