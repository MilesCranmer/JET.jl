<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · JET.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">JET.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">README</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Detecting-type-instability-with-@report_opt"><span>Detecting type instability with <code>@report_opt</code></span></a></li><li><a class="tocitem" href="#Analyse-methods-with-@report_call"><span>Analyse methods with <code>@report_call</code></span></a></li><li><a class="tocitem" href="#Analyse-whole-packages-with-report_package"><span>Analyse whole packages with <code>report_package</code></span></a></li><li><a class="tocitem" href="#Usage-tips"><span>Usage tips</span></a></li></ul></li><li><span class="tocitem">Analyses</span><ul><li><a class="tocitem" href="../jetanalysis/">Error Analysis</a></li><li><a class="tocitem" href="../optanalysis/">Optimization Analysis</a></li></ul></li><li><a class="tocitem" href="../config/">Configurations</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><span class="tocitem"><code>AbstractAnalyzer</code> Framework</span><ul><li><a class="tocitem" href="../generated-plugin-api/">API</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../generated-plugin-examples/dispatch_analysis/">Dispatch Analysis</a></li><li><a class="tocitem" href="../generated-plugin-examples/find_unstable_api/">&quot;Unstable API&quot; Analysis</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aviatesk/JET.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="JET-tutorial"><a class="docs-heading-anchor" href="#JET-tutorial">JET tutorial</a><a id="JET-tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#JET-tutorial" title="Permalink"></a></h1><p>JET leverages the Julia compiler&#39;s inference to check user code for type instability and type errors. This tutorial will demonstrate how to use JET effectively. It presupposes the reader has working knowledge of Julia, and understands Julian concepts such as &quot;dynamic dispatch&quot; and &quot;type stability&quot; - see the <a href="https://docs.julialang.org/en/v1/">Julia documentation</a> for explanation of these concepts.</p><p>Because JET relies on the compiler&#39;s type inference, it is not able to effectively analyze type unstable code. Making your code type stable is a prerequisite for effectively using JET&#39;s type error analysis. Therefore, we will begin by showing how to use JET to fix type instabilities.</p><p>First of all, you need to install JET: JET is an ordinary Julia package, so you can install it via Julia&#39;s built-in package manager and use it as like other packages.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ; # ] add JET # install JET via the built-in package manager</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using JET</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><h2 id="Detecting-type-instability-with-@report_opt"><a class="docs-heading-anchor" href="#Detecting-type-instability-with-@report_opt">Detecting type instability with <code>@report_opt</code></a><a id="Detecting-type-instability-with-@report_opt-1"></a><a class="docs-heading-anchor-permalink" href="#Detecting-type-instability-with-@report_opt" title="Permalink"></a></h2><p>JET exports a function <a href="../optanalysis/#JET.report_opt"><code>report_opt</code></a> and the related macro <a href="../optanalysis/#JET.@report_opt"><code>@report_opt</code></a>. It works similar to the function/macro pair <code>(@)code_warntype</code> from Base - except that it automatically analyses all the way down the function chain, and that it only displays any issues found.</p><p>For example, suppose we have the function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_one_first(x) = first(x) + 1;</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Any type instabilities of a given function call can be analysed thus:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_opt add_one_first([1])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_opt add_one_first(Any[1])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ @ REPL[1]:1 </span>%1 Main.:+ 1
<span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">(%1<span class="sgr96">::Any</span> Main.:+ 1)<span class="sgr96">::Any</span></span>
<span class="sgr91">└─────────────</span></code></pre><p>You can see that <code>add_one_first</code> is type stable when called with a <code>Vector{Int}</code>, but it leads to dynamic dispatch when called with <code>Vector{Any}</code>.</p><p>Suppose now we have <em>two levels</em> of type instability, where one type instability &quot;hides behind&quot; another type instability, as in this example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_one_first(x) = first(x) + 1;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; func_var = add_one_first;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x) = func_var(x);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_opt f(Any[1])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr91">┌ @ REPL[3]:1 </span>%1(x)
<span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">%1<span class="sgr96">::Any</span>(x<span class="sgr96">::Vector{Any}</span>)<span class="sgr96">::Any</span></span>
<span class="sgr91">└─────────────</span></code></pre><p>The dynamic dispatch we see here come from the fact that <code>func_var</code> is an untyped global variable. Remember that <code>add_one_first</code> was also type unstable when called with a <code>Vector{Any}</code>. So why doesn&#39;t <code>@report_opt</code> report that second type instability from calling <code>add_one_first(::Vector{Any})</code>? The reason is that because the Julia compiler does not know at compile time that <code>func_var</code> is equal to <code>add_one_first</code>, JET cannot &quot;see through&quot; the first type instability and see that <code>add_one_first(Any[1])</code> will eventually be called.</p><p>If we fix the first instability by defining the global variable <code>my_func_var</code> as <code>const</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; const my_func_var = add_one_first;</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Then the compiler knows that <code>add_one_first</code> will be called, and the second type instability from this function is revealed:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x) = my_func_var(x)</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_opt f(Any[1])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr35">┌ @ REPL[1]:1 </span>Main.my_func_var(x)
<span class="sgr35">│</span><span class="sgr91">┌ @ REPL[1]:1 </span>%1 Main.:+ 1
<span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">(%1<span class="sgr96">::Any</span> Main.:+ 1)<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr91">└─────────────</span></code></pre><p>Sometimes, type instability only shows up much deeper into a call chain, several functions deep. This is not a problem for JET. In the example below, JET sees type instability ~10 function calls deep:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_opt sum(Any[1])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 6 possible errors found ═════</span>
<span class="sgr35">┌ @ reducedim.jl:994 </span>Base.:(var&quot;#sum#811&quot;)(:, pairs(NamedTuple()), #self#, a)
<span class="sgr35">│</span><span class="sgr34">┌ @ reducedim.jl:994 </span>Base._sum(a, dims)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reducedim.jl:998 </span>Base.:(var&quot;#_sum#813&quot;)(pairs(NamedTuple()), #self#, a, _3)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reducedim.jl:998 </span>Base._sum(identity, a, :)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reducedim.jl:999 </span>Base.:(var&quot;#_sum#814&quot;)(pairs(NamedTuple()), #self#, f, a, _4)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reducedim.jl:999 </span>mapreduce(f, Base.add_sum, a)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reducedim.jl:357 </span>Base.:(var&quot;#mapreduce#804&quot;)(:, Base._InitialValue(), #self#, f, op, A)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reducedim.jl:357 </span>Base._mapreduce_dim(f, op, init, A, dims)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reducedim.jl:365 </span>Base._mapreduce(f, op, IndexStyle(A), A)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reduce.jl:447 </span>Base.mapreduce_impl(f, op, A, first(inds), last(inds))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reduce.jl:277 </span>Base.mapreduce_impl(f, op, A, ifirst, ilast, Base.pairwise_blocksize(f, op))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">┌ @ reduce.jl:257 </span>Base.mapreduce_first(f, op, %3)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Base.mapreduce_first(f<span class="sgr96">::typeof(identity)</span>, op<span class="sgr96">::typeof(Base.add_sum)</span>, %3<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">└─────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">┌ @ reduce.jl:262 </span>op(%9, %11)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">op<span class="sgr96">::typeof(Base.add_sum)</span>(%9<span class="sgr96">::Any</span>, %11<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">└─────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">┌ @ reduce.jl:273 </span>op(%69, %71)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">op<span class="sgr96">::typeof(Base.add_sum)</span>(%69<span class="sgr96">::Any</span>, %71<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">└─────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ @ reduce.jl:435 </span>Base.mapreduce_first(f, op, %11)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">Base.mapreduce_first(f<span class="sgr96">::typeof(identity)</span>, op<span class="sgr96">::typeof(Base.add_sum)</span>, %11<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└─────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ @ reduce.jl:440 </span>op(%16, %17)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">op<span class="sgr96">::typeof(Base.add_sum)</span>(%16<span class="sgr96">::Any</span>, %17<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└─────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">┌ @ reduce.jl:443 </span>op(%19, %26)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">│ runtime dispatch detected: </span><span class="sgr1">op<span class="sgr96">::typeof(Base.add_sum)</span>(%19<span class="sgr96">::Any</span>, %26<span class="sgr96">::Any</span>)<span class="sgr96">::Any</span></span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr91">└─────────────────</span></code></pre><p>As mentioned above, effective use of JET begins with liberal use of <code>@report_opt</code> to eliminate or reduce any dynamic dispatch, such that the Julia compiler is not blinded by dynamic dispatch.</p><p>After the program has been made as type stable as possible, it&#39;s time to use <code>@report_call</code> to find type errors.</p><h2 id="Analyse-methods-with-@report_call"><a class="docs-heading-anchor" href="#Analyse-methods-with-@report_call">Analyse methods with <code>@report_call</code></a><a id="Analyse-methods-with-@report_call-1"></a><a class="docs-heading-anchor-permalink" href="#Analyse-methods-with-@report_call" title="Permalink"></a></h2><p>The function/macro pair <a href="../jetanalysis/#JET.report_call"><code>report_call</code></a> and <a href="../jetanalysis/#JET.@report_call"><code>@report_call</code></a> works just like <code>(@)report_opt</code> - but where the latter reports dynamic dispatch, the former finds type errors.</p><p>The <code>@report_call</code> macro analyses function calls like so:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call sum([&#39;a&#39;])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 2 possible errors found ═════</span>
<span class="sgr35">┌ @ reducedim.jl:994 </span>Base.:(var&quot;#sum#811&quot;)(:, pairs(NamedTuple()), #self#, a)
<span class="sgr35">│</span><span class="sgr34">┌ @ reducedim.jl:994 </span>Base._sum(a, dims)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reducedim.jl:998 </span>Base.:(var&quot;#_sum#813&quot;)(pairs(NamedTuple()), #self#, a, _3)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reducedim.jl:998 </span>Base._sum(identity, a, :)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reducedim.jl:999 </span>Base.:(var&quot;#_sum#814&quot;)(pairs(NamedTuple()), #self#, f, a, _4)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reducedim.jl:999 </span>mapreduce(f, Base.add_sum, a)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reducedim.jl:357 </span>Base.:(var&quot;#mapreduce#804&quot;)(:, Base._InitialValue(), #self#, f, op, A)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reducedim.jl:357 </span>Base._mapreduce_dim(f, op, init, A, dims)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reducedim.jl:365 </span>Base._mapreduce(f, op, IndexStyle(A), A)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reduce.jl:432 </span>Base.mapreduce_empty_iter(f, op, A, Base.IteratorEltype(A))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reduce.jl:380 </span>Base.reduce_empty_iter(Base.MappingRF(f, op), itr, ItrEltype)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">┌ @ reduce.jl:384 </span>Base.reduce_empty(op, eltype(itr))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">┌ @ reduce.jl:361 </span>Base.mapreduce_empty(op.f, op.rf, T)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reduce.jl:372 </span>Base.reduce_empty(op, T)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">┌ @ reduce.jl:352 </span>Base.reduce_empty(+, T)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">┌ @ reduce.jl:343 </span>zero(T)
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">│ no matching method found `zero(::Type{Char})`: </span><span class="sgr1">zero(T<span class="sgr96">::Type{Char}</span>)</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr91">└─────────────────</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">┌ @ reduce.jl:440 </span>s = op(f(a1), f(a2))
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">┌ @ reduce.jl:24 </span>x + y
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">│ no matching method found `+(::Char, ::Char)`: </span><span class="sgr1">(x<span class="sgr96">::Char</span> + y<span class="sgr96">::Char</span>)</span>
<span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr33">│</span><span class="sgr32">│</span><span class="sgr35">│</span><span class="sgr34">│</span><span class="sgr91">└────────────────</span></code></pre><p>In this example, JET found two possible type errors:</p><ul><li>If the input vector is empty, the function call will error with a <code>MethodError</code> after attempting to call <code>zero(Char)</code>.</li><li>If the input vector has two or more elements, the call will error after attempting to call <code>+(::Char, ::Char)</code>.</li></ul><p>Note that these type errors show up even though the input vector had exactly one element, and so neither of these errors would actually occur at runtime if <code>sum([&#39;a&#39;])</code> had been executed. This happens because JET analyses the code on a <em>type</em> level, only looking at the code generated with the input <em>types</em>. It does not analyze what will actually happen with the given input value.</p><p>Note also that the two possible errors shown are mutally exclusive - no input will lead to both errors. Nonetheless, JET is able to detect both possibilities, because it analyses all possible branches in the generated function call.</p><p>In contrast, if we analyse the same <code>sum</code> method on a <code>Vector{Int}</code> instead of <code>Vector{Char}</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call sum([1])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code></pre><p>The two errors above do not appear. These errors do not apply to <code>Vector{Int}</code>, because <code>zero(Int)</code> is well-defined and so is <code>+(::Int, ::Int)</code>. This illustrates that JET does not analyze <em>methods</em>, but rather <em>function calls with specific types</em>. More precisely, JET analyses so-called <em>methodinstances</em>, since methodinstances are compiled whereas methods are not.</p><h2 id="Analyse-whole-packages-with-report_package"><a class="docs-heading-anchor" href="#Analyse-whole-packages-with-report_package">Analyse whole packages with <code>report_package</code></a><a id="Analyse-whole-packages-with-report_package-1"></a><a class="docs-heading-anchor-permalink" href="#Analyse-whole-packages-with-report_package" title="Permalink"></a></h2><p>As shown above, <em>methods</em> cannot be analyzed, but only <em>methodinstances</em>, i.e. methods plus the types of their arguments. Most packages, however, define only methods, and do not contain callsites. That is, they do not have any information about the types that these methods will be called with.</p><p>However, JET is able to do limited analysis using only the method signature extracted from the method definition. For example, if I define this simple function:</p><pre><code class="language-julia hljs">first_plus_n(itr, n::Real) = first(itr) + n;</code></pre><p>, then <em>at the very least</em>, we can guarantee that <code>itr isa Any</code> and <code>n isa Real</code>. Hence, JET can analyze the methodinstance <code>first_plus_n(::Any, ::Real)</code>, using only the method definition.</p><p>The JET function <a href="../jetanalysis/#JET.report_package"><code>report_package</code></a> extracts all method definitions in a package, and using the extracted signatures, runs <code>report_call</code> on them. For example, the package <code>BioSymbols</code> can be analysed like this:</p><pre><code class="language-julia hljs">julia&gt; using JET

julia&gt; report_package(BioSymbols)
[ output elided ]</code></pre><p>Note that <code>report_package</code> is less precise than <code>@report_call</code>, because method signatures of idiomatic Julia code are often very generic, so there is less type information in the signature itself than there is when given concrete argument types.</p><h2 id="Usage-tips"><a class="docs-heading-anchor" href="#Usage-tips">Usage tips</a><a id="Usage-tips-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-tips" title="Permalink"></a></h2><h4 id="Use-@report_opt-before-@report_call"><a class="docs-heading-anchor" href="#Use-@report_opt-before-@report_call">Use <code>@report_opt</code> before <code>@report_call</code></a><a id="Use-@report_opt-before-@report_call-1"></a><a class="docs-heading-anchor-permalink" href="#Use-@report_opt-before-@report_call" title="Permalink"></a></h4><p>JET works best on type-stable code. Iron out type instabilities using <code>@report_opt</code> before using <code>@report_call</code></p><h4 id="Filtering-away-false-postives"><a class="docs-heading-anchor" href="#Filtering-away-false-postives">Filtering away false postives</a><a id="Filtering-away-false-postives-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-away-false-postives" title="Permalink"></a></h4><p>It is common to find that JET finds lots of errors in your functions, which all derive from type instability and type issues in your dependencies. In fact, type issues from dependencies are often so plentiful they flood your analysis with false positives, which can make working with JET harder.</p><p>To reduce false positives, you can use the keywords <code>ignored_modules</code> and <code>target_modules</code>.Both take an iterable of modules.</p><p>The former removes any errors that originate from any of the given modules, while the latter removes any errors <em>except</em> ones originating from these modules.</p><p>For example, in the REPL (which is in module <code>Main</code>), we can define:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; g(x) = first(x) + 1</code><code class="nohighlight hljs ansi" style="display:block;">g (generic function with 1 method)</code></pre><p>This throws in a <code>Base</code> function if we pass <code>nothing</code> into it:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call g(nothing)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr7">═════ 1 possible error found ═════</span>
<span class="sgr35">┌ @ REPL[1]:1 </span>Main.first(x)
<span class="sgr35">│</span><span class="sgr91">┌ @ abstractarray.jl:465 </span>x = iterate(itr)
<span class="sgr35">│</span><span class="sgr91">│ no matching method found `iterate(::Nothing)`: </span><span class="sgr1">x = iterate(itr<span class="sgr96">::Nothing</span>)</span>
<span class="sgr35">│</span><span class="sgr91">└────────────────────────</span></code></pre><p>Since the error originates from <code>Base</code>, we can filter the error away by ignoring <code>Base</code>, or equivalently, we may retain only the ones from <code>Main</code>. Note that we pass <code>(Base,)</code> as a 1-element Tuple of modules:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call ignored_modules=(Base,) g(nothing)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call target_modules=(@__MODULE__,) g(nothing)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code></pre><p>The <code>AnyFrameModule</code> construct can be used to filter for (or against) any error where <em>any</em> of the function calls in the callchain originates from the given module. For example, in the example above, the function call begins in <code>Main</code> and ends in <code>Base</code>, so the callchain includes both modules. Ignoring <code>AnyFrameModule(Base)</code> <em>or</em> <code>AnyFrameModule(Main)</code> will then ignore the error:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call ignored_modules=(AnyFrameModule(Base),) g(nothing)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @report_call ignored_modules=(AnyFrameModule(@__MODULE__),) g(nothing)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92">No errors detected</span></code></pre><p>Similarly, the error would be retained if <code>target_modules</code> would have been <code>AnyFrameModule(Base)</code> <em>or</em> <code>AnyFrameModule(Main)</code>.</p><p>Beware that this filtering may filter away legitimate problems in your package. In the example above, if your code calls <code>f(nothing)</code>, the error may originate from Base, but it&#39;s clearly an error in your own code to call <code>f(nothing)</code>. So it is recommended to only filter away modules if they produce so many false positives that it makes using JET difficult.</p><h4 id="Analyze-scripts-and-apps-by-using-a-main-function"><a class="docs-heading-anchor" href="#Analyze-scripts-and-apps-by-using-a-main-function">Analyze scripts and apps by using a <code>main</code> function</a><a id="Analyze-scripts-and-apps-by-using-a-main-function-1"></a><a class="docs-heading-anchor-permalink" href="#Analyze-scripts-and-apps-by-using-a-main-function" title="Permalink"></a></h4><p>Scripts and apps called from the command line have a single logical entry point. If you wrap the logic in a <code>main</code> function, JET can analyse the entire script.</p><p>For example, suppose you made this command-line script which added two numbers from the command line:</p><pre><code class="language-julia hljs">a = parse(Int, first(ARGS))
b = parse(Int, last(ARGS))
println(a + b)</code></pre><p>You could rewrite this as:</p><pre><code class="language-julia hljs">function main()
    a = parse(Int, first(ARGS))
    b = parse(Int, last(ARGS))
    println(a + b)
end

main()</code></pre><p>, and then analyse the script with JET using <code>@report_call main()</code>. Using a <code>main</code> function has the further advantage that it makes it for other people to understand what your script does when invoked.</p><p>Alternatively, JET also provides the function <a href="../jetanalysis/#JET.report_file"><code>report_file</code></a>, which you can call like:</p><pre><code class="language-julia hljs">julia&gt; report_file(&quot;my_script.jl&quot;)</code></pre><p>, which will be equivalent to checking <code>@report_call main()</code>, if the script contains a <code>main()</code> call at top level.</p><h4 id="Analyze-packages-using-a-representative-workload"><a class="docs-heading-anchor" href="#Analyze-packages-using-a-representative-workload">Analyze packages using a representative workload</a><a id="Analyze-packages-using-a-representative-workload-1"></a><a class="docs-heading-anchor-permalink" href="#Analyze-packages-using-a-representative-workload" title="Permalink"></a></h4><p>As shown above, packages can be analysed with <code>report_package</code>. However, generic type signatures often used in packages lead to imprecise inference and thus imprecise analysis.</p><p>To improve analysis, you can create a file <code>src/workload.jl</code> in your package, which uses all (or most) functionality of the pacakge. The function could look like:</p><pre><code class="language-julia hljs">function exercise_mypkg()
    data = MyPkg.load_data()
    transformed = MyPkg.transform_data(data)
    # [ etc ...]
end</code></pre><p>Because such usage necessarily requires passing concrete types to your functions, calling <code>@report_call exercise_mypkg()</code> leads to more precise analysis than <code>report_package</code>.</p><p>Furthermore, once you have written a function like <code>exercise_mypkg</code>, you can use a package like <a href="https://github.com/timholy/SnoopCompile.jl"><code>SnoopPrecompile</code></a> to precompile the function, which will thus precompile all code exercised in the function, significantly reducing your package&#39;s latency.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« README</a><a class="docs-footer-nextpage" href="../jetanalysis/">Error Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 8 December 2022 07:58">Thursday 8 December 2022</span>. Using Julia version 1.10.0-DEV.112.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
