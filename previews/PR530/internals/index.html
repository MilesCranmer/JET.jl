<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · JET.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">JET.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">README</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><span class="tocitem">Analyses</span><ul><li><a class="tocitem" href="../jetanalysis/">Error Analysis</a></li><li><a class="tocitem" href="../optanalysis/">Optimization Analysis</a></li></ul></li><li><a class="tocitem" href="../config/">Configurations</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#abstractinterpret"><span>Abstract Interpretation</span></a></li><li><a class="tocitem" href="#toplevel"><span>Top-level Analysis</span></a></li><li><a class="tocitem" href="#analysis-result"><span>Analysis Result</span></a></li><li><a class="tocitem" href="#Error-Report-Interface"><span>Error Report Interface</span></a></li></ul></li><li><span class="tocitem"><code>AbstractAnalyzer</code> Framework</span><ul><li><a class="tocitem" href="../generated-plugin-api/">API</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../generated-plugin-examples/dispatch_analysis/">Dispatch Analysis</a></li><li><a class="tocitem" href="../generated-plugin-examples/find_unstable_api/">&quot;Unstable API&quot; Analysis</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aviatesk/JET.jl/blob/master/docs/src/internals.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Internals-of-JET.jl"><a class="docs-heading-anchor" href="#Internals-of-JET.jl">Internals of JET.jl</a><a id="Internals-of-JET.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Internals-of-JET.jl" title="Permalink"></a></h1><h2 id="abstractinterpret"><a class="docs-heading-anchor" href="#abstractinterpret">Abstract Interpretation</a><a id="abstractinterpret-1"></a><a class="docs-heading-anchor-permalink" href="#abstractinterpret" title="Permalink"></a></h2><p>In order to perform type-level program analysis, JET.jl uses <a href="https://github.com/JuliaLang/julia/blob/master/base/compiler/types.jl"><code>Core.Compiler.AbstractInterpreter</code> interface</a>, and customizes its abstract interpretation by overloading a subset of <code>Core.Compiler</code> functions, that are originally developed for Julia compiler&#39;s type inference and optimizations that aim at generating efficient native code for CPU execution.</p><p><a href="../generated-plugin-api/#JET.AbstractAnalyzer"><code>JET.AbstractAnalyzer</code></a> overloads a set of <code>Core.Compiler</code> functions to implement the &quot;core&quot; functionalities of JET&#39;s analysis, including inter-procedural error report propagation and caching of the analysis result. And each plugin analyzer (e.g. <a href="../jetanalysis/#JET.JETAnalyzer"><code>JET.JETAnalyzer</code></a>) will overload more <code>Core.Compiler</code> functions so that it can perform its own program analysis on top of the core <code>AbstractAnalyzer</code> infrastructure.</p><p>Most overloads use the <a href="https://docs.julialang.org/en/v1/base/base/#Core.invoke"><code>invoke</code></a> reflection, which allows <code>AbstractAnalyzer</code> to dispatch to the original <code>AbstractInterpreter</code>&#39;s abstract interpretation methods while still passing <code>AbstractAnalyzer</code> to the subsequent (maybe overloaded) callees.</p><article class="docstring"><header><a class="docstring-binding" id="JET.AnalysisResult" href="#JET.AnalysisResult"><code>JET.AnalysisResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnalysisResult</code></pre><p><a href="../generated-plugin-api/#JET.AbstractAnalyzer"><code>analyzer::AbstractAnalyzer</code></a> manages <a href="../generated-plugin-api/#JET.InferenceErrorReport"><code>InferenceErrorReport</code></a> by associating it with <code>InferenceResult</code>. <code>InferenceErrorReport</code>s found within the currently-analyzed <code>result::InferenceResult</code> can be accessed using <code>get_reports(analyzer, result)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/2a2cc9a64549983b99caad01adaf6c1edfc936dd/src/abstractinterpret/abstractanalyzer.jl#L55-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.islineage" href="#JET.islineage"><code>JET.islineage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">islineage(parent::MethodInstance, current::MethodInstance) -&gt;
    (report::InferenceErrorReport) -&gt; Bool</code></pre><p>Returns a function that checks if a given <code>InferenceErrorReport</code></p><ul><li>is generated from <code>current</code>, and</li><li>is &quot;lineage&quot; of <code>parent</code> (i.e. entered from it).</li></ul><p>This function is supposed to be used when additional analysis with extended lattice information happens in order to filter out reports collected from <code>current</code> by analysis without using that extended information. When a report should be filtered out, the first virtual stack frame represents <code>parent</code> and the second does <code>current</code>.</p><p>Example:</p><pre><code class="nohighlight hljs">entry
└─ linfo1 (report1: linfo1-&gt;linfo2)
   ├─ linfo2 (report1: linfo2)
   ├─ linfo3 (report2: linfo3-&gt;linfo2)
   │  └─ linfo2 (report2: linfo2)
   └─ linfo3′ (~~report2: linfo3-&gt;linfo2~~)</code></pre><p>In the example analysis above, <code>report2</code> should be filtered out on re-entering into <code>linfo3′</code> (i.e. when we&#39;re analyzing <code>linfo3</code> with constant arguments), nevertheless <code>report1</code> shouldn&#39;t because it is not detected within <code>linfo3</code> but within <code>linfo1</code> (so it&#39;s not a &quot;lineage of <code>linfo3</code>&quot;):</p><ul><li><code>islineage(linfo1, linfo3)(report2) === true</code></li><li><code>islineage(linfo1, linfo3)(report1) === false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/2a2cc9a64549983b99caad01adaf6c1edfc936dd/src/abstractinterpret/typeinfer.jl#L423-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Compiler.bail_out_toplevel_call" href="#Core.Compiler.bail_out_toplevel_call"><code>Core.Compiler.bail_out_toplevel_call</code></a> — <span class="docstring-category">Function</span></header><section><div><p>By default <code>AbstractInterpreter</code> implements the following inference bail out logic:</p><ul><li><code>bail_out_toplevel_call(::AbstractInterpreter, sig, ::InferenceState)</code>: bail out from  inter-procedural inference when inferring top-level and non-concrete call site <code>callsig</code></li><li><code>bail_out_call(::AbstractInterpreter, rt, ::InferenceState)</code>: bail out from inter-procedural  inference when return type <code>rt</code> grows up to <code>Any</code></li><li><code>bail_out_apply(::AbstractInterpreter, rt, ::InferenceState)</code>: bail out from <code>_apply_iterate</code> inference when return type <code>rt</code> grows up to <code>Any</code></li></ul><p>It also bails out from local statement/frame inference when any lattice element gets down to <code>Bottom</code>, but <code>AbstractInterpreter</code> doesn&#39;t provide a specific interface for configuring it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/e0761b3b953fc4b1fb27dac840158119f26882cd/base/compiler/types.jl#L441-L452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Compiler.bail_out_call" href="#Core.Compiler.bail_out_call"><code>Core.Compiler.bail_out_call</code></a> — <span class="docstring-category">Function</span></header><section><div><p>By default <code>AbstractInterpreter</code> implements the following inference bail out logic:</p><ul><li><code>bail_out_toplevel_call(::AbstractInterpreter, sig, ::InferenceState)</code>: bail out from  inter-procedural inference when inferring top-level and non-concrete call site <code>callsig</code></li><li><code>bail_out_call(::AbstractInterpreter, rt, ::InferenceState)</code>: bail out from inter-procedural  inference when return type <code>rt</code> grows up to <code>Any</code></li><li><code>bail_out_apply(::AbstractInterpreter, rt, ::InferenceState)</code>: bail out from <code>_apply_iterate</code> inference when return type <code>rt</code> grows up to <code>Any</code></li></ul><p>It also bails out from local statement/frame inference when any lattice element gets down to <code>Bottom</code>, but <code>AbstractInterpreter</code> doesn&#39;t provide a specific interface for configuring it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/e0761b3b953fc4b1fb27dac840158119f26882cd/base/compiler/types.jl#L441-L452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Compiler.add_call_backedges!" href="#Core.Compiler.add_call_backedges!"><code>Core.Compiler.add_call_backedges!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_call_backedges!(analyzer::JETAnalyzer, ...)</code></pre><p>An overload for <code>abstract_call_gf_by_type(analyzer::JETAnalyzer, ...)</code>, which always add backedges (even if a new method can&#39;t refine the return type grew up to <code>Any</code>). This is because a new method definition always has a potential to change <code>JETAnalyzer</code>&#39;s analysis result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/2a2cc9a64549983b99caad01adaf6c1edfc936dd/src/analyzers/jetanalyzer.jl#L279-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Compiler.const_prop_entry_heuristic" href="#Core.Compiler.const_prop_entry_heuristic"><code>Core.Compiler.const_prop_entry_heuristic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">const_prop_entry_heuristic(analyzer::JETAnalyzer, result::MethodCallResult, sv::InferenceState)</code></pre><p>This overload forces constant prop&#39; even if an inference result can&#39;t be improved anymore <em>with respect to the return type</em>, e.g. when <code>result.rt</code> is already <code>Const</code>. Especially, this overload implements an heuristic to force constant prop&#39; when any error points have been reported while the previous abstract method call without constant arguments. The reason we want much more aggressive constant propagation by that heuristic is that it&#39;s highly possible constant prop&#39; can produce more accurate analysis result, by throwing away false positive error reports by cutting off the unreachable control flow or detecting must-reachable <code>throw</code> calls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/2a2cc9a64549983b99caad01adaf6c1edfc936dd/src/analyzers/jetanalyzer.jl#L297-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.analyze_task_parallel_code!" href="#JET.analyze_task_parallel_code!"><code>JET.analyze_task_parallel_code!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">analyze_task_parallel_code!(analyzer::AbstractAnalyzer, argtypes::Argtypes, sv::InferenceState)</code></pre><p>Adds special cased analysis pass for task parallelism. In Julia&#39;s task parallelism implementation, parallel code is represented as closure and it&#39;s wrapped in a <code>Task</code> object. <code>Core.Compiler.NativeInterpreter</code> doesn&#39;t infer nor optimize the bodies of those closures when compiling code that creates parallel tasks, but JET will try to run additional analysis pass by recurring into the closures.</p><p>See also: <a href="https://github.com/aviatesk/JET.jl/issues/114">https://github.com/aviatesk/JET.jl/issues/114</a></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>JET won&#39;t do anything other than doing JET analysis, e.g. won&#39;t annotate return type of wrapped code block in order to not confuse the original <code>AbstractInterpreter</code> routine track <a href="https://github.com/JuliaLang/julia/pull/39773">https://github.com/JuliaLang/julia/pull/39773</a> for the changes in native abstract interpretation routine.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/2a2cc9a64549983b99caad01adaf6c1edfc936dd/src/abstractinterpret/typeinfer.jl#L106-L122">source</a></section></article><h3 id="How-AbstractAnalyzer-manages-caches"><a class="docs-heading-anchor" href="#How-AbstractAnalyzer-manages-caches">How <code>AbstractAnalyzer</code> manages caches</a><a id="How-AbstractAnalyzer-manages-caches-1"></a><a class="docs-heading-anchor-permalink" href="#How-AbstractAnalyzer-manages-caches" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>JET.AnalysisCache</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="JET.CachedAnalysisResult" href="#JET.CachedAnalysisResult"><code>JET.CachedAnalysisResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CachedAnalysisResult</code></pre><p><a href="#JET.AnalysisResult"><code>AnalysisResult</code></a> is transformed into <code>CachedAnalysisResult</code> when it is cached into a global cache maintained by <code>AbstractAnalyzer</code>. That means, <code>codeinf::CodeInstance = Core.Compiler.code_cache(analyzer::AbstractAnalyzer)[mi::MethodInstance])</code> is expected to have its field <code>codeinf.inferred::CachedAnalysisResult</code>.</p><p><a href="../generated-plugin-api/#JET.InferenceErrorReport"><code>InferenceErrorReport</code></a>s found within already-analyzed <code>result::InferenceResult</code> can be accessed with <code>get_cached_reports(analyzer, result)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/2a2cc9a64549983b99caad01adaf6c1edfc936dd/src/abstractinterpret/abstractanalyzer.jl#L67-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Compiler.inlining_policy" href="#Core.Compiler.inlining_policy"><code>Core.Compiler.inlining_policy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inlining_policy(analyzer::AbstractAnalyzer, @nospecialize(src), ...) -&gt; source::Any</code></pre><p>Implements inlining policy for <code>AbstractAnalyzer</code>. Since <code>AbstractAnalyzer</code> works on <code>InferenceResult</code> whose <code>src</code> field keeps <a href="#JET.AnalysisResult"><code>AnalysisResult</code></a> or <a href="#JET.CachedAnalysisResult"><code>CachedAnalysisResult</code></a>, this implementation needs to forward their wrapped source to <code>inlining_policy(::AbstractInterpreter, ::Any, ::UInt8)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/2a2cc9a64549983b99caad01adaf6c1edfc936dd/src/abstractinterpret/abstractanalyzer.jl#L631-L638">source</a></section></article><h2 id="toplevel"><a class="docs-heading-anchor" href="#toplevel">Top-level Analysis</a><a id="toplevel-1"></a><a class="docs-heading-anchor-permalink" href="#toplevel" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JET.virtual_process" href="#JET.virtual_process"><code>JET.virtual_process</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">virtual_process(s::AbstractString,
                filename::AbstractString,
                pkgid::Union{Nothing,Base.PkgId},
                analyzer::AbstractAnalyzer,
                config::ToplevelConfig) -&gt; res::VirtualProcessResult</code></pre><p>Simulates Julia&#39;s toplevel execution and collects error points, and finally returns <code>res::VirtualProcessResult</code></p><ul><li><code>res.included_files::Set{String}</code>: files that have been analyzed</li><li><code>res.defined_modules::Set{Module}</code>: module contexts created while this top-level analysis</li><li><code>res.toplevel_error_reports::Vector{ToplevelErrorReport}</code>: toplevel errors found during the   text parsing or partial (actual) interpretation; these reports are &quot;critical&quot; and should   have precedence over <code>inference_error_reports</code></li><li><code>res.inference_error_reports::Vector{InferenceErrorReport}</code>: possible error reports found   by <code>AbstractAnalyzer</code></li><li><code>res.toplevel_signatures</code>: signatures of methods defined within the analyzed files</li><li><code>res.actual2virtual::Pair{Module, Module}</code>: keeps actual and virtual module</li></ul><p>This function first parses <code>s::AbstractString</code> into <code>toplevelex::Expr</code> and then iterate the following steps on each code block (<code>blk</code>) of <code>toplevelex</code>:</p><ol><li>if <code>blk</code> is a <code>:module</code> expression, recursively enters analysis into an newly defined virtual module</li><li><code>lower</code>s <code>blk</code> into <code>:thunk</code> expression <code>lwr</code> (macros are also expanded in this step)</li><li>if the context module is virtualized, replaces self-references of the original context module with virtualized one: see <code>fix_self_references</code></li><li><code>ConcreteInterpreter</code> partially interprets some statements in <code>lwr</code> that should not be abstracted away (e.g. a <code>:method</code> definition); see also <a href="#JET.partially_interpret!"><code>partially_interpret!</code></a></li><li>finally, <code>AbstractAnalyzer</code> analyzes the remaining statements by abstract interpretation</li></ol><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>In order to process the toplevel code sequentially as Julia runtime does, <code>virtual_process</code> splits the entire code, and then iterate a simulation process on each code block. With this approach, we can&#39;t track the inter-code-block level dependencies, and so a partial interpretation of toplevle definitions will fail if it needs an access to global variables defined in other code blocks that are not interpreted but just abstracted. We can circumvent this issue using JET&#39;s <code>concretization_patterns</code> configuration, which allows us to customize JET&#39;s concretization strategy. See <a href="../config/#JET.ToplevelConfig"><code>ToplevelConfig</code></a> for more details.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/2a2cc9a64549983b99caad01adaf6c1edfc936dd/src/toplevel/virtualprocess.jl#L365-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.VirtualProcessResult" href="#JET.VirtualProcessResult"><code>JET.VirtualProcessResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">res::VirtualProcessResult</code></pre><ul><li><code>res.included_files::Set{String}</code>: files that have been analyzed</li><li><code>res.defined_modules::Set{Module}</code>: module contexts created while this top-level analysis</li><li><code>res.toplevel_error_reports::Vector{ToplevelErrorReport}</code>: toplevel errors found during the   text parsing or partial (actual) interpretation; these reports are &quot;critical&quot; and should   have precedence over <code>inference_error_reports</code></li><li><code>res.inference_error_reports::Vector{InferenceErrorReport}</code>: possible error reports found   by <code>AbstractAnalyzer</code></li><li><code>res.toplevel_signatures</code>: signatures of methods defined within the analyzed files</li><li><code>res.actual2virtual::Pair{Module, Module}</code>: keeps actual and virtual module</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/2a2cc9a64549983b99caad01adaf6c1edfc936dd/src/toplevel/virtualprocess.jl#L331-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.virtualize_module_context" href="#JET.virtualize_module_context"><code>JET.virtualize_module_context</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">virtualize_module_context(actual::Module)</code></pre><p>HACK to return a module where the context of <code>actual</code> is virtualized.</p><p>The virtualization will be done by 2 steps below:</p><ol><li>loads the module context of <code>actual</code> into a sandbox module, and export the whole context from there</li><li>then uses names exported from the sandbox</li></ol><p>This way, JET&#39;s runtime simulation in the virtual module context will be able to define a name that is already defined in <code>actual</code> without causing &quot;cannot assign a value to variable ... from module ...&quot; error, etc. It allows JET to virtualize the context of already-existing module other than <code>Main</code>.</p><div class="admonition is-warning"><header class="admonition-header">TODO</header><div class="admonition-body"><p>Currently this function relies on <code>Base.names</code>, and thus it can&#39;t restore the <code>using</code>ed names.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/2a2cc9a64549983b99caad01adaf6c1edfc936dd/src/toplevel/virtualprocess.jl#L453-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.ConcreteInterpreter" href="#JET.ConcreteInterpreter"><code>JET.ConcreteInterpreter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConcreteInterpreter</code></pre><p>The trait to inject code into JuliaInterpreter&#39;s interpretation process; JET.jl overloads:</p><ul><li><code>JuliaInterpreter.step_expr!</code> to add error report pass for module usage expressions and support package analysis</li><li><code>JuliaInterpreter.evaluate_call_recurse!</code> to special case <code>include</code> calls</li><li><code>JuliaInterpreter.handle_err</code> to wrap an error happened during interpretation into <code>ActualErrorWrapped</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/2a2cc9a64549983b99caad01adaf6c1edfc936dd/src/toplevel/virtualprocess.jl#L974-L983">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.partially_interpret!" href="#JET.partially_interpret!"><code>JET.partially_interpret!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">partially_interpret!(interp::ConcreteInterpreter, mod::Module, src::CodeInfo)</code></pre><p>Partially interprets statements in <code>src</code> using JuliaInterpreter.jl:</p><ul><li>concretizes &quot;toplevel definitions&quot;, i.e. <code>:method</code>, <code>:struct_type</code>, <code>:abstract_type</code> and <code>:primitive_type</code> expressions and their dependencies</li><li>concretizes user-specified toplevel code (see <a href="../config/#JET.ToplevelConfig"><code>ToplevelConfig</code></a>)</li><li>directly evaluates module usage expressions and report error of invalid module usages (TODO: enter into the loaded module and keep JET analysis)</li><li>special-cases <code>include</code> calls so that top-level analysis recursively enters the included file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/2a2cc9a64549983b99caad01adaf6c1edfc936dd/src/toplevel/virtualprocess.jl#L995-L1005">source</a></section></article><h3 id="How-top-level-analysis-is-bridged-to-AbstractAnalyzer"><a class="docs-heading-anchor" href="#How-top-level-analysis-is-bridged-to-AbstractAnalyzer">How top-level analysis is bridged to <code>AbstractAnalyzer</code></a><a id="How-top-level-analysis-is-bridged-to-AbstractAnalyzer-1"></a><a class="docs-heading-anchor-permalink" href="#How-top-level-analysis-is-bridged-to-AbstractAnalyzer" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JET.AbstractGlobal" href="#JET.AbstractGlobal"><code>JET.AbstractGlobal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct AbstractGlobal
    t::Any     # analyzed type
    isconst::Bool # is this abstract global variable declarared as constant or not
end</code></pre><p>Wraps a global variable whose type is analyzed by abstract interpretation. <code>AbstractGlobal</code> object will be actually evaluated into the context module, and a later analysis may refer to or alter its type on future load and store operations.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The type of the wrapped global variable will be propagated only when in a toplevel frame, and thus we don&#39;t care about the analysis cache invalidation on a refinement of the wrapped global variable, since JET doesn&#39;t cache the toplevel frame.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/2a2cc9a64549983b99caad01adaf6c1edfc936dd/src/abstractinterpret/typeinfer.jl#L559-L573">source</a></section></article><h2 id="analysis-result"><a class="docs-heading-anchor" href="#analysis-result">Analysis Result</a><a id="analysis-result-1"></a><a class="docs-heading-anchor-permalink" href="#analysis-result" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JET.JETToplevelResult" href="#JET.JETToplevelResult"><code>JET.JETToplevelResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">res::JETToplevelResult</code></pre><p>Represents the result of JET&#39;s analysis on a top-level script.</p><ul><li><code>res.analyzer::AbstractAnalyzer</code>: <a href="../generated-plugin-api/#JET.AbstractAnalyzer"><code>AbstractAnalyzer</code></a> used for this analysis</li><li><code>res.res::VirtualProcessResult</code>: <a href="#JET.VirtualProcessResult"><code>VirtualProcessResult</code></a> collected from this analysis</li><li><code>res.source::AbstractString</code>: the identity key of this analysis</li><li><code>res.jetconfigs</code>: configurations used for this analysis</li></ul><p><code>JETToplevelResult</code> implements <code>show</code> methods for each different frontend. An appropriate <code>show</code> method will be automatically chosen and render the analysis result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/2a2cc9a64549983b99caad01adaf6c1edfc936dd/src/JET.jl#L449-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.JETCallResult" href="#JET.JETCallResult"><code>JET.JETCallResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">res::JETCallResult</code></pre><p>Represents the result of JET&#39;s analysis on a function call.</p><ul><li><code>res.result::InferenceResult</code>: the result of this analysis</li><li><code>res.analyzer::AbstractAnalyzer</code>: <a href="../generated-plugin-api/#JET.AbstractAnalyzer"><code>AbstractAnalyzer</code></a> used for this analysis</li><li><code>res.source::AbstractString</code>: the identity key of this analysis</li><li><code>res.jetconfigs</code>: configurations used for this analysis</li></ul><p><code>JETCallResult</code> implements <code>show</code> methods for each different frontend. An appropriate <code>show</code> method will be automatically chosen and render the analysis result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/2a2cc9a64549983b99caad01adaf6c1edfc936dd/src/JET.jl#L489-L500">source</a></section></article><h2 id="Error-Report-Interface"><a class="docs-heading-anchor" href="#Error-Report-Interface">Error Report Interface</a><a id="Error-Report-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Report-Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JET.VirtualFrame" href="#JET.VirtualFrame"><code>JET.VirtualFrame</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VirtualFrame</code></pre><p>Stack information representing virtual execution context:</p><ul><li><code>file::Symbol</code>: the path to the file containing the virtual execution context</li><li><code>line::Int</code>: the line number in the file containing the virtual execution context</li><li><a href="#JET.Signature"><code>sig::Signature</code></a>: a signature of this frame</li><li><code>linfo::MethodInstance</code>: The <code>MethodInstance</code> containing the execution context</li></ul><p>This type is very similar to <code>Base.StackTraces.StackFrame</code>, but its execution context is collected during abstract interpration, not collected from actual execution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/2a2cc9a64549983b99caad01adaf6c1edfc936dd/src/abstractinterpret/inferenceerrorreport.jl#L38-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.VirtualStackTrace" href="#JET.VirtualStackTrace"><code>JET.VirtualStackTrace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VirtualStackTrace</code></pre><p>Represents a virtual stack trace in the form of a vector of <code>VirtualFrame</code>. The vector holds <code>VirtualFrame</code>s in order of &quot;from entry call site to error point&quot;, i.e. the first element is the <code>VirtualFrame</code> of the entry call site, and the last element is that contains the error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/2a2cc9a64549983b99caad01adaf6c1edfc936dd/src/abstractinterpret/inferenceerrorreport.jl#L56-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.Signature" href="#JET.Signature"><code>JET.Signature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Signature</code></pre><p>Represents an expression signature. <code>print_signature</code> implements a frontend functionality to show this type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/2a2cc9a64549983b99caad01adaf6c1edfc936dd/src/abstractinterpret/inferenceerrorreport.jl#L7-L12">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>JET.InferenceErrorReport</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="JET.ToplevelErrorReport" href="#JET.ToplevelErrorReport"><code>JET.ToplevelErrorReport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ToplevelErrorReport</code></pre><p>An interface type of error reports that JET collects while top-level concrete interpration. All <code>ToplevelErrorReport</code> should have the following fields:</p><ul><li><code>file::String</code>: the path to the file containing the interpretation context</li><li><code>line::Int</code>: the line number in the file containing the interpretation context</li></ul><p>See also: <a href="#JET.virtual_process"><code>virtual_process</code></a>, <a href="#JET.ConcreteInterpreter"><code>ConcreteInterpreter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/2a2cc9a64549983b99caad01adaf6c1edfc936dd/src/toplevel/virtualprocess.jl#L1-L10">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../config/">« Configurations</a><a class="docs-footer-nextpage" href="../generated-plugin-api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 1 June 2023 14:17">Thursday 1 June 2023</span>. Using Julia version 1.10.0-DEV.1418.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
