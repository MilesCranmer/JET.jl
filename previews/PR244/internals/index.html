<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · JET.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JET.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">README</a></li><li><a class="tocitem" href="../usages/">Usages</a></li><li><a class="tocitem" href="../config/">Configurations</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#abstractinterpret"><span>Abstract Interpretation</span></a></li><li><a class="tocitem" href="#toplevel"><span>Top-level Analysis</span></a></li><li><a class="tocitem" href="#Analysis-Results"><span>Analysis Results</span></a></li><li><a class="tocitem" href="#Error-Report-Interface"><span>Error Report Interface</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><span class="tocitem">JET Analyzer Framework</span><ul><li><a class="tocitem" href="../generated-plugin-api/">API</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../generated-plugin-examples/dispatch_analysis/">Dispatch Analysis</a></li><li><a class="tocitem" href="../generated-plugin-examples/find_unstable_api/">&quot;Unstable API&quot; Analysis</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aviatesk/JET.jl/blob/master/docs/src/internals.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Internals-of-JET.jl"><a class="docs-heading-anchor" href="#Internals-of-JET.jl">Internals of JET.jl</a><a id="Internals-of-JET.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Internals-of-JET.jl" title="Permalink"></a></h1><h2 id="abstractinterpret"><a class="docs-heading-anchor" href="#abstractinterpret">Abstract Interpretation</a><a id="abstractinterpret-1"></a><a class="docs-heading-anchor-permalink" href="#abstractinterpret" title="Permalink"></a></h2><p>In order to perform type level program analysis, JET.jl uses <a href="https://github.com/JuliaLang/julia/blob/master/base/compiler/types.jl"><code>Core.Compiler.AbstractInterpreter</code> interface</a>, and customizes its abstract interpretation by overloading subset of <code>Core.Compiler</code> functions, that are originally developed for Julia compiler&#39;s type inference and optimizations that aim at generating efficient native code for CPU execution.</p><p><a href="../generated-plugin-api/#JET.AbstractAnalyzer"><code>JET.AbstractAnalyzer</code></a> overloads a set of <code>Core.Compiler</code> functions to implement the &quot;core&quot; functionalities of JET&#39;s analysis, including inter-procedural error report propagation and caching of analysis result. And each plugin analyzer (e.g. <a href="@ref"><code>JET.JETAnalyzer</code></a>) will overload more <code>Core.Compiler</code> functions so that it can perform its own program analysis on top of the core <code>AbstractAnalyzer</code> infrastructure.</p><p>Most overloads use the <a href="https://docs.julialang.org/en/v1/base/base/#Core.invoke"><code>invoke</code></a> reflection, which allows <code>AbstractAnalyzer</code> to dispatch to the original <code>AbstractInterpreter</code>&#39;s abstract interpretation methods while still passing <code>AbstractAnalyzer</code> to the subsequent (maybe overloaded) callees (see <a href="#JET.@invoke"><code>JET.@invoke</code></a> macro).</p><article class="docstring"><header><a class="docstring-binding" id="JET.JETResult" href="#JET.JETResult"><code>JET.JETResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">JETResult</code></pre><p><code>result::InferenceResult</code> keeps the result of inference performed by <code>AbstractInterpreter</code>, where <code>result.src</code> holds the type-inferred source code.</p><p>JET&#39;s <a href="../generated-plugin-api/#JET.AbstractAnalyzer"><code>AbstractAnalyzer</code></a> uses the <code>result.src</code> field in a different way, where <code>result.src::JETResult</code> keeps both of error reports that are collected during inference and the type-inferred source code.</p><p>When cached, <code>JETResult</code> is transformed into <a href="#JET.JETCachedResult"><code>JETCachedResult</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/abstractinterpret/abstractanalyzer.jl#L539-L550">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.is_from_same_frame" href="#JET.is_from_same_frame"><code>JET.is_from_same_frame</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_from_same_frame(parent_linfo::MethodInstance, current_linfo::MethodInstance) -&gt;
    (report::InferenceErrorReport) -&gt; Bool</code></pre><p>Returns a function that checks if a given <code>InferenceErrorReport</code> is generated from <code>current_linfo</code>. It also checks <code>current_linfo</code> is a &quot;lineage&quot; of <code>parent_linfo</code> (i.e. entered from it).</p><p>This function is supposed to be used to filter out reports collected from analysis on <code>current_linfo</code> without using constants when entering into the constant analysis. As such, this function assumes that when a report should be filtered out, the first elment of its virtual stack frame <code>st</code> is for <code>parent_linfo</code> and the second element of that is for <code>current_linfo</code>.</p><p>Example: Assume <code>linfo2</code> will produce a report for some reason.</p><pre><code class="language-none">entry
└─ linfo1
   ├─ linfo2 (report1: linfo2)
   ├─ linfo3 (report1: linfo1-&gt;linfo2, report2: linfo3-&gt;linfo2)
   │  └─ linfo2 (report1: linfo1-&gt;linfo2, report2: linfo2)
   └─ linfo3′ (report1: linfo1-&gt;linfo2, ~~report2: linfo1-&gt;linfo3-&gt;linfo2~~)</code></pre><p>In the example analysis above, <code>report2</code> will be filtered out on re-entering into <code>linfo3′</code> (i.e. we&#39;re analyzing <code>linfo3</code> with constants argument), because <code>is_from_same_frame(linfo1, linfo3)(report2)</code> returns <code>true</code>. Note that <code>report1</code> is still kept there because of the lineage check, i.e. <code>is_from_same_frame(linfo1, linfo3)(report1)</code> returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/abstractinterpret/typeinfer.jl#L548-L574">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Compiler.bail_out_toplevel_call" href="#Core.Compiler.bail_out_toplevel_call"><code>Core.Compiler.bail_out_toplevel_call</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bail_out_toplevel_call(analyzer::AbstractAnalyzer, ...)</code></pre><p>An overload for <code>abstract_call_gf_by_type(analyzer::AbstractAnalyzer, ...)</code>, which keeps inference on non-concrete call sites in a toplevel frame created by <a href="#JET.virtual_process"><code>virtual_process</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/abstractinterpret/typeinfer.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Compiler.bail_out_call" href="#Core.Compiler.bail_out_call"><code>Core.Compiler.bail_out_call</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bail_out_call(analyzer::JETAnalyzer, ...)</code></pre><p>With this overload, <code>abstract_call_gf_by_type(analyzer::JETAnalyzer, ...)</code> doesn&#39;t bail out inference even after the current return type grows up to <code>Any</code> and collects as much error points as possible. Of course this slows down inference performance, but hoopefully it stays to be &quot;practical&quot; speed since the number of matching methods are limited beforehand.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/analyzers/jetanalyzer.jl#L295-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Compiler.add_call_backedges!" href="#Core.Compiler.add_call_backedges!"><code>Core.Compiler.add_call_backedges!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_call_backedges!(analyzer::JETAnalyzer, ...)</code></pre><p>An overload for <code>abstract_call_gf_by_type(analyzer::JETAnalyzer, ...)</code>, which always add backedges (even if a new method can&#39;t refine the return type grew up to <code>Any</code>). This is because a new method definition always has a potential to change <code>JETAnalyzer</code>&#39;s analysis result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/analyzers/jetanalyzer.jl#L306-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Compiler.const_prop_entry_heuristic" href="#Core.Compiler.const_prop_entry_heuristic"><code>Core.Compiler.const_prop_entry_heuristic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">const_prop_entry_heuristic(analyzer::JETAnalyzer, result::MethodCallResult, sv::InferenceState)</code></pre><p>This overload for <code>abstract_call_method_with_const_args(analyzer::JETAnalyzer, ...)</code> forces constant prop&#39; even if an inference result can&#39;t be improved anymore <em>with respect to the return type</em>, e.g. when <code>result.rt</code> is already <code>Const</code>. Especially, this overload implements an heuristic to force constant prop&#39; when any error points have been reported while the previous abstract method call without constant arguments. The reason we want much more aggressive constant propagation by that heuristic is that it&#39;s highly possible constant prop&#39; can produce more accurate analysis result, by throwing away false positive error reports by cutting off the unreachable control flow or detecting must-reachable <code>throw</code> calls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/analyzers/jetanalyzer.jl#L363-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.analyze_task_parallel_code!" href="#JET.analyze_task_parallel_code!"><code>JET.analyze_task_parallel_code!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">analyze_task_parallel_code!(analyzer::AbstractAnalyzer, argtypes::Vector{Any}, sv::InferenceState)</code></pre><p>Adds special cased analysis pass for task parallelism. In Julia&#39;s task parallelism implementation, parallel code is represented as closure and it&#39;s wrapped in a <code>Task</code> object. <code>NativeInterpreter</code> doesn&#39;t infer nor optimize the bodies of those closures when compiling code that creates parallel tasks, but JET will try to run additional analysis pass by recurring into the closures.</p><p>See also: <a href="https://github.com/aviatesk/JET.jl/issues/114">https://github.com/aviatesk/JET.jl/issues/114</a></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>JET won&#39;t do anything other than doing JET analysis, e.g. won&#39;t annotate return type of wrapped code block in order to not confuse the original <code>AbstractInterpreter</code> routine track <a href="https://github.com/JuliaLang/julia/pull/39773">https://github.com/JuliaLang/julia/pull/39773</a> for the changes in native abstract interpretation routine.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/abstractinterpret/typeinfer.jl#L217-L233">source</a></section></article><h3 id="How-AbstractAnalyzer-manages-caches"><a class="docs-heading-anchor" href="#How-AbstractAnalyzer-manages-caches">How <code>AbstractAnalyzer</code> manages caches</a><a id="How-AbstractAnalyzer-manages-caches-1"></a><a class="docs-heading-anchor-permalink" href="#How-AbstractAnalyzer-manages-caches" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JET.JET_CACHE" href="#JET.JET_CACHE"><code>JET.JET_CACHE</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">JET_CACHE::IdDict{UInt64, IdDict{Core.MethodInstance, Core.CodeInstance}}</code></pre><p>Keeps <code>src::CodeInstance</code> cache associated with <code>mi::MethodInstace</code> that represents the analysis result on <code>mi</code> performed by <a href="../generated-plugin-api/#JET.AbstractAnalyzer"><code>analyzer::AbstractAnalyzer</code></a>, where <a href="#JET.JETCachedResult"><code>src.inferred::JETCachedResult</code></a> caches JET&#39;s analysis result. This cache is separated by the identities of <code>AbstractAnalyzer</code>s, which are hash keys computed by <code>get_cache_key(analyzer::AbstractAnalyzer)</code>.</p><p><code>JET_CACHE</code> is completely separated from the <code>NativeInterpreter</code>&#39;s global cache, so that JET&#39;s analysis never interacts with actual code execution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/abstractinterpret/typeinfer.jl#L295-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.JETCachedResult" href="#JET.JETCachedResult"><code>JET.JETCachedResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">JETCachedResult</code></pre><p>When <a href="#JET.JETResult"><code>result::JETResult</code></a> is being cached, it&#39;s transformed into <code>cached::JETCachedResult</code> with its <code>result.reports::Vector{JET.InferenceErrorReport}</code> converted to <code>cached.reports::Vector{JET.InferenceErrorReportCache}</code>. When working with <a href="../generated-plugin-api/#JET.AbstractAnalyzer"><code>AbstractAnalyzer</code></a>, we can expect <code>codeinf::CodeInstance</code> to have the field <code>codeinf.inferred::JETCachedResult</code> as far as it&#39;s managed by <a href="#JET.JET_CACHE"><code>JET_CACHE</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/abstractinterpret/abstractanalyzer.jl#L556-L563">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.jet_inlining_policy" href="#JET.jet_inlining_policy"><code>JET.jet_inlining_policy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">jet_inlining_policy(src)</code></pre><p>Implements <code>Core.Compiler.inlining_policy</code> for <code>AbstractAnalyzer</code>. Since <code>AbstractAnalyzer</code> works on <code>InferenceResult</code> whose <code>src</code> field keeps <a href="#JET.JETResult"><code>JETResult</code></a> or <a href="#JET.JETCachedResult"><code>JETCachedResult</code></a>, <code>jet_inlining_policy</code> bypasses their wrapped source to <code>Core.Compiler.default_inlining_policy</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/abstractinterpret/abstractanalyzer.jl#L642-L649">source</a></section></article><h2 id="toplevel"><a class="docs-heading-anchor" href="#toplevel">Top-level Analysis</a><a id="toplevel-1"></a><a class="docs-heading-anchor-permalink" href="#toplevel" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JET.virtual_process" href="#JET.virtual_process"><code>JET.virtual_process</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">virtual_process(s::AbstractString,
                filename::AbstractString,
                analyzer::AbstractAnalyzer,
                config::ToplevelConfig,
                ) -&gt; res::VirtualProcessResult</code></pre><p>Simulates Julia&#39;s toplevel execution and collects error points, and finally returns <code>res::VirtualProcessResult</code></p><ul><li><code>res.included_files::Set{String}</code>: files that have been analyzed</li><li><code>res.toplevel_error_reports::Vector{ToplevelErrorReport}</code>: toplevel errors found during the   text parsing or partial (actual) interpretation; these reports are &quot;critical&quot; and should   have precedence over <code>inference_error_reports</code></li><li><code>res.inference_error_reports::Vector{InferenceErrorReport}</code>: possible error reports found   by <code>AbstractAnalyzer</code></li><li><code>res.toplevel_signatures</code>: signatures of methods defined within the analyzed files</li><li><code>res.actual2virtual::Pair{Module, Module}</code>: keeps actual and virtual module</li></ul><p>This function first parses <code>s::AbstractString</code> into <code>toplevelex::Expr</code> and then iterate the following steps on each code block (<code>blk</code>) of <code>toplevelex</code>:</p><ol><li>if <code>blk</code> is a <code>:module</code> expression, recusively enters analysis into an newly defined virtual module</li><li><code>lower</code>s <code>blk</code> into <code>:thunk</code> expression <code>lwr</code> (macros are also expanded in this step)</li><li>if the context module is virtualized, replaces self-references of the original context module with virtualized one: see <code>fix_self_references</code></li><li><code>ConcreteInterpreter</code> partially interprets some statements in <code>lwr</code> that should not be abstracted away (e.g. a <code>:method</code> definition); see also <a href="#JET.partially_interpret!"><code>partially_interpret!</code></a></li><li>finally, <code>AbstractAnalyzer</code> analyzes the remaining statements by abstract interpretation</li></ol><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>In order to process the toplevel code sequentially as Julia runtime does, <code>virtual_process</code> splits the entire code, and then iterate a simulation process on each code block. With this approach, we can&#39;t track the inter-code-block level dependencies, and so a partial interpretation of toplevle definitions will fail if it needs an access to global variables defined in other code blocks that are not interpreted but just abstracted. We can circumvent this issue using JET&#39;s <code>concretization_patterns</code> configuration, which allows us to customize JET&#39;s concretization strategy. See <a href="../config/#JET.ToplevelConfig"><code>ToplevelConfig</code></a> for more details.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/toplevel/virtualprocess.jl#L242-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.virtualize_module_context" href="#JET.virtualize_module_context"><code>JET.virtualize_module_context</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">virtualize_module_context(actual::Module)</code></pre><p>HACK: Returns a module where the context of <code>actual</code> is virtualized.</p><p>The virtualization will be done by 2 steps below:</p><ol><li>loads the module context of <code>actual</code> into a sandbox module, and export the whole context from there</li><li>then uses names exported from the sandbox</li></ol><p>This way, JET&#39;s runtime simulation in the virtual module context will be able to define a name that is already defined in <code>actual</code> without causing &quot;cannot assign a value to variable ... from module ...&quot; error, etc. It allows JET to virtualize the context of already-existing module other than <code>Main</code>.</p><div class="admonition is-warning"><header class="admonition-header">TODO</header><div class="admonition-body"><p>Currently this function relies on <code>Base.names</code>, and thus it can&#39;t restore the <code>using</code>ed names.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/toplevel/virtualprocess.jl#L313-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.ConcreteInterpreter" href="#JET.ConcreteInterpreter"><code>JET.ConcreteInterpreter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConcreteInterpreter</code></pre><p>The trait to inject code into JuliaInterpreter&#39;s interpretation process; JET.jl overloads:</p><ul><li><code>JuliaInterpreter.step_expr!</code> to add error report pass for module usage expressions and support package analysis</li><li><code>JuliaInterpreter.evaluate_call_recurse!</code> to special case <code>include</code> calls</li><li><code>JuliaInterpreter.handle_err</code> to wrap an error happened during interpretation into <code>ActualErrorWrapped</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/toplevel/virtualprocess.jl#L743-L752">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.partially_interpret!" href="#JET.partially_interpret!"><code>JET.partially_interpret!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">partially_interpret!(interp::ConcreteInterpreter, mod::Module, src::CodeInfo)</code></pre><p>Partially interprets statements in <code>src</code> using JuliaInterpreter.jl:</p><ul><li>concretizes &quot;toplevel definitions&quot;, i.e. <code>:method</code>, <code>:struct_type</code>, <code>:abstract_type</code> and <code>:primitive_type</code> expressions and their dependencies</li><li>concretizes user-specified toplevel code (see <a href="../config/#JET.ToplevelConfig"><code>ToplevelConfig</code></a>)</li><li>directly evaluates module usage expressions and report error of invalid module usages (TODO: enter into the loaded module and keep JET analysis)</li><li>special-cases <code>include</code> calls so that top-level analysis recursively enters the included file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/toplevel/virtualprocess.jl#L763-L773">source</a></section></article><h3 id="How-top-level-analysis-is-bridged-to-AbstractAnalyzer"><a class="docs-heading-anchor" href="#How-top-level-analysis-is-bridged-to-AbstractAnalyzer">How top-level analysis is bridged to <code>AbstractAnalyzer</code></a><a id="How-top-level-analysis-is-bridged-to-AbstractAnalyzer-1"></a><a class="docs-heading-anchor-permalink" href="#How-top-level-analysis-is-bridged-to-AbstractAnalyzer" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JET.AbstractGlobal" href="#JET.AbstractGlobal"><code>JET.AbstractGlobal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct AbstractGlobal
    t::Any     # analyzed type
    iscd::Bool # is this abstract global variable declarared as constant or not
end</code></pre><p>Wraps a global variable whose type is analyzed by abtract interpretation. <code>AbstractGlobal</code> object will be actually evaluated into the context module, and a later analysis may refer to or alter its type on future load and store operations.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The type of the wrapped global variable will be propagated only when in a toplevel frame, and thus we don&#39;t care about the analysis cache invalidation on a refinement of the wrapped global variable, since JET doesn&#39;t cache the toplevel frame.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/abstractinterpret/typeinfer.jl#L4-L18">source</a></section></article><h2 id="Analysis-Results"><a class="docs-heading-anchor" href="#Analysis-Results">Analysis Results</a><a id="Analysis-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-Results" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JET.JETToplevelResult" href="#JET.JETToplevelResult"><code>JET.JETToplevelResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">res::JETToplevelResult</code></pre><p>Represents the result of JET&#39;s analysis on a top-level script.</p><ul><li><code>res.analyzer::AbstractAnalyzer</code>: <a href="../generated-plugin-api/#JET.AbstractAnalyzer"><code>AbstractAnalyzer</code></a> used for this analysis</li><li><code>res.res::VirtualProcessResult</code>: <a href="@ref"><code>VirtualProcessResult</code></a> collected from this analysis</li><li><code>res.source::String</code>: the identity key of this analysis</li><li><code>res.jetconfigs</code>: <a href="../config/#JET-configurations">JET configurations</a> used for this analysis</li></ul><p><code>JETToplevelResult</code> implements <code>show</code> methods for each different frontend. An appropriate <code>show</code> method will be automatically choosen and render the analysis result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/JET.jl#L528-L539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.JETCallResult" href="#JET.JETCallResult"><code>JET.JETCallResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">res::JETCallResult</code></pre><p>Represents the result of JET&#39;s analysis on a function call.</p><ul><li><code>res.result::InferenceResult</code>: the result of this analysis</li><li><code>res.analyzer::AbstractAnalyzer</code>: <a href="../generated-plugin-api/#JET.AbstractAnalyzer"><code>AbstractAnalyzer</code></a> used for this analysis</li><li><code>res.source::String</code>: the identity key of this analysis</li><li><code>res.jetconfigs</code>: <a href="../config/#JET-configurations">JET configurations</a> used for this analysis</li></ul><p><code>JETCallResult</code> implements <code>show</code> methods for each different frontend. An appropriate <code>show</code> method will be automatically choosen and render the analysis result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/JET.jl#L551-L562">source</a></section></article><h2 id="Error-Report-Interface"><a class="docs-heading-anchor" href="#Error-Report-Interface">Error Report Interface</a><a id="Error-Report-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Report-Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JET.VirtualFrame" href="#JET.VirtualFrame"><code>JET.VirtualFrame</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VirtualFrame</code></pre><p>Stack information representing virtual execution context:</p><ul><li><code>file::Symbol</code>: the path to the file containing the virtual execution context</li><li><code>line::Int</code>: the line number in the file containing the virtual execution context</li><li><code>sig::Vector{Any}</code>: a signature of this frame</li><li><code>linfo::MethodInstance</code>: The <code>MethodInstance</code> containing the execution context</li></ul><p>This type is very similar to <code>Base.StackTraces.StackFrame</code>, but its execution context is collected during abstract interpration, not collected from actual execution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/abstractinterpret/inferenceerrorreport.jl#L7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.VirtualStackTrace" href="#JET.VirtualStackTrace"><code>JET.VirtualStackTrace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VirtualStackTrace</code></pre><p>Represents a virtual stack trace in the form of a vector of <code>VirtualFrame</code>. The vector holds <code>VirtualFrame</code>s in order of &quot;from entry call site to error point&quot;, i.e. the first element is the <code>VirtualFrame</code> of the entry call site, and the last element is that contains the error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/abstractinterpret/inferenceerrorreport.jl#L26-L33">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>JET.InferenceErrorReport</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="JET.ToplevelErrorReport" href="#JET.ToplevelErrorReport"><code>JET.ToplevelErrorReport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ToplevelErrorReport</code></pre><p>An interface type of error reports that JET collects while top-level concrete interpration. All <code>ToplevelErrorReport</code> should have the following fields:</p><ul><li><code>file::String</code>: the path to the file containing the interpretation context</li><li><code>line::Int</code>: the line number in the file containing the interpretation context</li></ul><p>See also: <a href="#JET.virtual_process"><code>virtual_process</code></a>, <a href="#JET.ConcreteInterpreter"><code>ConcreteInterpreter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/toplevel/virtualprocess.jl#L1-L10">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JET.@invoke" href="#JET.@invoke"><code>JET.@invoke</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@invoke f(arg::T, ...; kwargs...)</code></pre><p>Provides a convenient way to call <a href="https://docs.julialang.org/en/v1/base/base/#Core.invoke"><code>invoke</code></a>; <code>@invoke f(arg1::T1, arg2::T2; kwargs...)</code> will be expanded into <code>invoke(f, Tuple{T1,T2}, arg1, arg2; kwargs...)</code>. When an argument&#39;s type annotation is omitted, it&#39;s specified as <code>Any</code> argument, e.g. <code>@invoke f(arg1::T, arg2)</code> will be expanded into <code>invoke(f, Tuple{T,Any}, arg1, arg2)</code>.</p><p>This could be used to call down to <code>NativeInterpreter</code>&#39;s abstract interpretation method of <code>f</code> while passing <code>AbstractAnalyzer</code> so that subsequent calls of abstract interpretation functions overloaded against <code>AbstractAnalyzer</code> can be called from the native method of <code>f</code>. E.g. <code>@invoke</code> can be used to call down to <code>NativeInterpreter</code>&#39;s <code>abstract_call_gf_by_type</code>:</p><pre><code class="language-julia">@invoke abstract_call_gf_by_type(analyzer::AbstractInterpreter, f, argtypes::Vector{Any}, atype, sv::InferenceState,
                                 max_methods::Int)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/JET.jl#L261-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.@invokelatest" href="#JET.@invokelatest"><code>JET.@invokelatest</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@invokelatest f(args...; kwargs...)</code></pre><p>Provides a convenient way to call <a href="https://docs.julialang.org/en/v1/base/base/#Base.invokelatest"><code>Base.invokelatest</code></a>. <code>@invokelatest f(args...; kwargs...)</code> will simply be expanded into <code>Base.invokelatest(f, args...; kwargs...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/JET.jl#L290-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.@withmixedhash" href="#JET.@withmixedhash"><code>JET.@withmixedhash</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@withmixedhash (mutable) struct T
    fields ...
end</code></pre><p>Defines struct <code>T</code> while automatically defining its <code>Base.hash(::T, ::UInt)</code> method which mixes hashes of all of <code>T</code>&#39;s fields (and also corresponding <code>Base.:(==)(::T, ::T)</code> method).</p><p>This macro is supposed to abstract the following kind of pattern:</p><blockquote><p>https://github.com/aviatesk/julia/blob/999973df2850d6b2e0bd4bcf03ef90a14217b63c/base/pkgid.jl#L3-L25</p></blockquote><pre><code class="language-julia">struct PkgId
    uuid::Union{UUID,Nothing}
    name::String
end

==(a::PkgId, b::PkgId) = a.uuid == b.uuid &amp;&amp; a.name == b.name

function hash(pkg::PkgId, h::UInt)
    h += 0xc9f248583a0ca36c % UInt
    h = hash(pkg.uuid, h)
    h = hash(pkg.name, h)
    return h
end</code></pre><blockquote><p>with <code>@withmixedhash</code></p></blockquote><pre><code class="language-julia">@withmixedhash struct PkgId
    uuid::Union{UUID,Nothing}
    name::String
end</code></pre><p>See also: <a href="@ref"><code>EGAL_TYPES</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/JET.jl#L321-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.@jetconfigurable" href="#JET.@jetconfigurable"><code>JET.@jetconfigurable</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@jetconfigurable function config_func(args...; configurations...)
    ...
end</code></pre><p>This macro asserts that there&#39;s no configuration naming conflict across the <code>@jetconfigurable</code> functions so that a configuration for a <code>@jetconfigurable</code> function  doesn&#39;t affect the other <code>@jetconfigurable</code> functions. This macro also adds a dummy splat keyword arguments (<code>jetconfigs...</code>) to the function definition so that any configuration of other <code>@jetconfigurable</code> functions can be passed on to it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/03429afb954cf9ad99bfce60da1f117cb9fda9b8/src/JET.jl#L411-L421">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../config/">« Configurations</a><a class="docs-footer-nextpage" href="../generated-plugin-api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 31 August 2021 18:58">Tuesday 31 August 2021</span>. Using Julia version 1.8.0-DEV.447.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
