<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · JET.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JET.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">README</a></li><li><a class="tocitem" href="../usages/">Usages</a></li><li><a class="tocitem" href="../config/">Configurations</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#Abstract-Interpretation-Based-Analysis"><span>Abstract Interpretation Based Analysis</span></a></li><li><a class="tocitem" href="#Top-level-Analysis"><span>Top-level Analysis</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aviatesk/JET.jl/blob/master/docs/src/internals.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Internals-of-JET.jl"><a class="docs-heading-anchor" href="#Internals-of-JET.jl">Internals of JET.jl</a><a id="Internals-of-JET.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Internals-of-JET.jl" title="Permalink"></a></h1><h2 id="Abstract-Interpretation-Based-Analysis"><a class="docs-heading-anchor" href="#Abstract-Interpretation-Based-Analysis">Abstract Interpretation Based Analysis</a><a id="Abstract-Interpretation-Based-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Interpretation-Based-Analysis" title="Permalink"></a></h2><p>JET.jl overloads functions with the <a href="https://github.com/JuliaLang/julia/blob/master/base/compiler/types.jl"><code>Core.Compiler.AbstractInterpreter</code> interface</a>, and customizes its abstract interpretation routine. The overloads are done on <code>JETInterpreter &lt;: AbstractInterpreter</code> so that <code>typeinf(::JETInterpreter, ::InferenceState)</code> will do the customized abstract interpretation and collect type errors.</p><p>Most overloads use the <a href="https://docs.julialang.org/en/v1/base/base/#Core.invoke"><code>invoke</code></a> reflection, which allows <code>JETInterpreter</code> to dispatch to the original <code>AbstractInterpreter</code>&#39;s abstract interpretation methods and still keep passing it to the subsequent (maybe overloaded) callees (see <a href="#JET.@invoke"><code>JET.@invoke</code></a> macro).</p><article class="docstring"><header><a class="docstring-binding" id="Core.Compiler.bail_out_toplevel_call" href="#Core.Compiler.bail_out_toplevel_call"><code>Core.Compiler.bail_out_toplevel_call</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bail_out_toplevel_call(interp::JETInterpreter, ...)</code></pre><p>An overload for <code>abstract_call_gf_by_type(interp::JETInterpreter, ...)</code>, which keeps   inference on non-concrete call sites in a toplevel frame created by   <a href="#JET.virtual_process"><code>virtual_process</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/578c0d2b4c1879195af5fe22c84212696743db67/src/abstractinterpretation.jl#L75-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Compiler.bail_out_call" href="#Core.Compiler.bail_out_call"><code>Core.Compiler.bail_out_call</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bail_out_call(interp::JETInterpreter, ...)</code></pre><p>With this overload, <code>abstract_call_gf_by_type(interp::JETInterpreter, ...)</code> doesn&#39;t bail out   inference even after the current return type grows up to <code>Any</code> and collects as much error   points as possible. Of course this slows down inference performance, but hoopefully it stays to be &quot;practical&quot;   speed since the number of matching methods are limited beforehand.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/578c0d2b4c1879195af5fe22c84212696743db67/src/abstractinterpretation.jl#L86-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Compiler.add_call_backedges!" href="#Core.Compiler.add_call_backedges!"><code>Core.Compiler.add_call_backedges!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_call_backedges!(interp::JETInterpreter, ...)</code></pre><p>An overload for <code>abstract_call_gf_by_type(interp::JETInterpreter, ...)</code>, which always add   backedges (even if a new method can&#39;t refine the return type grew up to <code>Any</code>). This is because a new method definition always has a potential to change the JET analysis result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/578c0d2b4c1879195af5fe22c84212696743db67/src/abstractinterpretation.jl#L97-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Compiler.const_prop_entry_heuristic" href="#Core.Compiler.const_prop_entry_heuristic"><code>Core.Compiler.const_prop_entry_heuristic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">const_prop_entry_heuristic(interp::JETInterpreter, @nospecialize(rettype), sv::InferenceState, edgecycle::Bool)</code></pre><p>An overload for <code>abstract_call_method_with_const_args(interp::JETInterpreter, ...)</code>, which   forces constant prop&#39; even if the inference result can&#39;t be improved anymore, e.g. when   <code>rettype</code> is already <code>Const</code>; this is because constant prop&#39; can still produce more accurate   analysis by throwing away false positive error reports by cutting off the unreachable   control flow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/578c0d2b4c1879195af5fe22c84212696743db67/src/abstractinterpretation.jl#L144-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.analyze_task_parallel_code!" href="#JET.analyze_task_parallel_code!"><code>JET.analyze_task_parallel_code!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">analyze_task_parallel_code!(interp::JETInterpreter, @nospecialize(f), argtypes::Vector{Any}, sv::InferenceState)</code></pre><p>Adds special cased analysis pass for task parallelism (xref: <a href="https://github.com/aviatesk/JET.jl/issues/114">https://github.com/aviatesk/JET.jl/issues/114</a>). In Julia&#39;s task parallelism implementation, parallel code is represented as closure and it&#39;s   wrapped in a <code>Task</code> object. <code>NativeInterpreter</code> doesn&#39;t run type inference nor optimization   on the body of those closures when compiling code that creates parallel tasks, but JET will   try to run additional analysis pass by recurring into the closures.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>JET won&#39;t do anything other than doing JET analysis, e.g. won&#39;t annotate return type of wrapped code block in order to not confuse the original <code>AbstractInterpreter</code> routine track <a href="https://github.com/JuliaLang/julia/pull/39773">https://github.com/JuliaLang/julia/pull/39773</a> for the changes in native abstract interpretation routine.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/578c0d2b4c1879195af5fe22c84212696743db67/src/abstractinterpretation.jl#L172-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.is_from_same_frame" href="#JET.is_from_same_frame"><code>JET.is_from_same_frame</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_from_same_frame(parent_linfo::MethodInstance, current_linfo::MethodInstance) -&gt;
    (report::InferenceErrorReport) -&gt; Bool</code></pre><p>Returns a function that checks if a given <code>InferenceErrorReport</code> is generated from <code>current_linfo</code>. It also checks <code>current_linfo</code> is a &quot;lineage&quot; of <code>parent_linfo</code> (i.e. entered from it).</p><p>This function is supposed to be used to filter out reports from analysis on <code>current_linfo</code>   without using constants when entering into the constant analysis. As such, this function   assumes that when a report should be filtered out, the first elment of its virtual stack   frame <code>st</code> is for <code>parent_linfo</code> and the second element of that is for <code>current_linfo</code>.</p><p>Example: Assume <code>linfo2</code> will produce a report for some reason. In the example analysis below, <code>report2</code> will be filtered out on re-entering into <code>linfo3</code>   with constants (i.e. <code>linfo3′</code>). Note that <code>report1</code> is still kept there because of the   lineage check.</p><pre><code class="language-none">entry
└─ linfo1
   ├─ linfo2 (report1: linfo2)
   ├─ linfo3 (report1: linfo1-&gt;linfo2, report2: linfo3-&gt;linfo2)
   │  └─ linfo2 (report1: linfo2, report2: linfo2)
   └─ linfo3′ (report1: linfo1-&gt;linfo2, ~~report2: linfo1-&gt;linfo3-&gt;linfo2~~)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/578c0d2b4c1879195af5fe22c84212696743db67/src/typeinfer.jl#L214-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.AbstractGlobal" href="#JET.AbstractGlobal"><code>JET.AbstractGlobal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct AbstractGlobal
    t::Any     # analyzed type
    iscd::Bool # whether this abstract global variable is declarared as constant or not
end</code></pre><p>Wraps a global variable whose type is analyzed by abtract interpretation. <code>AbstractGlobal</code> object will be actually evaluated into the context module, and a later   analysis may refer to its type or alter it on another assignment.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The type of the wrapped global variable will be propagated only when in a toplevel frame,   and thus we don&#39;t care about the analysis cache invalidation on a refinement of the   wrapped global variable, since JET doesn&#39;t cache the toplevel frame.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/578c0d2b4c1879195af5fe22c84212696743db67/src/abstractinterpretation.jl#L1-L15">source</a></section></article><h2 id="Top-level-Analysis"><a class="docs-heading-anchor" href="#Top-level-Analysis">Top-level Analysis</a><a id="Top-level-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Top-level-Analysis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JET.virtual_process" href="#JET.virtual_process"><code>JET.virtual_process</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">virtual_process(s::AbstractString,
                filename::AbstractString,
                interp::JETInterpreter,
                config::ToplevelConfig,
                ) -&gt; res::VirtualProcessResult</code></pre><p>Simulates Julia&#39;s toplevel execution and collects error points, and finally returns <code>res::VirtualProcessResult</code></p><ul><li><code>res.included_files::Set{String}</code>: files that have been analyzed</li><li><code>res.toplevel_error_reports::Vector{ToplevelErrorReport}</code>: toplevel errors found during the   text parsing or partial (actual) interpretation; these reports are &quot;critical&quot; and should   have precedence over <code>inference_error_reports</code></li><li><code>res.inference_error_reports::Vector{InferenceErrorReport}</code>: possible error reports found   by <code>JETInterpreter</code></li><li><code>res.toplevel_signatures</code>: signatures of methods defined within the analyzed files</li><li><code>res.actual2virtual::Pair{Module, Module}</code>: keeps actual and virtual module</li></ul><p>This function first parses <code>s::AbstractString</code> into <code>toplevelex::Expr</code> and then iterate the   following steps on each code block (<code>blk</code>) of <code>toplevelex</code>:</p><ol><li>if <code>blk</code> is a <code>:module</code> expression, recusively enters analysis into an newly defined   virtual module</li><li><code>lower</code>s <code>blk</code> into <code>:thunk</code> expression <code>lwr</code> (macros are also expanded in this step)</li><li>if the context module is virtualized, replaces self-references of the original context   module with virtualized one: see <code>fix_self_references</code></li><li><code>ConcreteInterpreter</code> partially interprets some statements in <code>lwr</code> that should not be   abstracted away (e.g. a <code>:method</code> definition); see also <a href="#JET.partially_interpret!"><code>partially_interpret!</code></a></li><li>finally, <code>JETInterpreter</code> analyzes the remaining statements by abstract interpretation</li></ol><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>In order to process the toplevel code sequentially as Julia runtime does, <code>virtual_process</code>   splits the entire code, and then iterate a simulation process on each code block. With this approach, we can&#39;t track the inter-code-block level dependencies, and so a   partial interpretation of toplevle definitions will fail if it needs an access to global   variables defined in other code blocks that are not interpreted but just abstracted. We can circumvent this issue using JET&#39;s <code>concretization_patterns</code> configuration, which   allows us to customize JET&#39;s concretization strategy. See <a href="../config/#JET.ToplevelConfig"><code>ToplevelConfig</code></a> for more details.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/578c0d2b4c1879195af5fe22c84212696743db67/src/virtualprocess.jl#L188-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.virtualize_module_context" href="#JET.virtualize_module_context"><code>JET.virtualize_module_context</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">virtualize_module_context(actual::Module)</code></pre><p>HACK: Returns a module where the context of <code>actual</code> is virtualized.</p><p>The virtualization will be done by 2 steps below:</p><ol><li>loads the module context of <code>actual</code> into a sandbox module, and export the whole context from there</li><li>then uses names exported from the sandbox</li></ol><p>This way, JET&#39;s runtime simulation in the virtual module context will be able to define a name   that is already defined in <code>actual</code> without causing   &quot;cannot assign a value to variable ... from module ...&quot; error, etc. It allows JET to virtualize the context of already-existing module other than <code>Main</code>.</p><div class="admonition is-warning"><header class="admonition-header">TODO</header><div class="admonition-body"><p>Currently this function relies on <code>Base.names</code>, and thus it can&#39;t restore the <code>using</code>ed   names.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/578c0d2b4c1879195af5fe22c84212696743db67/src/virtualprocess.jl#L256-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.ConcreteInterpreter" href="#JET.ConcreteInterpreter"><code>JET.ConcreteInterpreter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConcreteInterpreter</code></pre><p>The trait to inject code into JuliaInterpreter&#39;s interpretation process; JET.jl overloads:</p><ul><li><code>JuliaInterpreter.step_expr!</code> to add error report pass for module usage expressions and   support package analysis</li><li><code>JuliaInterpreter.evaluate_call_recurse!</code> to special case <code>include</code> calls</li><li><code>JuliaInterpreter.handle_err</code> to wrap an error happened during interpretation into   <code>ActualErrorWrapped</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/578c0d2b4c1879195af5fe22c84212696743db67/src/virtualprocess.jl#L614-L623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.partially_interpret!" href="#JET.partially_interpret!"><code>JET.partially_interpret!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">partially_interpret!(interp::ConcreteInterpreter, mod::Module, src::CodeInfo)</code></pre><p>Partially interprets statements in <code>src</code> using JuliaInterpreter.jl:</p><ul><li>concretizes &quot;toplevel definitions&quot;, i.e. <code>:method</code>, <code>:struct_type</code>, <code>:abstract_type</code> and   <code>:primitive_type</code> expressions and their dependencies</li><li>concretizes user-specified toplevel code (see <a href="../config/#JET.ToplevelConfig"><code>ToplevelConfig</code></a>)</li><li>directly evaluates module usage expressions and report error of invalid module usages (TODO: enter into the loaded module and keep JET analysis)</li><li>special-cases <code>include</code> calls so that top-level analysis recursively enters the included file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/578c0d2b4c1879195af5fe22c84212696743db67/src/virtualprocess.jl#L634-L644">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JET.@invoke" href="#JET.@invoke"><code>JET.@invoke</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@invoke f(arg::T, ...; kwargs...)</code></pre><p>Provides a convenient way to call <a href="https://docs.julialang.org/en/v1/base/base/#Core.invoke"><code>invoke</code></a>; <code>@invoke f(arg1::T1, arg2::T2; kwargs...)</code> will be expanded into <code>invoke(f, Tuple{T1,T2}, arg1, arg2; kwargs...)</code>. When an argument&#39;s type annotation is omitted, it&#39;s specified as <code>Any</code> argument, e.g. <code>@invoke f(arg1::T, arg2)</code> will be expanded into <code>invoke(f, Tuple{T,Any}, arg1, arg2)</code>.</p><p>This could be used to call down to <code>NativeInterpreter</code>&#39;s abstract interpretation method of   <code>f</code> while passing <code>JETInterpreter</code> so that subsequent calls of abstract interpretation   functions overloaded against <code>JETInterpreter</code> can be called from the native method of <code>f</code>; e.g. calls down to <code>NativeInterpreter</code>&#39;s <code>abstract_call_gf_by_type</code> method:</p><pre><code class="language-julia">@invoke abstract_call_gf_by_type(interp::AbstractInterpreter, f, argtypes::Vector{Any}, atype, sv::InferenceState,
                                 max_methods::Int)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/578c0d2b4c1879195af5fe22c84212696743db67/src/JET.jl#L195-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.@invokelatest" href="#JET.@invokelatest"><code>JET.@invokelatest</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@invokelatest f(args...; kwargs...)</code></pre><p>Provides a convenient way to call <a href="https://docs.julialang.org/en/v1/base/base/#Base.invokelatest"><code>Base.invokelatest</code></a>. <code>@invokelatest f(args...; kwargs...)</code> will simply be expanded into <code>Base.invokelatest(f, args...; kwargs...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/578c0d2b4c1879195af5fe22c84212696743db67/src/JET.jl#L224-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.@withmixedhash" href="#JET.@withmixedhash"><code>JET.@withmixedhash</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@withmixedhash (mutable) struct T
    fields ...
end</code></pre><p>Defines struct <code>T</code> while automatically defining its <code>Base.hash(::T, ::UInt)</code> method which   mixes hashes of all of <code>T</code>&#39;s fields (and also corresponding <code>Base.:(==)(::T, ::T)</code> method).</p><p>This macro is supposed to abstract the following kind of pattern:</p><blockquote><p>https://github.com/aviatesk/julia/blob/999973df2850d6b2e0bd4bcf03ef90a14217b63c/base/pkgid.jl#L3-L25</p></blockquote><pre><code class="language-julia">struct PkgId
    uuid::Union{UUID,Nothing}
    name::String
end

==(a::PkgId, b::PkgId) = a.uuid == b.uuid &amp;&amp; a.name == b.name

function hash(pkg::PkgId, h::UInt)
    h += 0xc9f248583a0ca36c % UInt
    h = hash(pkg.uuid, h)
    h = hash(pkg.name, h)
    return h
end</code></pre><blockquote><p>with <code>@withmixedhash</code></p></blockquote><pre><code class="language-julia">@withmixedhash struct PkgId
    uuid::Union{UUID,Nothing}
    name::String
end</code></pre><p>See also: <a href="@ref"><code>EGAL_TYPES</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/578c0d2b4c1879195af5fe22c84212696743db67/src/JET.jl#L255-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.@jetconfigurable" href="#JET.@jetconfigurable"><code>JET.@jetconfigurable</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@jetconfigurable function config_func(args...; configurations...)
    ...
end</code></pre><p>This macro asserts that there&#39;s no configuration naming conflict across the <code>@jetconfigurable</code>   functions so that a configuration for a <code>@jetconfigurable</code> function  doesn&#39;t affect the other   <code>@jetconfigurable</code> functions. This macro also adds a dummy splat keyword arguments (<code>jetconfigs...</code>) to the function definition   so that any configuration of other <code>@jetconfigurable</code> functions can be passed on to it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/578c0d2b4c1879195af5fe22c84212696743db67/src/JET.jl#L347-L357">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../config/">« Configurations</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 16 April 2021 12:46">Friday 16 April 2021</span>. Using Julia version 1.7.0-DEV.931.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
